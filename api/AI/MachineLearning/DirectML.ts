/// Auto-generated by Deno Win32: Windows.Win32.AI.MachineLearning.DirectML.Apis

import * as util from "../../../util.ts";

// Enums
export type DML_TENSOR_DATA_TYPE = number;
export type DML_TENSOR_TYPE = number;
export type DML_TENSOR_FLAGS = number;
export type DML_OPERATOR_TYPE = number;
export type DML_REDUCE_FUNCTION = number;
export type DML_MATRIX_TRANSFORM = number;
export type DML_CONVOLUTION_MODE = number;
export type DML_CONVOLUTION_DIRECTION = number;
export type DML_PADDING_MODE = number;
export type DML_INTERPOLATION_MODE = number;
export type DML_RECURRENT_NETWORK_DIRECTION = number;
export type DML_ROUNDING_MODE = number;
export type DML_IS_INFINITY_MODE = number;
export type DML_AXIS_DIRECTION = number;
export type DML_DEPTH_SPACE_ORDER = number;
export type DML_RANDOM_GENERATOR_TYPE = number;
export type DML_FEATURE_LEVEL = number;
export type DML_FEATURE = number;
export type DML_EXECUTION_FLAGS = number;
export type DML_CREATE_DEVICE_FLAGS = number;
export type DML_BINDING_TYPE = number;
export type DML_GRAPH_EDGE_TYPE = number;
export type DML_GRAPH_NODE_TYPE = number;

// Constants
export const DML_TARGET_VERSION = 16384;
export const DML_TENSOR_DIMENSION_COUNT_MAX = 5;
export const DML_TENSOR_DIMENSION_COUNT_MAX1 = 8;
export const DML_TEMPORARY_BUFFER_ALIGNMENT = 256;
export const DML_PERSISTENT_BUFFER_ALIGNMENT = 256;
export const DML_MINIMUM_BUFFER_TENSOR_ALIGNMENT = 16;
export const DML_TENSOR_DATA_TYPE_UNKNOWN = 0;
export const DML_TENSOR_DATA_TYPE_FLOAT32 = 1;
export const DML_TENSOR_DATA_TYPE_FLOAT16 = 2;
export const DML_TENSOR_DATA_TYPE_UINT32 = 3;
export const DML_TENSOR_DATA_TYPE_UINT16 = 4;
export const DML_TENSOR_DATA_TYPE_UINT8 = 5;
export const DML_TENSOR_DATA_TYPE_INT32 = 6;
export const DML_TENSOR_DATA_TYPE_INT16 = 7;
export const DML_TENSOR_DATA_TYPE_INT8 = 8;
export const DML_TENSOR_DATA_TYPE_FLOAT64 = 9;
export const DML_TENSOR_DATA_TYPE_UINT64 = 10;
export const DML_TENSOR_DATA_TYPE_INT64 = 11;
export const DML_TENSOR_TYPE_INVALID = 0;
export const DML_TENSOR_TYPE_BUFFER = 1;
export const DML_TENSOR_FLAG_NONE = 0;
export const DML_TENSOR_FLAG_OWNED_BY_DML = 1;
export const DML_OPERATOR_INVALID = 0;
export const DML_OPERATOR_ELEMENT_WISE_IDENTITY = 1;
export const DML_OPERATOR_ELEMENT_WISE_ABS = 2;
export const DML_OPERATOR_ELEMENT_WISE_ACOS = 3;
export const DML_OPERATOR_ELEMENT_WISE_ADD = 4;
export const DML_OPERATOR_ELEMENT_WISE_ASIN = 5;
export const DML_OPERATOR_ELEMENT_WISE_ATAN = 6;
export const DML_OPERATOR_ELEMENT_WISE_CEIL = 7;
export const DML_OPERATOR_ELEMENT_WISE_CLIP = 8;
export const DML_OPERATOR_ELEMENT_WISE_COS = 9;
export const DML_OPERATOR_ELEMENT_WISE_DIVIDE = 10;
export const DML_OPERATOR_ELEMENT_WISE_EXP = 11;
export const DML_OPERATOR_ELEMENT_WISE_FLOOR = 12;
export const DML_OPERATOR_ELEMENT_WISE_LOG = 13;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_AND = 14;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_EQUALS = 15;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN = 16;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN = 17;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_NOT = 18;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_OR = 19;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_XOR = 20;
export const DML_OPERATOR_ELEMENT_WISE_MAX = 21;
export const DML_OPERATOR_ELEMENT_WISE_MEAN = 22;
export const DML_OPERATOR_ELEMENT_WISE_MIN = 23;
export const DML_OPERATOR_ELEMENT_WISE_MULTIPLY = 24;
export const DML_OPERATOR_ELEMENT_WISE_POW = 25;
export const DML_OPERATOR_ELEMENT_WISE_CONSTANT_POW = 26;
export const DML_OPERATOR_ELEMENT_WISE_RECIP = 27;
export const DML_OPERATOR_ELEMENT_WISE_SIN = 28;
export const DML_OPERATOR_ELEMENT_WISE_SQRT = 29;
export const DML_OPERATOR_ELEMENT_WISE_SUBTRACT = 30;
export const DML_OPERATOR_ELEMENT_WISE_TAN = 31;
export const DML_OPERATOR_ELEMENT_WISE_THRESHOLD = 32;
export const DML_OPERATOR_ELEMENT_WISE_QUANTIZE_LINEAR = 33;
export const DML_OPERATOR_ELEMENT_WISE_DEQUANTIZE_LINEAR = 34;
export const DML_OPERATOR_ACTIVATION_ELU = 35;
export const DML_OPERATOR_ACTIVATION_HARDMAX = 36;
export const DML_OPERATOR_ACTIVATION_HARD_SIGMOID = 37;
export const DML_OPERATOR_ACTIVATION_IDENTITY = 38;
export const DML_OPERATOR_ACTIVATION_LEAKY_RELU = 39;
export const DML_OPERATOR_ACTIVATION_LINEAR = 40;
export const DML_OPERATOR_ACTIVATION_LOG_SOFTMAX = 41;
export const DML_OPERATOR_ACTIVATION_PARAMETERIZED_RELU = 42;
export const DML_OPERATOR_ACTIVATION_PARAMETRIC_SOFTPLUS = 43;
export const DML_OPERATOR_ACTIVATION_RELU = 44;
export const DML_OPERATOR_ACTIVATION_SCALED_ELU = 45;
export const DML_OPERATOR_ACTIVATION_SCALED_TANH = 46;
export const DML_OPERATOR_ACTIVATION_SIGMOID = 47;
export const DML_OPERATOR_ACTIVATION_SOFTMAX = 48;
export const DML_OPERATOR_ACTIVATION_SOFTPLUS = 49;
export const DML_OPERATOR_ACTIVATION_SOFTSIGN = 50;
export const DML_OPERATOR_ACTIVATION_TANH = 51;
export const DML_OPERATOR_ACTIVATION_THRESHOLDED_RELU = 52;
export const DML_OPERATOR_CONVOLUTION = 53;
export const DML_OPERATOR_GEMM = 54;
export const DML_OPERATOR_REDUCE = 55;
export const DML_OPERATOR_AVERAGE_POOLING = 56;
export const DML_OPERATOR_LP_POOLING = 57;
export const DML_OPERATOR_MAX_POOLING = 58;
export const DML_OPERATOR_ROI_POOLING = 59;
export const DML_OPERATOR_SLICE = 60;
export const DML_OPERATOR_CAST = 61;
export const DML_OPERATOR_SPLIT = 62;
export const DML_OPERATOR_JOIN = 63;
export const DML_OPERATOR_PADDING = 64;
export const DML_OPERATOR_VALUE_SCALE_2D = 65;
export const DML_OPERATOR_UPSAMPLE_2D = 66;
export const DML_OPERATOR_GATHER = 67;
export const DML_OPERATOR_SPACE_TO_DEPTH = 68;
export const DML_OPERATOR_DEPTH_TO_SPACE = 69;
export const DML_OPERATOR_TILE = 70;
export const DML_OPERATOR_TOP_K = 71;
export const DML_OPERATOR_BATCH_NORMALIZATION = 72;
export const DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION = 73;
export const DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION = 74;
export const DML_OPERATOR_LP_NORMALIZATION = 75;
export const DML_OPERATOR_RNN = 76;
export const DML_OPERATOR_LSTM = 77;
export const DML_OPERATOR_GRU = 78;
export const DML_OPERATOR_ELEMENT_WISE_SIGN = 79;
export const DML_OPERATOR_ELEMENT_WISE_IS_NAN = 80;
export const DML_OPERATOR_ELEMENT_WISE_ERF = 81;
export const DML_OPERATOR_ELEMENT_WISE_SINH = 82;
export const DML_OPERATOR_ELEMENT_WISE_COSH = 83;
export const DML_OPERATOR_ELEMENT_WISE_TANH = 84;
export const DML_OPERATOR_ELEMENT_WISE_ASINH = 85;
export const DML_OPERATOR_ELEMENT_WISE_ACOSH = 86;
export const DML_OPERATOR_ELEMENT_WISE_ATANH = 87;
export const DML_OPERATOR_ELEMENT_WISE_IF = 88;
export const DML_OPERATOR_ELEMENT_WISE_ADD1 = 89;
export const DML_OPERATOR_ACTIVATION_SHRINK = 90;
export const DML_OPERATOR_MAX_POOLING1 = 91;
export const DML_OPERATOR_MAX_UNPOOLING = 92;
export const DML_OPERATOR_DIAGONAL_MATRIX = 93;
export const DML_OPERATOR_SCATTER_ELEMENTS = 94;
export const DML_OPERATOR_SCATTER = 94;
export const DML_OPERATOR_ONE_HOT = 95;
export const DML_OPERATOR_RESAMPLE = 96;
export const DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_LEFT = 97;
export const DML_OPERATOR_ELEMENT_WISE_BIT_SHIFT_RIGHT = 98;
export const DML_OPERATOR_ELEMENT_WISE_ROUND = 99;
export const DML_OPERATOR_ELEMENT_WISE_IS_INFINITY = 100;
export const DML_OPERATOR_ELEMENT_WISE_MODULUS_TRUNCATE = 101;
export const DML_OPERATOR_ELEMENT_WISE_MODULUS_FLOOR = 102;
export const DML_OPERATOR_FILL_VALUE_CONSTANT = 103;
export const DML_OPERATOR_FILL_VALUE_SEQUENCE = 104;
export const DML_OPERATOR_CUMULATIVE_SUMMATION = 105;
export const DML_OPERATOR_REVERSE_SUBSEQUENCES = 106;
export const DML_OPERATOR_GATHER_ELEMENTS = 107;
export const DML_OPERATOR_GATHER_ND = 108;
export const DML_OPERATOR_SCATTER_ND = 109;
export const DML_OPERATOR_MAX_POOLING2 = 110;
export const DML_OPERATOR_SLICE1 = 111;
export const DML_OPERATOR_TOP_K1 = 112;
export const DML_OPERATOR_DEPTH_TO_SPACE1 = 113;
export const DML_OPERATOR_SPACE_TO_DEPTH1 = 114;
export const DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION1 = 115;
export const DML_OPERATOR_RESAMPLE1 = 116;
export const DML_OPERATOR_MATRIX_MULTIPLY_INTEGER = 117;
export const DML_OPERATOR_QUANTIZED_LINEAR_MATRIX_MULTIPLY = 118;
export const DML_OPERATOR_CONVOLUTION_INTEGER = 119;
export const DML_OPERATOR_QUANTIZED_LINEAR_CONVOLUTION = 120;
export const DML_OPERATOR_ELEMENT_WISE_BIT_AND = 121;
export const DML_OPERATOR_ELEMENT_WISE_BIT_OR = 122;
export const DML_OPERATOR_ELEMENT_WISE_BIT_XOR = 123;
export const DML_OPERATOR_ELEMENT_WISE_BIT_NOT = 124;
export const DML_OPERATOR_ELEMENT_WISE_BIT_COUNT = 125;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL = 126;
export const DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL = 127;
export const DML_OPERATOR_ACTIVATION_CELU = 128;
export const DML_OPERATOR_ACTIVATION_RELU_GRAD = 129;
export const DML_OPERATOR_AVERAGE_POOLING_GRAD = 130;
export const DML_OPERATOR_MAX_POOLING_GRAD = 131;
export const DML_OPERATOR_RANDOM_GENERATOR = 132;
export const DML_OPERATOR_NONZERO_COORDINATES = 133;
export const DML_OPERATOR_RESAMPLE_GRAD = 134;
export const DML_OPERATOR_SLICE_GRAD = 135;
export const DML_OPERATOR_ADAM_OPTIMIZER = 136;
export const DML_OPERATOR_ARGMIN = 137;
export const DML_OPERATOR_ARGMAX = 138;
export const DML_OPERATOR_ROI_ALIGN = 139;
export const DML_OPERATOR_GATHER_ND1 = 140;
export const DML_OPERATOR_ELEMENT_WISE_ATAN_YX = 141;
export const DML_OPERATOR_ELEMENT_WISE_CLIP_GRAD = 142;
export const DML_OPERATOR_ELEMENT_WISE_DIFFERENCE_SQUARE = 143;
export const DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION_GRAD = 144;
export const DML_OPERATOR_CUMULATIVE_PRODUCT = 145;
export const DML_OPERATOR_BATCH_NORMALIZATION_GRAD = 146;
export const DML_OPERATOR_ELEMENT_WISE_QUANTIZED_LINEAR_ADD = 147;
export const DML_OPERATOR_DYNAMIC_QUANTIZE_LINEAR = 148;
export const DML_OPERATOR_ROI_ALIGN1 = 149;
export const DML_REDUCE_FUNCTION_ARGMAX = 0;
export const DML_REDUCE_FUNCTION_ARGMIN = 1;
export const DML_REDUCE_FUNCTION_AVERAGE = 2;
export const DML_REDUCE_FUNCTION_L1 = 3;
export const DML_REDUCE_FUNCTION_L2 = 4;
export const DML_REDUCE_FUNCTION_LOG_SUM = 5;
export const DML_REDUCE_FUNCTION_LOG_SUM_EXP = 6;
export const DML_REDUCE_FUNCTION_MAX = 7;
export const DML_REDUCE_FUNCTION_MIN = 8;
export const DML_REDUCE_FUNCTION_MULTIPLY = 9;
export const DML_REDUCE_FUNCTION_SUM = 10;
export const DML_REDUCE_FUNCTION_SUM_SQUARE = 11;
export const DML_MATRIX_TRANSFORM_NONE = 0;
export const DML_MATRIX_TRANSFORM_TRANSPOSE = 1;
export const DML_CONVOLUTION_MODE_CONVOLUTION = 0;
export const DML_CONVOLUTION_MODE_CROSS_CORRELATION = 1;
export const DML_CONVOLUTION_DIRECTION_FORWARD = 0;
export const DML_CONVOLUTION_DIRECTION_BACKWARD = 1;
export const DML_PADDING_MODE_CONSTANT = 0;
export const DML_PADDING_MODE_EDGE = 1;
export const DML_PADDING_MODE_REFLECTION = 2;
export const DML_PADDING_MODE_SYMMETRIC = 3;
export const DML_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0;
export const DML_INTERPOLATION_MODE_LINEAR = 1;
export const DML_RECURRENT_NETWORK_DIRECTION_FORWARD = 0;
export const DML_RECURRENT_NETWORK_DIRECTION_BACKWARD = 1;
export const DML_RECURRENT_NETWORK_DIRECTION_BIDIRECTIONAL = 2;
export const DML_ROUNDING_MODE_HALVES_TO_NEAREST_EVEN = 0;
export const DML_ROUNDING_MODE_TOWARD_ZERO = 1;
export const DML_ROUNDING_MODE_TOWARD_INFINITY = 2;
export const DML_IS_INFINITY_MODE_EITHER = 0;
export const DML_IS_INFINITY_MODE_POSITIVE = 1;
export const DML_IS_INFINITY_MODE_NEGATIVE = 2;
export const DML_AXIS_DIRECTION_INCREASING = 0;
export const DML_AXIS_DIRECTION_DECREASING = 1;
export const DML_DEPTH_SPACE_ORDER_DEPTH_COLUMN_ROW = 0;
export const DML_DEPTH_SPACE_ORDER_COLUMN_ROW_DEPTH = 1;
export const DML_RANDOM_GENERATOR_TYPE_PHILOX_4X32_10 = 0;
export const DML_FEATURE_LEVEL_1_0 = 4096;
export const DML_FEATURE_LEVEL_2_0 = 8192;
export const DML_FEATURE_LEVEL_2_1 = 8448;
export const DML_FEATURE_LEVEL_3_0 = 12288;
export const DML_FEATURE_LEVEL_3_1 = 12544;
export const DML_FEATURE_LEVEL_4_0 = 16384;
export const DML_FEATURE_TENSOR_DATA_TYPE_SUPPORT = 0;
export const DML_FEATURE_FEATURE_LEVELS = 1;
export const DML_EXECUTION_FLAG_NONE = 0;
export const DML_EXECUTION_FLAG_ALLOW_HALF_PRECISION_COMPUTATION = 1;
export const DML_EXECUTION_FLAG_DISABLE_META_COMMANDS = 2;
export const DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE = 4;
export const DML_CREATE_DEVICE_FLAG_NONE = 0;
export const DML_CREATE_DEVICE_FLAG_DEBUG = 1;
export const DML_BINDING_TYPE_NONE = 0;
export const DML_BINDING_TYPE_BUFFER = 1;
export const DML_BINDING_TYPE_BUFFER_ARRAY = 2;
export const DML_GRAPH_EDGE_TYPE_INVALID = 0;
export const DML_GRAPH_EDGE_TYPE_INPUT = 1;
export const DML_GRAPH_EDGE_TYPE_OUTPUT = 2;
export const DML_GRAPH_EDGE_TYPE_INTERMEDIATE = 3;
export const DML_GRAPH_NODE_TYPE_INVALID = 0;
export const DML_GRAPH_NODE_TYPE_OPERATOR = 1;

// Structs

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BUFFER_TENSOR_DESC (size: 48)
 */
export interface DML_BUFFER_TENSOR_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_TENSOR_DATA_TYPE */
  DataType: DML_TENSOR_DATA_TYPE;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_TENSOR_FLAGS */
  Flags: DML_TENSOR_FLAGS;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Sizes: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** u64 */
  TotalTensorSizeInBytes: number | bigint;
  /** u32 */
  GuaranteedBaseOffsetAlignment: number;
}

export const sizeofDML_BUFFER_TENSOR_DESC = 48;

export function allocDML_BUFFER_TENSOR_DESC(data?: Partial<DML_BUFFER_TENSOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BUFFER_TENSOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.DataType !== undefined) view.setInt32(0, Number(data.DataType), true);
  // 0x04: u32
  if (data?.Flags !== undefined) view.setUint32(4, Number(data.Flags), true);
  // 0x08: u32
  if (data?.DimensionCount !== undefined) view.setUint32(8, Number(data.DimensionCount), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Sizes !== undefined) view.setBigUint64(16, data.Sizes === null ? 0n : util.toBigInt(util.toPointer(data.Sizes)), true);
  // 0x18: pointer
  if (data?.Strides !== undefined) view.setBigUint64(24, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x20: u64
  if (data?.TotalTensorSizeInBytes !== undefined) view.setBigUint64(32, util.toBigInt(data.TotalTensorSizeInBytes), true);
  // 0x28: u32
  if (data?.GuaranteedBaseOffsetAlignment !== undefined) view.setUint32(40, Number(data.GuaranteedBaseOffsetAlignment), true);
  // 0x2c: pad4
  return buf;
}

export class DML_BUFFER_TENSOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get DataType(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: u32
  get Flags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get DimensionCount(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Sizes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: u64
  get TotalTensorSizeInBytes(): number | bigint {
    return this.view.getBigUint64(32, true);
  }

  // 0x28: u32
  get GuaranteedBaseOffsetAlignment(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x00: i32
  set DataType(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: u32
  set Flags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set DimensionCount(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Sizes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: u64
  set TotalTensorSizeInBytes(value: number | bigint) {
    this.view.setBigUint64(32, util.toBigInt(value), true);
  }

  // 0x28: u32
  set GuaranteedBaseOffsetAlignment(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_TENSOR_DESC (size: 16)
 */
export interface DML_TENSOR_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_TENSOR_TYPE */
  Type: DML_TENSOR_TYPE;
  /** ptr */
  Desc: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_TENSOR_DESC = 16;

export function allocDML_TENSOR_DESC(data?: Partial<DML_TENSOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_TENSOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.Type !== undefined) view.setInt32(0, Number(data.Type), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Desc !== undefined) view.setBigUint64(8, data.Desc === null ? 0n : util.toBigInt(util.toPointer(data.Desc)), true);
  return buf;
}

export class DML_TENSOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get Type(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Desc(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: i32
  set Type(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Desc(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SCALE_BIAS (size: 8)
 */
export interface DML_SCALE_BIAS {
  /** f32 */
  Scale: number;
  /** f32 */
  Bias: number;
}

export const sizeofDML_SCALE_BIAS = 8;

export function allocDML_SCALE_BIAS(data?: Partial<DML_SCALE_BIAS>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SCALE_BIAS);
  const view = new DataView(buf.buffer);
  // 0x00: f32
  if (data?.Scale !== undefined) view.setFloat32(0, Number(data.Scale), true);
  // 0x04: f32
  if (data?.Bias !== undefined) view.setFloat32(4, Number(data.Bias), true);
  return buf;
}

export class DML_SCALE_BIASView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: f32
  get Scale(): number {
    return this.view.getFloat32(0, true);
  }

  // 0x04: f32
  get Bias(): number {
    return this.view.getFloat32(4, true);
  }

  // 0x00: f32
  set Scale(value: number) {
    this.view.setFloat32(0, value, true);
  }

  // 0x04: f32
  set Bias(value: number) {
    this.view.setFloat32(4, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SIZE_2D (size: 8)
 */
export interface DML_SIZE_2D {
  /** u32 */
  Width: number;
  /** u32 */
  Height: number;
}

export const sizeofDML_SIZE_2D = 8;

export function allocDML_SIZE_2D(data?: Partial<DML_SIZE_2D>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SIZE_2D);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Width !== undefined) view.setUint32(0, Number(data.Width), true);
  // 0x04: u32
  if (data?.Height !== undefined) view.setUint32(4, Number(data.Height), true);
  return buf;
}

export class DML_SIZE_2DView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Width(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Height(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set Width(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Height(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SCALAR_UNION (size: 56)
 */
export interface DML_SCALAR_UNION {
  /** array */
  Bytes: Deno.PointerValue | null;
  /** i8 */
  Int8: number;
  /** u8 */
  UInt8: number;
  /** i16 */
  Int16: number;
  /** u16 */
  UInt16: number;
  /** i32 */
  Int32: number;
  /** u32 */
  UInt32: number;
  /** i64 */
  Int64: number | bigint;
  /** u64 */
  UInt64: number | bigint;
  /** f32 */
  Float32: number;
  /** f64 */
  Float64: number;
}

export const sizeofDML_SCALAR_UNION = 56;

export function allocDML_SCALAR_UNION(data?: Partial<DML_SCALAR_UNION>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SCALAR_UNION);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Bytes !== undefined) view.setBigUint64(0, data.Bytes === null ? 0n : util.toBigInt(util.toPointer(data.Bytes)), true);
  // 0x08: i8
  if (data?.Int8 !== undefined) view.setInt8(8, Number(data.Int8));
  // 0x09: u8
  if (data?.UInt8 !== undefined) view.setUint8(9, Number(data.UInt8));
  // 0x0a: i16
  if (data?.Int16 !== undefined) view.setInt16(10, Number(data.Int16), true);
  // 0x0c: u16
  if (data?.UInt16 !== undefined) view.setUint16(12, Number(data.UInt16), true);
  // 0x0e: i32
  if (data?.Int32 !== undefined) view.setInt32(14, Number(data.Int32), true);
  // 0x12: u32
  if (data?.UInt32 !== undefined) view.setUint32(18, Number(data.UInt32), true);
  // 0x16: pad2
  // 0x18: i64
  if (data?.Int64 !== undefined) view.setBigInt64(24, util.toBigInt(data.Int64), true);
  // 0x20: u64
  if (data?.UInt64 !== undefined) view.setBigUint64(32, util.toBigInt(data.UInt64), true);
  // 0x28: f32
  if (data?.Float32 !== undefined) view.setFloat32(40, Number(data.Float32), true);
  // 0x2c: pad4
  // 0x30: f64
  if (data?.Float64 !== undefined) view.setFloat64(48, Number(data.Float64), true);
  return buf;
}

export class DML_SCALAR_UNIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Bytes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: i8
  get Int8(): number {
    return this.view.getInt8(8);
  }

  // 0x09: u8
  get UInt8(): number {
    return this.view.getUint8(9);
  }

  // 0x0a: i16
  get Int16(): number {
    return this.view.getInt16(10, true);
  }

  // 0x0c: u16
  get UInt16(): number {
    return this.view.getUint16(12, true);
  }

  // 0x0e: i32
  get Int32(): number {
    return this.view.getInt32(14, true);
  }

  // 0x12: u32
  get UInt32(): number {
    return this.view.getUint32(18, true);
  }

  // 0x16: pad2

  // 0x18: i64
  get Int64(): number | bigint {
    return this.view.getBigInt64(24, true);
  }

  // 0x20: u64
  get UInt64(): number | bigint {
    return this.view.getBigUint64(32, true);
  }

  // 0x28: f32
  get Float32(): number {
    return this.view.getFloat32(40, true);
  }

  // 0x2c: pad4

  // 0x30: f64
  get Float64(): number {
    return this.view.getFloat64(48, true);
  }

  // 0x00: pointer
  set Bytes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: i8
  set Int8(value: number) {
    this.view.setInt8(8, value);
  }

  // 0x09: u8
  set UInt8(value: number) {
    this.view.setUint8(9, value);
  }

  // 0x0a: i16
  set Int16(value: number) {
    this.view.setInt16(10, value, true);
  }

  // 0x0c: u16
  set UInt16(value: number) {
    this.view.setUint16(12, value, true);
  }

  // 0x0e: i32
  set Int32(value: number) {
    this.view.setInt32(14, value, true);
  }

  // 0x12: u32
  set UInt32(value: number) {
    this.view.setUint32(18, value, true);
  }

  // 0x16: pad2

  // 0x18: i64
  set Int64(value: number | bigint) {
    this.view.setBigInt64(24, util.toBigInt(value), true);
  }

  // 0x20: u64
  set UInt64(value: number | bigint) {
    this.view.setBigUint64(32, util.toBigInt(value), true);
  }

  // 0x28: f32
  set Float32(value: number) {
    this.view.setFloat32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: f64
  set Float64(value: number) {
    this.view.setFloat64(48, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_OPERATOR_DESC (size: 16)
 */
export interface DML_OPERATOR_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_OPERATOR_TYPE */
  Type: DML_OPERATOR_TYPE;
  /** ptr */
  Desc: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_OPERATOR_DESC = 16;

export function allocDML_OPERATOR_DESC(data?: Partial<DML_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.Type !== undefined) view.setInt32(0, Number(data.Type), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Desc !== undefined) view.setBigUint64(8, data.Desc === null ? 0n : util.toBigInt(util.toPointer(data.Desc)), true);
  return buf;
}

export class DML_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get Type(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Desc(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: i32
  set Type(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Desc(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ABS_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ABS_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ABS_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ABS_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ABS_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ABS_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ABS_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ACOS_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ACOS_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ACOS_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ACOS_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ACOS_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ACOS_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ACOS_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ADD_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ADD_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ADD_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ADD_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ADD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ADD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ADD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ADD1_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_ADD1_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  FusedActivation: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ADD1_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_ADD1_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ADD1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ADD1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: pointer
  if (data?.FusedActivation !== undefined) view.setBigUint64(24, data.FusedActivation === null ? 0n : util.toBigInt(util.toPointer(data.FusedActivation)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ADD1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get FusedActivation(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set FusedActivation(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ASIN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ASIN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ASIN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ASIN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ASIN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ASIN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ASIN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ATAN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ATAN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ATAN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ATAN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ATAN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ATAN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ATAN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_CEIL_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_CEIL_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_CEIL_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_CEIL_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_CEIL_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_CEIL_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_CEIL_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_CLIP_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_CLIP_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Min: number;
  /** f32 */
  Max: number;
}

export const sizeofDML_ELEMENT_WISE_CLIP_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_CLIP_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_CLIP_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_CLIP_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  // 0x18: f32
  if (data?.Min !== undefined) view.setFloat32(24, Number(data.Min), true);
  // 0x1c: f32
  if (data?.Max !== undefined) view.setFloat32(28, Number(data.Max), true);
  return buf;
}

export class DML_ELEMENT_WISE_CLIP_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: f32
  get Min(): number {
    return this.view.getFloat32(24, true);
  }

  // 0x1c: f32
  get Max(): number {
    return this.view.getFloat32(28, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: f32
  set Min(value: number) {
    this.view.setFloat32(24, value, true);
  }

  // 0x1c: f32
  set Max(value: number) {
    this.view.setFloat32(28, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_COS_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_COS_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_COS_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_COS_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_COS_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_COS_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_COS_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_EXP_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_EXP_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_EXP_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_EXP_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_EXP_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_EXP_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_EXP_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_FLOOR_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_FLOOR_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_FLOOR_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_FLOOR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_FLOOR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_FLOOR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_FLOOR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOG_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOG_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOG_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOG_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOG_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOG_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOG_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC (size: 16)
 */
export interface DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC = 16;

export function allocDML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_MAX_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_MAX_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_MAX_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_MAX_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_MAX_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_MAX_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_MAX_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_MEAN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_MEAN_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_MEAN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_MEAN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_MEAN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_MEAN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_MEAN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_MIN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_MIN_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_MIN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_MIN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_MIN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_MIN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_MIN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_POW_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_POW_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ExponentTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_POW_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_POW_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_POW_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_POW_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ExponentTensor !== undefined) view.setBigUint64(8, data.ExponentTensor === null ? 0n : util.toBigInt(util.toPointer(data.ExponentTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(24, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_POW_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ExponentTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ExponentTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Exponent: number;
}

export const sizeofDML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  // 0x18: f32
  if (data?.Exponent !== undefined) view.setFloat32(24, Number(data.Exponent), true);
  // 0x1c: pad4
  return buf;
}

export class DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: f32
  get Exponent(): number {
    return this.view.getFloat32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: f32
  set Exponent(value: number) {
    this.view.setFloat32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_RECIP_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_RECIP_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_RECIP_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_RECIP_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_RECIP_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_RECIP_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_RECIP_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_SIN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_SIN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_SIN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_SIN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_SIN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_SIN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_SIN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_SQRT_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_SQRT_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_SQRT_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_SQRT_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_SQRT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_SQRT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_SQRT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_TAN_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_TAN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_TAN_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_TAN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_TAN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_TAN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_TAN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Min: number;
}

export const sizeofDML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  // 0x18: f32
  if (data?.Min !== undefined) view.setFloat32(24, Number(data.Min), true);
  // 0x1c: pad4
  return buf;
}

export class DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: f32
  get Min(): number {
    return this.view.getFloat32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: f32
  set Min(value: number) {
    this.view.setFloat32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ScaleTensor !== undefined) view.setBigUint64(8, data.ScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.ScaleTensor)), true);
  // 0x10: pointer
  if (data?.ZeroPointTensor !== undefined) view.setBigUint64(16, data.ZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.ZeroPointTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ScaleTensor !== undefined) view.setBigUint64(8, data.ScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.ScaleTensor)), true);
  // 0x10: pointer
  if (data?.ZeroPointTensor !== undefined) view.setBigUint64(16, data.ZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.ZeroPointTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_ELU_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_ELU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
}

export const sizeofDML_ACTIVATION_ELU_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_ELU_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_ELU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_ELU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: pad4
  return buf;
}

export class DML_ACTIVATION_ELU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_HARDMAX_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_HARDMAX_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_HARDMAX_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_HARDMAX_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_HARDMAX_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_HARDMAX_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_HARDMAX_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
  /** f32 */
  Beta: number;
}

export const sizeofDML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: f32
  if (data?.Beta !== undefined) view.setFloat32(20, Number(data.Beta), true);
  return buf;
}

export class DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: f32
  get Beta(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: f32
  set Beta(value: number) {
    this.view.setFloat32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_IDENTITY_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_IDENTITY_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_IDENTITY_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_IDENTITY_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_IDENTITY_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_IDENTITY_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_IDENTITY_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
}

export const sizeofDML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: pad4
  return buf;
}

export class DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_LINEAR_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_LINEAR_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
  /** f32 */
  Beta: number;
}

export const sizeofDML_ACTIVATION_LINEAR_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_LINEAR_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_LINEAR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_LINEAR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: f32
  if (data?.Beta !== undefined) view.setFloat32(20, Number(data.Beta), true);
  return buf;
}

export class DML_ACTIVATION_LINEAR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: f32
  get Beta(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: f32
  set Beta(value: number) {
    this.view.setFloat32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  SlopeTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.SlopeTensor !== undefined) view.setBigUint64(8, data.SlopeTensor === null ? 0n : util.toBigInt(util.toPointer(data.SlopeTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get SlopeTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set SlopeTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
  /** f32 */
  Beta: number;
}

export const sizeofDML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: f32
  if (data?.Beta !== undefined) view.setFloat32(20, Number(data.Beta), true);
  return buf;
}

export class DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: f32
  get Beta(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: f32
  set Beta(value: number) {
    this.view.setFloat32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_RELU_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_RELU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_RELU_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_RELU_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_RELU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_RELU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_RELU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_SCALED_ELU_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_SCALED_ELU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
  /** f32 */
  Gamma: number;
}

export const sizeofDML_ACTIVATION_SCALED_ELU_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_SCALED_ELU_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_SCALED_ELU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_SCALED_ELU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: f32
  if (data?.Gamma !== undefined) view.setFloat32(20, Number(data.Gamma), true);
  return buf;
}

export class DML_ACTIVATION_SCALED_ELU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: f32
  get Gamma(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: f32
  set Gamma(value: number) {
    this.view.setFloat32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_SCALED_TANH_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_SCALED_TANH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
  /** f32 */
  Beta: number;
}

export const sizeofDML_ACTIVATION_SCALED_TANH_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_SCALED_TANH_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_SCALED_TANH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_SCALED_TANH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: f32
  if (data?.Beta !== undefined) view.setFloat32(20, Number(data.Beta), true);
  return buf;
}

export class DML_ACTIVATION_SCALED_TANH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: f32
  get Beta(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: f32
  set Beta(value: number) {
    this.view.setFloat32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_SIGMOID_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_SIGMOID_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_SIGMOID_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_SIGMOID_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_SIGMOID_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_SIGMOID_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_SIGMOID_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_SOFTMAX_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_SOFTMAX_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_SOFTMAX_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_SOFTMAX_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_SOFTMAX_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_SOFTMAX_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_SOFTMAX_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_SOFTPLUS_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_SOFTPLUS_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Steepness: number;
}

export const sizeofDML_ACTIVATION_SOFTPLUS_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_SOFTPLUS_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_SOFTPLUS_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_SOFTPLUS_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Steepness !== undefined) view.setFloat32(16, Number(data.Steepness), true);
  // 0x14: pad4
  return buf;
}

export class DML_ACTIVATION_SOFTPLUS_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Steepness(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Steepness(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_SOFTSIGN_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_SOFTSIGN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_SOFTSIGN_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_SOFTSIGN_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_SOFTSIGN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_SOFTSIGN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_SOFTSIGN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_TANH_OPERATOR_DESC (size: 16)
 */
export interface DML_ACTIVATION_TANH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_TANH_OPERATOR_DESC = 16;

export function allocDML_ACTIVATION_TANH_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_TANH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_TANH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ACTIVATION_TANH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
}

export const sizeofDML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: pad4
  return buf;
}

export class DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_CONVOLUTION_OPERATOR_DESC (size: 104)
 */
export interface DML_CONVOLUTION_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  FilterTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_CONVOLUTION_MODE */
  Mode: DML_CONVOLUTION_MODE;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_CONVOLUTION_DIRECTION */
  Direction: DML_CONVOLUTION_DIRECTION;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Dilations: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputPadding: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  GroupCount: number;
  /** ptr */
  FusedActivation: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_CONVOLUTION_OPERATOR_DESC = 104;

export function allocDML_CONVOLUTION_OPERATOR_DESC(data?: Partial<DML_CONVOLUTION_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_CONVOLUTION_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.FilterTensor !== undefined) view.setBigUint64(8, data.FilterTensor === null ? 0n : util.toBigInt(util.toPointer(data.FilterTensor)), true);
  // 0x10: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(16, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: i32
  if (data?.Mode !== undefined) view.setInt32(32, Number(data.Mode), true);
  // 0x24: i32
  if (data?.Direction !== undefined) view.setInt32(36, Number(data.Direction), true);
  // 0x28: u32
  if (data?.DimensionCount !== undefined) view.setUint32(40, Number(data.DimensionCount), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.Strides !== undefined) view.setBigUint64(48, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x38: pointer
  if (data?.Dilations !== undefined) view.setBigUint64(56, data.Dilations === null ? 0n : util.toBigInt(util.toPointer(data.Dilations)), true);
  // 0x40: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(64, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x48: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(72, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x50: pointer
  if (data?.OutputPadding !== undefined) view.setBigUint64(80, data.OutputPadding === null ? 0n : util.toBigInt(util.toPointer(data.OutputPadding)), true);
  // 0x58: u32
  if (data?.GroupCount !== undefined) view.setUint32(88, Number(data.GroupCount), true);
  // 0x5c: pad4
  // 0x60: pointer
  if (data?.FusedActivation !== undefined) view.setBigUint64(96, data.FusedActivation === null ? 0n : util.toBigInt(util.toPointer(data.FusedActivation)), true);
  return buf;
}

export class DML_CONVOLUTION_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get FilterTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: i32
  get Mode(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: i32
  get Direction(): number {
    return this.view.getInt32(36, true);
  }

  // 0x28: u32
  get DimensionCount(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get Dilations(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x48: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(72, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x50: pointer
  get OutputPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(80, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x58: u32
  get GroupCount(): number {
    return this.view.getUint32(88, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  get FusedActivation(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(96, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set FilterTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: i32
  set Mode(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: i32
  set Direction(value: number) {
    this.view.setInt32(36, value, true);
  }

  // 0x28: u32
  set DimensionCount(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set Dilations(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x48: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(72, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x50: pointer
  set OutputPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(80, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x58: u32
  set GroupCount(value: number) {
    this.view.setUint32(88, value, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  set FusedActivation(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(96, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GEMM_OPERATOR_DESC (size: 56)
 */
export interface DML_GEMM_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  CTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_MATRIX_TRANSFORM */
  TransA: DML_MATRIX_TRANSFORM;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_MATRIX_TRANSFORM */
  TransB: DML_MATRIX_TRANSFORM;
  /** f32 */
  Alpha: number;
  /** f32 */
  Beta: number;
  /** ptr */
  FusedActivation: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_GEMM_OPERATOR_DESC = 56;

export function allocDML_GEMM_OPERATOR_DESC(data?: Partial<DML_GEMM_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GEMM_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.CTensor !== undefined) view.setBigUint64(16, data.CTensor === null ? 0n : util.toBigInt(util.toPointer(data.CTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: i32
  if (data?.TransA !== undefined) view.setInt32(32, Number(data.TransA), true);
  // 0x24: i32
  if (data?.TransB !== undefined) view.setInt32(36, Number(data.TransB), true);
  // 0x28: f32
  if (data?.Alpha !== undefined) view.setFloat32(40, Number(data.Alpha), true);
  // 0x2c: f32
  if (data?.Beta !== undefined) view.setFloat32(44, Number(data.Beta), true);
  // 0x30: pointer
  if (data?.FusedActivation !== undefined) view.setBigUint64(48, data.FusedActivation === null ? 0n : util.toBigInt(util.toPointer(data.FusedActivation)), true);
  return buf;
}

export class DML_GEMM_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get CTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: i32
  get TransA(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: i32
  get TransB(): number {
    return this.view.getInt32(36, true);
  }

  // 0x28: f32
  get Alpha(): number {
    return this.view.getFloat32(40, true);
  }

  // 0x2c: f32
  get Beta(): number {
    return this.view.getFloat32(44, true);
  }

  // 0x30: pointer
  get FusedActivation(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set CTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: i32
  set TransA(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: i32
  set TransB(value: number) {
    this.view.setInt32(36, value, true);
  }

  // 0x28: f32
  set Alpha(value: number) {
    this.view.setFloat32(40, value, true);
  }

  // 0x2c: f32
  set Beta(value: number) {
    this.view.setFloat32(44, value, true);
  }

  // 0x30: pointer
  set FusedActivation(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_REDUCE_OPERATOR_DESC (size: 40)
 */
export interface DML_REDUCE_OPERATOR_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_REDUCE_FUNCTION */
  Function: DML_REDUCE_FUNCTION;
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  AxisCount: number;
  /** ptr */
  Axes: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_REDUCE_OPERATOR_DESC = 40;

export function allocDML_REDUCE_OPERATOR_DESC(data?: Partial<DML_REDUCE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_REDUCE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.Function !== undefined) view.setInt32(0, Number(data.Function), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(8, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.AxisCount !== undefined) view.setUint32(24, Number(data.AxisCount), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Axes !== undefined) view.setBigUint64(32, data.Axes === null ? 0n : util.toBigInt(util.toPointer(data.Axes)), true);
  return buf;
}

export class DML_REDUCE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get Function(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get AxisCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Axes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: i32
  set Function(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set AxisCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Axes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }
}

export type BOOL = number;

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_AVERAGE_POOLING_OPERATOR_DESC (size: 64)
 */
export interface DML_AVERAGE_POOLING_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WindowSize: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Foundation.BOOL */
  IncludePadding: boolean;
}

export const sizeofDML_AVERAGE_POOLING_OPERATOR_DESC = 64;

export function allocDML_AVERAGE_POOLING_OPERATOR_DESC(data?: Partial<DML_AVERAGE_POOLING_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_AVERAGE_POOLING_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.DimensionCount !== undefined) view.setUint32(16, Number(data.DimensionCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Strides !== undefined) view.setBigUint64(24, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x20: pointer
  if (data?.WindowSize !== undefined) view.setBigUint64(32, data.WindowSize === null ? 0n : util.toBigInt(util.toPointer(data.WindowSize)), true);
  // 0x28: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(40, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x30: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(48, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x38: i32
  if (data?.IncludePadding !== undefined) view.setInt32(56, Number(data.IncludePadding), true);
  // 0x3c: pad4
  return buf;
}

export class DML_AVERAGE_POOLING_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get DimensionCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get WindowSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: i32
  get IncludePadding(): number {
    return this.view.getInt32(56, true);
  }

  // 0x3c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set DimensionCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set WindowSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: i32
  set IncludePadding(value: number) {
    this.view.setInt32(56, value, true);
  }

  // 0x3c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_LP_POOLING_OPERATOR_DESC (size: 64)
 */
export interface DML_LP_POOLING_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WindowSize: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  P: number;
}

export const sizeofDML_LP_POOLING_OPERATOR_DESC = 64;

export function allocDML_LP_POOLING_OPERATOR_DESC(data?: Partial<DML_LP_POOLING_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_LP_POOLING_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.DimensionCount !== undefined) view.setUint32(16, Number(data.DimensionCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Strides !== undefined) view.setBigUint64(24, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x20: pointer
  if (data?.WindowSize !== undefined) view.setBigUint64(32, data.WindowSize === null ? 0n : util.toBigInt(util.toPointer(data.WindowSize)), true);
  // 0x28: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(40, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x30: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(48, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x38: u32
  if (data?.P !== undefined) view.setUint32(56, Number(data.P), true);
  // 0x3c: pad4
  return buf;
}

export class DML_LP_POOLING_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get DimensionCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get WindowSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: u32
  get P(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set DimensionCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set WindowSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: u32
  set P(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MAX_POOLING_OPERATOR_DESC (size: 56)
 */
export interface DML_MAX_POOLING_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WindowSize: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MAX_POOLING_OPERATOR_DESC = 56;

export function allocDML_MAX_POOLING_OPERATOR_DESC(data?: Partial<DML_MAX_POOLING_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MAX_POOLING_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.DimensionCount !== undefined) view.setUint32(16, Number(data.DimensionCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Strides !== undefined) view.setBigUint64(24, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x20: pointer
  if (data?.WindowSize !== undefined) view.setBigUint64(32, data.WindowSize === null ? 0n : util.toBigInt(util.toPointer(data.WindowSize)), true);
  // 0x28: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(40, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x30: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(48, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  return buf;
}

export class DML_MAX_POOLING_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get DimensionCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get WindowSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set DimensionCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set WindowSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ROI_POOLING_OPERATOR_DESC (size: 40)
 */
export interface DML_ROI_POOLING_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ROITensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  SpatialScale: number;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_SIZE_2D */
  PooledSize: Uint8Array | Deno.PointerValue | null;
}

export const sizeofDML_ROI_POOLING_OPERATOR_DESC = 40;

export function allocDML_ROI_POOLING_OPERATOR_DESC(data?: Partial<DML_ROI_POOLING_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ROI_POOLING_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ROITensor !== undefined) view.setBigUint64(8, data.ROITensor === null ? 0n : util.toBigInt(util.toPointer(data.ROITensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: f32
  if (data?.SpatialScale !== undefined) view.setFloat32(24, Number(data.SpatialScale), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.PooledSize !== undefined) view.setBigUint64(32, data.PooledSize === null ? 0n : util.toBigInt(util.toPointer(data.PooledSize)), true);
  return buf;
}

export class DML_ROI_POOLING_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ROITensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: f32
  get SpatialScale(): number {
    return this.view.getFloat32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get PooledSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ROITensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: f32
  set SpatialScale(value: number) {
    this.view.setFloat32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set PooledSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SLICE_OPERATOR_DESC (size: 48)
 */
export interface DML_SLICE_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Offsets: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Sizes: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_SLICE_OPERATOR_DESC = 48;

export function allocDML_SLICE_OPERATOR_DESC(data?: Partial<DML_SLICE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SLICE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.DimensionCount !== undefined) view.setUint32(16, Number(data.DimensionCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Offsets !== undefined) view.setBigUint64(24, data.Offsets === null ? 0n : util.toBigInt(util.toPointer(data.Offsets)), true);
  // 0x20: pointer
  if (data?.Sizes !== undefined) view.setBigUint64(32, data.Sizes === null ? 0n : util.toBigInt(util.toPointer(data.Sizes)), true);
  // 0x28: pointer
  if (data?.Strides !== undefined) view.setBigUint64(40, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  return buf;
}

export class DML_SLICE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get DimensionCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Offsets(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get Sizes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set DimensionCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Offsets(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set Sizes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_CAST_OPERATOR_DESC (size: 16)
 */
export interface DML_CAST_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_CAST_OPERATOR_DESC = 16;

export function allocDML_CAST_OPERATOR_DESC(data?: Partial<DML_CAST_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_CAST_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_CAST_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SPLIT_OPERATOR_DESC (size: 32)
 */
export interface DML_SPLIT_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  OutputCount: number;
  /** ptr */
  OutputTensors: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
}

export const sizeofDML_SPLIT_OPERATOR_DESC = 32;

export function allocDML_SPLIT_OPERATOR_DESC(data?: Partial<DML_SPLIT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SPLIT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: u32
  if (data?.OutputCount !== undefined) view.setUint32(8, Number(data.OutputCount), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.OutputTensors !== undefined) view.setBigUint64(16, data.OutputTensors === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensors)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: pad4
  return buf;
}

export class DML_SPLIT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: u32
  get OutputCount(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get OutputTensors(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: u32
  set OutputCount(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set OutputTensors(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_JOIN_OPERATOR_DESC (size: 32)
 */
export interface DML_JOIN_OPERATOR_DESC {
  /** u32 */
  InputCount: number;
  /** ptr */
  InputTensors: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
}

export const sizeofDML_JOIN_OPERATOR_DESC = 32;

export function allocDML_JOIN_OPERATOR_DESC(data?: Partial<DML_JOIN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_JOIN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.InputCount !== undefined) view.setUint32(0, Number(data.InputCount), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.InputTensors !== undefined) view.setBigUint64(8, data.InputTensors === null ? 0n : util.toBigInt(util.toPointer(data.InputTensors)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: pad4
  return buf;
}

export class DML_JOIN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get InputCount(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get InputTensors(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: u32
  set InputCount(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set InputTensors(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_PADDING_OPERATOR_DESC (size: 48)
 */
export interface DML_PADDING_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_PADDING_MODE */
  PaddingMode: DML_PADDING_MODE;
  /** f32 */
  PaddingValue: number;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_PADDING_OPERATOR_DESC = 48;

export function allocDML_PADDING_OPERATOR_DESC(data?: Partial<DML_PADDING_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_PADDING_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: i32
  if (data?.PaddingMode !== undefined) view.setInt32(16, Number(data.PaddingMode), true);
  // 0x14: f32
  if (data?.PaddingValue !== undefined) view.setFloat32(20, Number(data.PaddingValue), true);
  // 0x18: u32
  if (data?.DimensionCount !== undefined) view.setUint32(24, Number(data.DimensionCount), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(32, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x28: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(40, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  return buf;
}

export class DML_PADDING_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: i32
  get PaddingMode(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: f32
  get PaddingValue(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x18: u32
  get DimensionCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: i32
  set PaddingMode(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: f32
  set PaddingValue(value: number) {
    this.view.setFloat32(20, value, true);
  }

  // 0x18: u32
  set DimensionCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_VALUE_SCALE_2D_OPERATOR_DESC (size: 32)
 */
export interface DML_VALUE_SCALE_2D_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Scale: number;
  /** u32 */
  ChannelCount: number;
  /** ptr */
  Bias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_VALUE_SCALE_2D_OPERATOR_DESC = 32;

export function allocDML_VALUE_SCALE_2D_OPERATOR_DESC(data?: Partial<DML_VALUE_SCALE_2D_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_VALUE_SCALE_2D_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Scale !== undefined) view.setFloat32(16, Number(data.Scale), true);
  // 0x14: u32
  if (data?.ChannelCount !== undefined) view.setUint32(20, Number(data.ChannelCount), true);
  // 0x18: pointer
  if (data?.Bias !== undefined) view.setBigUint64(24, data.Bias === null ? 0n : util.toBigInt(util.toPointer(data.Bias)), true);
  return buf;
}

export class DML_VALUE_SCALE_2D_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Scale(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: u32
  get ChannelCount(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get Bias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Scale(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: u32
  set ChannelCount(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set Bias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_UPSAMPLE_2D_OPERATOR_DESC (size: 32)
 */
export interface DML_UPSAMPLE_2D_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_SIZE_2D */
  ScaleSize: Uint8Array | Deno.PointerValue | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_INTERPOLATION_MODE */
  InterpolationMode: DML_INTERPOLATION_MODE;
}

export const sizeofDML_UPSAMPLE_2D_OPERATOR_DESC = 32;

export function allocDML_UPSAMPLE_2D_OPERATOR_DESC(data?: Partial<DML_UPSAMPLE_2D_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_UPSAMPLE_2D_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleSize !== undefined) view.setBigUint64(16, data.ScaleSize === null ? 0n : util.toBigInt(util.toPointer(data.ScaleSize)), true);
  // 0x18: i32
  if (data?.InterpolationMode !== undefined) view.setInt32(24, Number(data.InterpolationMode), true);
  // 0x1c: pad4
  return buf;
}

export class DML_UPSAMPLE_2D_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: i32
  get InterpolationMode(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: i32
  set InterpolationMode(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GATHER_OPERATOR_DESC (size: 32)
 */
export interface DML_GATHER_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
  /** u32 */
  IndexDimensions: number;
}

export const sizeofDML_GATHER_OPERATOR_DESC = 32;

export function allocDML_GATHER_OPERATOR_DESC(data?: Partial<DML_GATHER_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GATHER_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(8, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: u32
  if (data?.IndexDimensions !== undefined) view.setUint32(28, Number(data.IndexDimensions), true);
  return buf;
}

export class DML_GATHER_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get IndexDimensions(): number {
    return this.view.getUint32(28, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set IndexDimensions(value: number) {
    this.view.setUint32(28, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SPACE_TO_DEPTH_OPERATOR_DESC (size: 24)
 */
export interface DML_SPACE_TO_DEPTH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  BlockSize: number;
}

export const sizeofDML_SPACE_TO_DEPTH_OPERATOR_DESC = 24;

export function allocDML_SPACE_TO_DEPTH_OPERATOR_DESC(data?: Partial<DML_SPACE_TO_DEPTH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SPACE_TO_DEPTH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.BlockSize !== undefined) view.setUint32(16, Number(data.BlockSize), true);
  // 0x14: pad4
  return buf;
}

export class DML_SPACE_TO_DEPTH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get BlockSize(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set BlockSize(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_DEPTH_TO_SPACE_OPERATOR_DESC (size: 24)
 */
export interface DML_DEPTH_TO_SPACE_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  BlockSize: number;
}

export const sizeofDML_DEPTH_TO_SPACE_OPERATOR_DESC = 24;

export function allocDML_DEPTH_TO_SPACE_OPERATOR_DESC(data?: Partial<DML_DEPTH_TO_SPACE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_DEPTH_TO_SPACE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.BlockSize !== undefined) view.setUint32(16, Number(data.BlockSize), true);
  // 0x14: pad4
  return buf;
}

export class DML_DEPTH_TO_SPACE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get BlockSize(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set BlockSize(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_TILE_OPERATOR_DESC (size: 32)
 */
export interface DML_TILE_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  RepeatsCount: number;
  /** ptr */
  Repeats: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_TILE_OPERATOR_DESC = 32;

export function allocDML_TILE_OPERATOR_DESC(data?: Partial<DML_TILE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_TILE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.RepeatsCount !== undefined) view.setUint32(16, Number(data.RepeatsCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Repeats !== undefined) view.setBigUint64(24, data.Repeats === null ? 0n : util.toBigInt(util.toPointer(data.Repeats)), true);
  return buf;
}

export class DML_TILE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get RepeatsCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Repeats(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set RepeatsCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Repeats(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_TOP_K_OPERATOR_DESC (size: 32)
 */
export interface DML_TOP_K_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputValueTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputIndexTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
  /** u32 */
  K: number;
}

export const sizeofDML_TOP_K_OPERATOR_DESC = 32;

export function allocDML_TOP_K_OPERATOR_DESC(data?: Partial<DML_TOP_K_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_TOP_K_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputValueTensor !== undefined) view.setBigUint64(8, data.OutputValueTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputValueTensor)), true);
  // 0x10: pointer
  if (data?.OutputIndexTensor !== undefined) view.setBigUint64(16, data.OutputIndexTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputIndexTensor)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: u32
  if (data?.K !== undefined) view.setUint32(28, Number(data.K), true);
  return buf;
}

export class DML_TOP_K_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputValueTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputIndexTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get K(): number {
    return this.view.getUint32(28, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputValueTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputIndexTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set K(value: number) {
    this.view.setUint32(28, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BATCH_NORMALIZATION_OPERATOR_DESC (size: 64)
 */
export interface DML_BATCH_NORMALIZATION_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  MeanTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  VarianceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Foundation.BOOL */
  Spatial: boolean;
  /** f32 */
  Epsilon: number;
  /** ptr */
  FusedActivation: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_BATCH_NORMALIZATION_OPERATOR_DESC = 64;

export function allocDML_BATCH_NORMALIZATION_OPERATOR_DESC(data?: Partial<DML_BATCH_NORMALIZATION_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BATCH_NORMALIZATION_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.MeanTensor !== undefined) view.setBigUint64(8, data.MeanTensor === null ? 0n : util.toBigInt(util.toPointer(data.MeanTensor)), true);
  // 0x10: pointer
  if (data?.VarianceTensor !== undefined) view.setBigUint64(16, data.VarianceTensor === null ? 0n : util.toBigInt(util.toPointer(data.VarianceTensor)), true);
  // 0x18: pointer
  if (data?.ScaleTensor !== undefined) view.setBigUint64(24, data.ScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.ScaleTensor)), true);
  // 0x20: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(32, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x28: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(40, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x30: i32
  if (data?.Spatial !== undefined) view.setInt32(48, Number(data.Spatial), true);
  // 0x34: f32
  if (data?.Epsilon !== undefined) view.setFloat32(52, Number(data.Epsilon), true);
  // 0x38: pointer
  if (data?.FusedActivation !== undefined) view.setBigUint64(56, data.FusedActivation === null ? 0n : util.toBigInt(util.toPointer(data.FusedActivation)), true);
  return buf;
}

export class DML_BATCH_NORMALIZATION_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get MeanTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get VarianceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get ScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: i32
  get Spatial(): number {
    return this.view.getInt32(48, true);
  }

  // 0x34: f32
  get Epsilon(): number {
    return this.view.getFloat32(52, true);
  }

  // 0x38: pointer
  get FusedActivation(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set MeanTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set VarianceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set ScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: i32
  set Spatial(value: number) {
    this.view.setInt32(48, value, true);
  }

  // 0x34: f32
  set Epsilon(value: number) {
    this.view.setFloat32(52, value, true);
  }

  // 0x38: pointer
  set FusedActivation(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC (size: 56)
 */
export interface DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Foundation.BOOL */
  CrossChannel: boolean;
  /** Windows.Win32.Foundation.BOOL */
  NormalizeVariance: boolean;
  /** f32 */
  Epsilon: number;
  /** ptr */
  FusedActivation: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC = 56;

export function allocDML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC(data?: Partial<DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ScaleTensor !== undefined) view.setBigUint64(8, data.ScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.ScaleTensor)), true);
  // 0x10: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(16, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: i32
  if (data?.CrossChannel !== undefined) view.setInt32(32, Number(data.CrossChannel), true);
  // 0x24: i32
  if (data?.NormalizeVariance !== undefined) view.setInt32(36, Number(data.NormalizeVariance), true);
  // 0x28: f32
  if (data?.Epsilon !== undefined) view.setFloat32(40, Number(data.Epsilon), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.FusedActivation !== undefined) view.setBigUint64(48, data.FusedActivation === null ? 0n : util.toBigInt(util.toPointer(data.FusedActivation)), true);
  return buf;
}

export class DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: i32
  get CrossChannel(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: i32
  get NormalizeVariance(): number {
    return this.view.getInt32(36, true);
  }

  // 0x28: f32
  get Epsilon(): number {
    return this.view.getFloat32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get FusedActivation(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: i32
  set CrossChannel(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: i32
  set NormalizeVariance(value: number) {
    this.view.setInt32(36, value, true);
  }

  // 0x28: f32
  set Epsilon(value: number) {
    this.view.setFloat32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set FusedActivation(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC (size: 40)
 */
export interface DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Foundation.BOOL */
  CrossChannel: boolean;
  /** u32 */
  LocalSize: number;
  /** f32 */
  Alpha: number;
  /** f32 */
  Beta: number;
  /** f32 */
  Bias: number;
}

export const sizeofDML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC = 40;

export function allocDML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC(data?: Partial<DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: i32
  if (data?.CrossChannel !== undefined) view.setInt32(16, Number(data.CrossChannel), true);
  // 0x14: u32
  if (data?.LocalSize !== undefined) view.setUint32(20, Number(data.LocalSize), true);
  // 0x18: f32
  if (data?.Alpha !== undefined) view.setFloat32(24, Number(data.Alpha), true);
  // 0x1c: f32
  if (data?.Beta !== undefined) view.setFloat32(28, Number(data.Beta), true);
  // 0x20: f32
  if (data?.Bias !== undefined) view.setFloat32(32, Number(data.Bias), true);
  // 0x24: pad4
  return buf;
}

export class DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: i32
  get CrossChannel(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: u32
  get LocalSize(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: f32
  get Alpha(): number {
    return this.view.getFloat32(24, true);
  }

  // 0x1c: f32
  get Beta(): number {
    return this.view.getFloat32(28, true);
  }

  // 0x20: f32
  get Bias(): number {
    return this.view.getFloat32(32, true);
  }

  // 0x24: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: i32
  set CrossChannel(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: u32
  set LocalSize(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: f32
  set Alpha(value: number) {
    this.view.setFloat32(24, value, true);
  }

  // 0x1c: f32
  set Beta(value: number) {
    this.view.setFloat32(28, value, true);
  }

  // 0x20: f32
  set Bias(value: number) {
    this.view.setFloat32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_LP_NORMALIZATION_OPERATOR_DESC (size: 32)
 */
export interface DML_LP_NORMALIZATION_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
  /** f32 */
  Epsilon: number;
  /** u32 */
  P: number;
}

export const sizeofDML_LP_NORMALIZATION_OPERATOR_DESC = 32;

export function allocDML_LP_NORMALIZATION_OPERATOR_DESC(data?: Partial<DML_LP_NORMALIZATION_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_LP_NORMALIZATION_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.Axis !== undefined) view.setUint32(16, Number(data.Axis), true);
  // 0x14: f32
  if (data?.Epsilon !== undefined) view.setFloat32(20, Number(data.Epsilon), true);
  // 0x18: u32
  if (data?.P !== undefined) view.setUint32(24, Number(data.P), true);
  // 0x1c: pad4
  return buf;
}

export class DML_LP_NORMALIZATION_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get Axis(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: f32
  get Epsilon(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x18: u32
  get P(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set Axis(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: f32
  set Epsilon(value: number) {
    this.view.setFloat32(20, value, true);
  }

  // 0x18: u32
  set P(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_RNN_OPERATOR_DESC (size: 88)
 */
export interface DML_RNN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WeightTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  RecurrenceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  HiddenInitTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  SequenceLengthsTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputSequenceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputSingleTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  ActivationDescCount: number;
  /** ptr */
  ActivationDescs: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_RECURRENT_NETWORK_DIRECTION */
  Direction: DML_RECURRENT_NETWORK_DIRECTION;
}

export const sizeofDML_RNN_OPERATOR_DESC = 88;

export function allocDML_RNN_OPERATOR_DESC(data?: Partial<DML_RNN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_RNN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.WeightTensor !== undefined) view.setBigUint64(8, data.WeightTensor === null ? 0n : util.toBigInt(util.toPointer(data.WeightTensor)), true);
  // 0x10: pointer
  if (data?.RecurrenceTensor !== undefined) view.setBigUint64(16, data.RecurrenceTensor === null ? 0n : util.toBigInt(util.toPointer(data.RecurrenceTensor)), true);
  // 0x18: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(24, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x20: pointer
  if (data?.HiddenInitTensor !== undefined) view.setBigUint64(32, data.HiddenInitTensor === null ? 0n : util.toBigInt(util.toPointer(data.HiddenInitTensor)), true);
  // 0x28: pointer
  if (data?.SequenceLengthsTensor !== undefined) view.setBigUint64(40, data.SequenceLengthsTensor === null ? 0n : util.toBigInt(util.toPointer(data.SequenceLengthsTensor)), true);
  // 0x30: pointer
  if (data?.OutputSequenceTensor !== undefined) view.setBigUint64(48, data.OutputSequenceTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputSequenceTensor)), true);
  // 0x38: pointer
  if (data?.OutputSingleTensor !== undefined) view.setBigUint64(56, data.OutputSingleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputSingleTensor)), true);
  // 0x40: u32
  if (data?.ActivationDescCount !== undefined) view.setUint32(64, Number(data.ActivationDescCount), true);
  // 0x44: pad4
  // 0x48: pointer
  if (data?.ActivationDescs !== undefined) view.setBigUint64(72, data.ActivationDescs === null ? 0n : util.toBigInt(util.toPointer(data.ActivationDescs)), true);
  // 0x50: i32
  if (data?.Direction !== undefined) view.setInt32(80, Number(data.Direction), true);
  // 0x54: pad4
  return buf;
}

export class DML_RNN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get WeightTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get RecurrenceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get HiddenInitTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get SequenceLengthsTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get OutputSequenceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get OutputSingleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: u32
  get ActivationDescCount(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  get ActivationDescs(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(72, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x50: i32
  get Direction(): number {
    return this.view.getInt32(80, true);
  }

  // 0x54: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set WeightTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set RecurrenceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set HiddenInitTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set SequenceLengthsTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set OutputSequenceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set OutputSingleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: u32
  set ActivationDescCount(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  set ActivationDescs(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(72, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x50: i32
  set Direction(value: number) {
    this.view.setInt32(80, value, true);
  }

  // 0x54: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_LSTM_OPERATOR_DESC (size: 120)
 */
export interface DML_LSTM_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WeightTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  RecurrenceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  HiddenInitTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  CellMemInitTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  SequenceLengthsTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  PeepholeTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputSequenceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputSingleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputCellSingleTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  ActivationDescCount: number;
  /** ptr */
  ActivationDescs: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_RECURRENT_NETWORK_DIRECTION */
  Direction: DML_RECURRENT_NETWORK_DIRECTION;
  /** f32 */
  ClipThreshold: number;
  /** Windows.Win32.Foundation.BOOL */
  UseClipThreshold: boolean;
  /** Windows.Win32.Foundation.BOOL */
  CoupleInputForget: boolean;
}

export const sizeofDML_LSTM_OPERATOR_DESC = 120;

export function allocDML_LSTM_OPERATOR_DESC(data?: Partial<DML_LSTM_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_LSTM_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.WeightTensor !== undefined) view.setBigUint64(8, data.WeightTensor === null ? 0n : util.toBigInt(util.toPointer(data.WeightTensor)), true);
  // 0x10: pointer
  if (data?.RecurrenceTensor !== undefined) view.setBigUint64(16, data.RecurrenceTensor === null ? 0n : util.toBigInt(util.toPointer(data.RecurrenceTensor)), true);
  // 0x18: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(24, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x20: pointer
  if (data?.HiddenInitTensor !== undefined) view.setBigUint64(32, data.HiddenInitTensor === null ? 0n : util.toBigInt(util.toPointer(data.HiddenInitTensor)), true);
  // 0x28: pointer
  if (data?.CellMemInitTensor !== undefined) view.setBigUint64(40, data.CellMemInitTensor === null ? 0n : util.toBigInt(util.toPointer(data.CellMemInitTensor)), true);
  // 0x30: pointer
  if (data?.SequenceLengthsTensor !== undefined) view.setBigUint64(48, data.SequenceLengthsTensor === null ? 0n : util.toBigInt(util.toPointer(data.SequenceLengthsTensor)), true);
  // 0x38: pointer
  if (data?.PeepholeTensor !== undefined) view.setBigUint64(56, data.PeepholeTensor === null ? 0n : util.toBigInt(util.toPointer(data.PeepholeTensor)), true);
  // 0x40: pointer
  if (data?.OutputSequenceTensor !== undefined) view.setBigUint64(64, data.OutputSequenceTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputSequenceTensor)), true);
  // 0x48: pointer
  if (data?.OutputSingleTensor !== undefined) view.setBigUint64(72, data.OutputSingleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputSingleTensor)), true);
  // 0x50: pointer
  if (data?.OutputCellSingleTensor !== undefined) view.setBigUint64(80, data.OutputCellSingleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputCellSingleTensor)), true);
  // 0x58: u32
  if (data?.ActivationDescCount !== undefined) view.setUint32(88, Number(data.ActivationDescCount), true);
  // 0x5c: pad4
  // 0x60: pointer
  if (data?.ActivationDescs !== undefined) view.setBigUint64(96, data.ActivationDescs === null ? 0n : util.toBigInt(util.toPointer(data.ActivationDescs)), true);
  // 0x68: i32
  if (data?.Direction !== undefined) view.setInt32(104, Number(data.Direction), true);
  // 0x6c: f32
  if (data?.ClipThreshold !== undefined) view.setFloat32(108, Number(data.ClipThreshold), true);
  // 0x70: i32
  if (data?.UseClipThreshold !== undefined) view.setInt32(112, Number(data.UseClipThreshold), true);
  // 0x74: i32
  if (data?.CoupleInputForget !== undefined) view.setInt32(116, Number(data.CoupleInputForget), true);
  return buf;
}

export class DML_LSTM_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get WeightTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get RecurrenceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get HiddenInitTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get CellMemInitTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get SequenceLengthsTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get PeepholeTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get OutputSequenceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x48: pointer
  get OutputSingleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(72, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x50: pointer
  get OutputCellSingleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(80, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x58: u32
  get ActivationDescCount(): number {
    return this.view.getUint32(88, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  get ActivationDescs(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(96, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x68: i32
  get Direction(): number {
    return this.view.getInt32(104, true);
  }

  // 0x6c: f32
  get ClipThreshold(): number {
    return this.view.getFloat32(108, true);
  }

  // 0x70: i32
  get UseClipThreshold(): number {
    return this.view.getInt32(112, true);
  }

  // 0x74: i32
  get CoupleInputForget(): number {
    return this.view.getInt32(116, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set WeightTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set RecurrenceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set HiddenInitTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set CellMemInitTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set SequenceLengthsTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set PeepholeTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set OutputSequenceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x48: pointer
  set OutputSingleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(72, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x50: pointer
  set OutputCellSingleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(80, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x58: u32
  set ActivationDescCount(value: number) {
    this.view.setUint32(88, value, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  set ActivationDescs(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(96, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x68: i32
  set Direction(value: number) {
    this.view.setInt32(104, value, true);
  }

  // 0x6c: f32
  set ClipThreshold(value: number) {
    this.view.setFloat32(108, value, true);
  }

  // 0x70: i32
  set UseClipThreshold(value: number) {
    this.view.setInt32(112, value, true);
  }

  // 0x74: i32
  set CoupleInputForget(value: number) {
    this.view.setInt32(116, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GRU_OPERATOR_DESC (size: 88)
 */
export interface DML_GRU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WeightTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  RecurrenceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  HiddenInitTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  SequenceLengthsTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputSequenceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputSingleTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  ActivationDescCount: number;
  /** ptr */
  ActivationDescs: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_RECURRENT_NETWORK_DIRECTION */
  Direction: DML_RECURRENT_NETWORK_DIRECTION;
  /** Windows.Win32.Foundation.BOOL */
  LinearBeforeReset: boolean;
}

export const sizeofDML_GRU_OPERATOR_DESC = 88;

export function allocDML_GRU_OPERATOR_DESC(data?: Partial<DML_GRU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GRU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.WeightTensor !== undefined) view.setBigUint64(8, data.WeightTensor === null ? 0n : util.toBigInt(util.toPointer(data.WeightTensor)), true);
  // 0x10: pointer
  if (data?.RecurrenceTensor !== undefined) view.setBigUint64(16, data.RecurrenceTensor === null ? 0n : util.toBigInt(util.toPointer(data.RecurrenceTensor)), true);
  // 0x18: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(24, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x20: pointer
  if (data?.HiddenInitTensor !== undefined) view.setBigUint64(32, data.HiddenInitTensor === null ? 0n : util.toBigInt(util.toPointer(data.HiddenInitTensor)), true);
  // 0x28: pointer
  if (data?.SequenceLengthsTensor !== undefined) view.setBigUint64(40, data.SequenceLengthsTensor === null ? 0n : util.toBigInt(util.toPointer(data.SequenceLengthsTensor)), true);
  // 0x30: pointer
  if (data?.OutputSequenceTensor !== undefined) view.setBigUint64(48, data.OutputSequenceTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputSequenceTensor)), true);
  // 0x38: pointer
  if (data?.OutputSingleTensor !== undefined) view.setBigUint64(56, data.OutputSingleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputSingleTensor)), true);
  // 0x40: u32
  if (data?.ActivationDescCount !== undefined) view.setUint32(64, Number(data.ActivationDescCount), true);
  // 0x44: pad4
  // 0x48: pointer
  if (data?.ActivationDescs !== undefined) view.setBigUint64(72, data.ActivationDescs === null ? 0n : util.toBigInt(util.toPointer(data.ActivationDescs)), true);
  // 0x50: i32
  if (data?.Direction !== undefined) view.setInt32(80, Number(data.Direction), true);
  // 0x54: i32
  if (data?.LinearBeforeReset !== undefined) view.setInt32(84, Number(data.LinearBeforeReset), true);
  return buf;
}

export class DML_GRU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get WeightTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get RecurrenceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get HiddenInitTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get SequenceLengthsTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get OutputSequenceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get OutputSingleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: u32
  get ActivationDescCount(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  get ActivationDescs(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(72, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x50: i32
  get Direction(): number {
    return this.view.getInt32(80, true);
  }

  // 0x54: i32
  get LinearBeforeReset(): number {
    return this.view.getInt32(84, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set WeightTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set RecurrenceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set HiddenInitTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set SequenceLengthsTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set OutputSequenceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set OutputSingleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: u32
  set ActivationDescCount(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  set ActivationDescs(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(72, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x50: i32
  set Direction(value: number) {
    this.view.setInt32(80, value, true);
  }

  // 0x54: i32
  set LinearBeforeReset(value: number) {
    this.view.setInt32(84, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_SIGN_OPERATOR_DESC (size: 16)
 */
export interface DML_ELEMENT_WISE_SIGN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_SIGN_OPERATOR_DESC = 16;

export function allocDML_ELEMENT_WISE_SIGN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_SIGN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_SIGN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_SIGN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC (size: 16)
 */
export interface DML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC = 16;

export function allocDML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_IS_NAN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_IS_NAN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ERF_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ERF_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ERF_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ERF_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ERF_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ERF_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ERF_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_SINH_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_SINH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_SINH_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_SINH_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_SINH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_SINH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_SINH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_COSH_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_COSH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_COSH_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_COSH_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_COSH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_COSH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_COSH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_TANH_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_TANH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_TANH_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_TANH_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_TANH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_TANH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_TANH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ASINH_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ASINH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ASINH_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ASINH_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ASINH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ASINH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ASINH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ACOSH_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ACOSH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ACOSH_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ACOSH_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ACOSH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ACOSH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ACOSH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ATANH_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ATANH_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleBias: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ATANH_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ATANH_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ATANH_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ATANH_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.ScaleBias !== undefined) view.setBigUint64(16, data.ScaleBias === null ? 0n : util.toBigInt(util.toPointer(data.ScaleBias)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ATANH_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get ScaleBias(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set ScaleBias(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_IF_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_IF_OPERATOR_DESC {
  /** ptr */
  ConditionTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_IF_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_IF_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_IF_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_IF_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ConditionTensor !== undefined) view.setBigUint64(0, data.ConditionTensor === null ? 0n : util.toBigInt(util.toPointer(data.ConditionTensor)), true);
  // 0x08: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(8, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x10: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(16, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_IF_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ConditionTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ConditionTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_SHRINK_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_SHRINK_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Bias: number;
  /** f32 */
  Threshold: number;
}

export const sizeofDML_ACTIVATION_SHRINK_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_SHRINK_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_SHRINK_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_SHRINK_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Bias !== undefined) view.setFloat32(16, Number(data.Bias), true);
  // 0x14: f32
  if (data?.Threshold !== undefined) view.setFloat32(20, Number(data.Threshold), true);
  return buf;
}

export class DML_ACTIVATION_SHRINK_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Bias(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: f32
  get Threshold(): number {
    return this.view.getFloat32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Bias(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: f32
  set Threshold(value: number) {
    this.view.setFloat32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MAX_POOLING1_OPERATOR_DESC (size: 64)
 */
export interface DML_MAX_POOLING1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputIndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WindowSize: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MAX_POOLING1_OPERATOR_DESC = 64;

export function allocDML_MAX_POOLING1_OPERATOR_DESC(data?: Partial<DML_MAX_POOLING1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MAX_POOLING1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.OutputIndicesTensor !== undefined) view.setBigUint64(16, data.OutputIndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputIndicesTensor)), true);
  // 0x18: u32
  if (data?.DimensionCount !== undefined) view.setUint32(24, Number(data.DimensionCount), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Strides !== undefined) view.setBigUint64(32, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x28: pointer
  if (data?.WindowSize !== undefined) view.setBigUint64(40, data.WindowSize === null ? 0n : util.toBigInt(util.toPointer(data.WindowSize)), true);
  // 0x30: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(48, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x38: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(56, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  return buf;
}

export class DML_MAX_POOLING1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputIndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get DimensionCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get WindowSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputIndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set DimensionCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set WindowSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MAX_UNPOOLING_OPERATOR_DESC (size: 24)
 */
export interface DML_MAX_UNPOOLING_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MAX_UNPOOLING_OPERATOR_DESC = 24;

export function allocDML_MAX_UNPOOLING_OPERATOR_DESC(data?: Partial<DML_MAX_UNPOOLING_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MAX_UNPOOLING_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(8, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_MAX_UNPOOLING_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_DIAGONAL_MATRIX_OPERATOR_DESC (size: 16)
 */
export interface DML_DIAGONAL_MATRIX_OPERATOR_DESC {
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** i32 */
  Offset: number;
  /** f32 */
  Value: number;
}

export const sizeofDML_DIAGONAL_MATRIX_OPERATOR_DESC = 16;

export function allocDML_DIAGONAL_MATRIX_OPERATOR_DESC(data?: Partial<DML_DIAGONAL_MATRIX_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_DIAGONAL_MATRIX_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(0, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x08: i32
  if (data?.Offset !== undefined) view.setInt32(8, Number(data.Offset), true);
  // 0x0c: f32
  if (data?.Value !== undefined) view.setFloat32(12, Number(data.Value), true);
  return buf;
}

export class DML_DIAGONAL_MATRIX_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: i32
  get Offset(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: f32
  get Value(): number {
    return this.view.getFloat32(12, true);
  }

  // 0x00: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: i32
  set Offset(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: f32
  set Value(value: number) {
    this.view.setFloat32(12, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SCATTER_OPERATOR_DESC (size: 40)
 */
export interface DML_SCATTER_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  UpdatesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
}

export const sizeofDML_SCATTER_OPERATOR_DESC = 40;

export function allocDML_SCATTER_OPERATOR_DESC(data?: Partial<DML_SCATTER_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SCATTER_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(8, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x10: pointer
  if (data?.UpdatesTensor !== undefined) view.setBigUint64(16, data.UpdatesTensor === null ? 0n : util.toBigInt(util.toPointer(data.UpdatesTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: u32
  if (data?.Axis !== undefined) view.setUint32(32, Number(data.Axis), true);
  // 0x24: pad4
  return buf;
}

export class DML_SCATTER_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get UpdatesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: u32
  get Axis(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set UpdatesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: u32
  set Axis(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ONE_HOT_OPERATOR_DESC (size: 32)
 */
export interface DML_ONE_HOT_OPERATOR_DESC {
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ValuesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
}

export const sizeofDML_ONE_HOT_OPERATOR_DESC = 32;

export function allocDML_ONE_HOT_OPERATOR_DESC(data?: Partial<DML_ONE_HOT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ONE_HOT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(0, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x08: pointer
  if (data?.ValuesTensor !== undefined) view.setBigUint64(8, data.ValuesTensor === null ? 0n : util.toBigInt(util.toPointer(data.ValuesTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: pad4
  return buf;
}

export class DML_ONE_HOT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ValuesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ValuesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_RESAMPLE_OPERATOR_DESC (size: 32)
 */
export interface DML_RESAMPLE_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_INTERPOLATION_MODE */
  InterpolationMode: DML_INTERPOLATION_MODE;
  /** u32 */
  ScaleCount: number;
  /** ptr */
  Scales: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_RESAMPLE_OPERATOR_DESC = 32;

export function allocDML_RESAMPLE_OPERATOR_DESC(data?: Partial<DML_RESAMPLE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_RESAMPLE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: i32
  if (data?.InterpolationMode !== undefined) view.setInt32(16, Number(data.InterpolationMode), true);
  // 0x14: u32
  if (data?.ScaleCount !== undefined) view.setUint32(20, Number(data.ScaleCount), true);
  // 0x18: pointer
  if (data?.Scales !== undefined) view.setBigUint64(24, data.Scales === null ? 0n : util.toBigInt(util.toPointer(data.Scales)), true);
  return buf;
}

export class DML_RESAMPLE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: i32
  get InterpolationMode(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: u32
  get ScaleCount(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get Scales(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: i32
  set InterpolationMode(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: u32
  set ScaleCount(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set Scales(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_BIT_SHIFT_LEFT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_BIT_SHIFT_RIGHT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ROUND_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ROUND_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_ROUNDING_MODE */
  RoundingMode: DML_ROUNDING_MODE;
}

export const sizeofDML_ELEMENT_WISE_ROUND_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ROUND_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ROUND_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ROUND_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: i32
  if (data?.RoundingMode !== undefined) view.setInt32(16, Number(data.RoundingMode), true);
  // 0x14: pad4
  return buf;
}

export class DML_ELEMENT_WISE_ROUND_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: i32
  get RoundingMode(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: i32
  set RoundingMode(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_IS_INFINITY_MODE */
  InfinityMode: DML_IS_INFINITY_MODE;
}

export const sizeofDML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: i32
  if (data?.InfinityMode !== undefined) view.setInt32(16, Number(data.InfinityMode), true);
  // 0x14: pad4
  return buf;
}

export class DML_ELEMENT_WISE_IS_INFINITY_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: i32
  get InfinityMode(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: i32
  set InfinityMode(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_MODULUS_TRUNCATE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_MODULUS_FLOOR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_FILL_VALUE_CONSTANT_OPERATOR_DESC (size: 24)
 */
export interface DML_FILL_VALUE_CONSTANT_OPERATOR_DESC {
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_TENSOR_DATA_TYPE */
  ValueDataType: DML_TENSOR_DATA_TYPE;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_SCALAR_UNION */
  Value: Uint8Array | Deno.PointerValue | null;
}

export const sizeofDML_FILL_VALUE_CONSTANT_OPERATOR_DESC = 24;

export function allocDML_FILL_VALUE_CONSTANT_OPERATOR_DESC(data?: Partial<DML_FILL_VALUE_CONSTANT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_FILL_VALUE_CONSTANT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(0, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x08: i32
  if (data?.ValueDataType !== undefined) view.setInt32(8, Number(data.ValueDataType), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Value !== undefined) view.setBigUint64(16, data.Value === null ? 0n : util.toBigInt(util.toPointer(data.Value)), true);
  return buf;
}

export class DML_FILL_VALUE_CONSTANT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: i32
  get ValueDataType(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Value(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: i32
  set ValueDataType(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Value(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_FILL_VALUE_SEQUENCE_OPERATOR_DESC (size: 32)
 */
export interface DML_FILL_VALUE_SEQUENCE_OPERATOR_DESC {
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_TENSOR_DATA_TYPE */
  ValueDataType: DML_TENSOR_DATA_TYPE;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_SCALAR_UNION */
  ValueStart: Uint8Array | Deno.PointerValue | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_SCALAR_UNION */
  ValueDelta: Uint8Array | Deno.PointerValue | null;
}

export const sizeofDML_FILL_VALUE_SEQUENCE_OPERATOR_DESC = 32;

export function allocDML_FILL_VALUE_SEQUENCE_OPERATOR_DESC(data?: Partial<DML_FILL_VALUE_SEQUENCE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_FILL_VALUE_SEQUENCE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(0, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x08: i32
  if (data?.ValueDataType !== undefined) view.setInt32(8, Number(data.ValueDataType), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.ValueStart !== undefined) view.setBigUint64(16, data.ValueStart === null ? 0n : util.toBigInt(util.toPointer(data.ValueStart)), true);
  // 0x18: pointer
  if (data?.ValueDelta !== undefined) view.setBigUint64(24, data.ValueDelta === null ? 0n : util.toBigInt(util.toPointer(data.ValueDelta)), true);
  return buf;
}

export class DML_FILL_VALUE_SEQUENCE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: i32
  get ValueDataType(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get ValueStart(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get ValueDelta(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: i32
  set ValueDataType(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set ValueStart(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set ValueDelta(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_CUMULATIVE_SUMMATION_OPERATOR_DESC (size: 32)
 */
export interface DML_CUMULATIVE_SUMMATION_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_AXIS_DIRECTION */
  AxisDirection: DML_AXIS_DIRECTION;
  /** Windows.Win32.Foundation.BOOL */
  HasExclusiveSum: boolean;
}

export const sizeofDML_CUMULATIVE_SUMMATION_OPERATOR_DESC = 32;

export function allocDML_CUMULATIVE_SUMMATION_OPERATOR_DESC(data?: Partial<DML_CUMULATIVE_SUMMATION_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_CUMULATIVE_SUMMATION_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.Axis !== undefined) view.setUint32(16, Number(data.Axis), true);
  // 0x14: i32
  if (data?.AxisDirection !== undefined) view.setInt32(20, Number(data.AxisDirection), true);
  // 0x18: i32
  if (data?.HasExclusiveSum !== undefined) view.setInt32(24, Number(data.HasExclusiveSum), true);
  // 0x1c: pad4
  return buf;
}

export class DML_CUMULATIVE_SUMMATION_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get Axis(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: i32
  get AxisDirection(): number {
    return this.view.getInt32(20, true);
  }

  // 0x18: i32
  get HasExclusiveSum(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set Axis(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: i32
  set AxisDirection(value: number) {
    this.view.setInt32(20, value, true);
  }

  // 0x18: i32
  set HasExclusiveSum(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_REVERSE_SUBSEQUENCES_OPERATOR_DESC (size: 32)
 */
export interface DML_REVERSE_SUBSEQUENCES_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  SequenceLengthsTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
}

export const sizeofDML_REVERSE_SUBSEQUENCES_OPERATOR_DESC = 32;

export function allocDML_REVERSE_SUBSEQUENCES_OPERATOR_DESC(data?: Partial<DML_REVERSE_SUBSEQUENCES_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_REVERSE_SUBSEQUENCES_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.SequenceLengthsTensor !== undefined) view.setBigUint64(8, data.SequenceLengthsTensor === null ? 0n : util.toBigInt(util.toPointer(data.SequenceLengthsTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: pad4
  return buf;
}

export class DML_REVERSE_SUBSEQUENCES_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get SequenceLengthsTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set SequenceLengthsTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GATHER_ELEMENTS_OPERATOR_DESC (size: 32)
 */
export interface DML_GATHER_ELEMENTS_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
}

export const sizeofDML_GATHER_ELEMENTS_OPERATOR_DESC = 32;

export function allocDML_GATHER_ELEMENTS_OPERATOR_DESC(data?: Partial<DML_GATHER_ELEMENTS_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GATHER_ELEMENTS_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(8, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: pad4
  return buf;
}

export class DML_GATHER_ELEMENTS_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GATHER_ND_OPERATOR_DESC (size: 32)
 */
export interface DML_GATHER_ND_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  InputDimensionCount: number;
  /** u32 */
  IndicesDimensionCount: number;
}

export const sizeofDML_GATHER_ND_OPERATOR_DESC = 32;

export function allocDML_GATHER_ND_OPERATOR_DESC(data?: Partial<DML_GATHER_ND_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GATHER_ND_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(8, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.InputDimensionCount !== undefined) view.setUint32(24, Number(data.InputDimensionCount), true);
  // 0x1c: u32
  if (data?.IndicesDimensionCount !== undefined) view.setUint32(28, Number(data.IndicesDimensionCount), true);
  return buf;
}

export class DML_GATHER_ND_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get InputDimensionCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get IndicesDimensionCount(): number {
    return this.view.getUint32(28, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set InputDimensionCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set IndicesDimensionCount(value: number) {
    this.view.setUint32(28, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SCATTER_ND_OPERATOR_DESC (size: 40)
 */
export interface DML_SCATTER_ND_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  UpdatesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  InputDimensionCount: number;
  /** u32 */
  IndicesDimensionCount: number;
}

export const sizeofDML_SCATTER_ND_OPERATOR_DESC = 40;

export function allocDML_SCATTER_ND_OPERATOR_DESC(data?: Partial<DML_SCATTER_ND_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SCATTER_ND_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(8, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x10: pointer
  if (data?.UpdatesTensor !== undefined) view.setBigUint64(16, data.UpdatesTensor === null ? 0n : util.toBigInt(util.toPointer(data.UpdatesTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: u32
  if (data?.InputDimensionCount !== undefined) view.setUint32(32, Number(data.InputDimensionCount), true);
  // 0x24: u32
  if (data?.IndicesDimensionCount !== undefined) view.setUint32(36, Number(data.IndicesDimensionCount), true);
  return buf;
}

export class DML_SCATTER_ND_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get UpdatesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: u32
  get InputDimensionCount(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: u32
  get IndicesDimensionCount(): number {
    return this.view.getUint32(36, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set UpdatesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: u32
  set InputDimensionCount(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: u32
  set IndicesDimensionCount(value: number) {
    this.view.setUint32(36, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MAX_POOLING2_OPERATOR_DESC (size: 72)
 */
export interface DML_MAX_POOLING2_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputIndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WindowSize: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Dilations: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MAX_POOLING2_OPERATOR_DESC = 72;

export function allocDML_MAX_POOLING2_OPERATOR_DESC(data?: Partial<DML_MAX_POOLING2_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MAX_POOLING2_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.OutputIndicesTensor !== undefined) view.setBigUint64(16, data.OutputIndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputIndicesTensor)), true);
  // 0x18: u32
  if (data?.DimensionCount !== undefined) view.setUint32(24, Number(data.DimensionCount), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Strides !== undefined) view.setBigUint64(32, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x28: pointer
  if (data?.WindowSize !== undefined) view.setBigUint64(40, data.WindowSize === null ? 0n : util.toBigInt(util.toPointer(data.WindowSize)), true);
  // 0x30: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(48, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x38: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(56, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x40: pointer
  if (data?.Dilations !== undefined) view.setBigUint64(64, data.Dilations === null ? 0n : util.toBigInt(util.toPointer(data.Dilations)), true);
  return buf;
}

export class DML_MAX_POOLING2_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputIndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get DimensionCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get WindowSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get Dilations(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputIndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set DimensionCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set WindowSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set Dilations(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SLICE1_OPERATOR_DESC (size: 48)
 */
export interface DML_SLICE1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  InputWindowOffsets: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputWindowSizes: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputWindowStrides: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_SLICE1_OPERATOR_DESC = 48;

export function allocDML_SLICE1_OPERATOR_DESC(data?: Partial<DML_SLICE1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SLICE1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.DimensionCount !== undefined) view.setUint32(16, Number(data.DimensionCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.InputWindowOffsets !== undefined) view.setBigUint64(24, data.InputWindowOffsets === null ? 0n : util.toBigInt(util.toPointer(data.InputWindowOffsets)), true);
  // 0x20: pointer
  if (data?.InputWindowSizes !== undefined) view.setBigUint64(32, data.InputWindowSizes === null ? 0n : util.toBigInt(util.toPointer(data.InputWindowSizes)), true);
  // 0x28: pointer
  if (data?.InputWindowStrides !== undefined) view.setBigUint64(40, data.InputWindowStrides === null ? 0n : util.toBigInt(util.toPointer(data.InputWindowStrides)), true);
  return buf;
}

export class DML_SLICE1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get DimensionCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get InputWindowOffsets(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get InputWindowSizes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get InputWindowStrides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set DimensionCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set InputWindowOffsets(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set InputWindowSizes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set InputWindowStrides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_TOP_K1_OPERATOR_DESC (size: 40)
 */
export interface DML_TOP_K1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputValueTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputIndexTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
  /** u32 */
  K: number;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_AXIS_DIRECTION */
  AxisDirection: DML_AXIS_DIRECTION;
}

export const sizeofDML_TOP_K1_OPERATOR_DESC = 40;

export function allocDML_TOP_K1_OPERATOR_DESC(data?: Partial<DML_TOP_K1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_TOP_K1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputValueTensor !== undefined) view.setBigUint64(8, data.OutputValueTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputValueTensor)), true);
  // 0x10: pointer
  if (data?.OutputIndexTensor !== undefined) view.setBigUint64(16, data.OutputIndexTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputIndexTensor)), true);
  // 0x18: u32
  if (data?.Axis !== undefined) view.setUint32(24, Number(data.Axis), true);
  // 0x1c: u32
  if (data?.K !== undefined) view.setUint32(28, Number(data.K), true);
  // 0x20: i32
  if (data?.AxisDirection !== undefined) view.setInt32(32, Number(data.AxisDirection), true);
  // 0x24: pad4
  return buf;
}

export class DML_TOP_K1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputValueTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputIndexTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get Axis(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get K(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: i32
  get AxisDirection(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputValueTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputIndexTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set Axis(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set K(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: i32
  set AxisDirection(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_DEPTH_TO_SPACE1_OPERATOR_DESC (size: 24)
 */
export interface DML_DEPTH_TO_SPACE1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  BlockSize: number;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_DEPTH_SPACE_ORDER */
  Order: DML_DEPTH_SPACE_ORDER;
}

export const sizeofDML_DEPTH_TO_SPACE1_OPERATOR_DESC = 24;

export function allocDML_DEPTH_TO_SPACE1_OPERATOR_DESC(data?: Partial<DML_DEPTH_TO_SPACE1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_DEPTH_TO_SPACE1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.BlockSize !== undefined) view.setUint32(16, Number(data.BlockSize), true);
  // 0x14: i32
  if (data?.Order !== undefined) view.setInt32(20, Number(data.Order), true);
  return buf;
}

export class DML_DEPTH_TO_SPACE1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get BlockSize(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: i32
  get Order(): number {
    return this.view.getInt32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set BlockSize(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: i32
  set Order(value: number) {
    this.view.setInt32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SPACE_TO_DEPTH1_OPERATOR_DESC (size: 24)
 */
export interface DML_SPACE_TO_DEPTH1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  BlockSize: number;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_DEPTH_SPACE_ORDER */
  Order: DML_DEPTH_SPACE_ORDER;
}

export const sizeofDML_SPACE_TO_DEPTH1_OPERATOR_DESC = 24;

export function allocDML_SPACE_TO_DEPTH1_OPERATOR_DESC(data?: Partial<DML_SPACE_TO_DEPTH1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SPACE_TO_DEPTH1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.BlockSize !== undefined) view.setUint32(16, Number(data.BlockSize), true);
  // 0x14: i32
  if (data?.Order !== undefined) view.setInt32(20, Number(data.Order), true);
  return buf;
}

export class DML_SPACE_TO_DEPTH1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get BlockSize(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: i32
  get Order(): number {
    return this.view.getInt32(20, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set BlockSize(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: i32
  set Order(value: number) {
    this.view.setInt32(20, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC (size: 64)
 */
export interface DML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  AxisCount: number;
  /** ptr */
  Axes: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Foundation.BOOL */
  NormalizeVariance: boolean;
  /** f32 */
  Epsilon: number;
  /** ptr */
  FusedActivation: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC = 64;

export function allocDML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC(data?: Partial<DML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ScaleTensor !== undefined) view.setBigUint64(8, data.ScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.ScaleTensor)), true);
  // 0x10: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(16, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: u32
  if (data?.AxisCount !== undefined) view.setUint32(32, Number(data.AxisCount), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.Axes !== undefined) view.setBigUint64(40, data.Axes === null ? 0n : util.toBigInt(util.toPointer(data.Axes)), true);
  // 0x30: i32
  if (data?.NormalizeVariance !== undefined) view.setInt32(48, Number(data.NormalizeVariance), true);
  // 0x34: f32
  if (data?.Epsilon !== undefined) view.setFloat32(52, Number(data.Epsilon), true);
  // 0x38: pointer
  if (data?.FusedActivation !== undefined) view.setBigUint64(56, data.FusedActivation === null ? 0n : util.toBigInt(util.toPointer(data.FusedActivation)), true);
  return buf;
}

export class DML_MEAN_VARIANCE_NORMALIZATION1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: u32
  get AxisCount(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get Axes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: i32
  get NormalizeVariance(): number {
    return this.view.getInt32(48, true);
  }

  // 0x34: f32
  get Epsilon(): number {
    return this.view.getFloat32(52, true);
  }

  // 0x38: pointer
  get FusedActivation(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: u32
  set AxisCount(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set Axes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: i32
  set NormalizeVariance(value: number) {
    this.view.setInt32(48, value, true);
  }

  // 0x34: f32
  set Epsilon(value: number) {
    this.view.setFloat32(52, value, true);
  }

  // 0x38: pointer
  set FusedActivation(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_RESAMPLE1_OPERATOR_DESC (size: 48)
 */
export interface DML_RESAMPLE1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_INTERPOLATION_MODE */
  InterpolationMode: DML_INTERPOLATION_MODE;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Scales: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputPixelOffsets: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputPixelOffsets: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_RESAMPLE1_OPERATOR_DESC = 48;

export function allocDML_RESAMPLE1_OPERATOR_DESC(data?: Partial<DML_RESAMPLE1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_RESAMPLE1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: i32
  if (data?.InterpolationMode !== undefined) view.setInt32(16, Number(data.InterpolationMode), true);
  // 0x14: u32
  if (data?.DimensionCount !== undefined) view.setUint32(20, Number(data.DimensionCount), true);
  // 0x18: pointer
  if (data?.Scales !== undefined) view.setBigUint64(24, data.Scales === null ? 0n : util.toBigInt(util.toPointer(data.Scales)), true);
  // 0x20: pointer
  if (data?.InputPixelOffsets !== undefined) view.setBigUint64(32, data.InputPixelOffsets === null ? 0n : util.toBigInt(util.toPointer(data.InputPixelOffsets)), true);
  // 0x28: pointer
  if (data?.OutputPixelOffsets !== undefined) view.setBigUint64(40, data.OutputPixelOffsets === null ? 0n : util.toBigInt(util.toPointer(data.OutputPixelOffsets)), true);
  return buf;
}

export class DML_RESAMPLE1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: i32
  get InterpolationMode(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: u32
  get DimensionCount(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get Scales(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get InputPixelOffsets(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get OutputPixelOffsets(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: i32
  set InterpolationMode(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: u32
  set DimensionCount(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set Scales(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set InputPixelOffsets(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set OutputPixelOffsets(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC (size: 40)
 */
export interface DML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  AZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC = 40;

export function allocDML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC(data?: Partial<DML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.AZeroPointTensor !== undefined) view.setBigUint64(8, data.AZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.AZeroPointTensor)), true);
  // 0x10: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(16, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x18: pointer
  if (data?.BZeroPointTensor !== undefined) view.setBigUint64(24, data.BZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.BZeroPointTensor)), true);
  // 0x20: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(32, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_MATRIX_MULTIPLY_INTEGER_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get AZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get BZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set AZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set BZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC (size: 72)
 */
export interface DML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  AScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  AZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC = 72;

export function allocDML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC(data?: Partial<DML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.AScaleTensor !== undefined) view.setBigUint64(8, data.AScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.AScaleTensor)), true);
  // 0x10: pointer
  if (data?.AZeroPointTensor !== undefined) view.setBigUint64(16, data.AZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.AZeroPointTensor)), true);
  // 0x18: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(24, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x20: pointer
  if (data?.BScaleTensor !== undefined) view.setBigUint64(32, data.BScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.BScaleTensor)), true);
  // 0x28: pointer
  if (data?.BZeroPointTensor !== undefined) view.setBigUint64(40, data.BZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.BZeroPointTensor)), true);
  // 0x30: pointer
  if (data?.OutputScaleTensor !== undefined) view.setBigUint64(48, data.OutputScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputScaleTensor)), true);
  // 0x38: pointer
  if (data?.OutputZeroPointTensor !== undefined) view.setBigUint64(56, data.OutputZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputZeroPointTensor)), true);
  // 0x40: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(64, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_QUANTIZED_LINEAR_MATRIX_MULTIPLY_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get AScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get AZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get BScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get BZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get OutputScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get OutputZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set AScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set AZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set BScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set BZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set OutputScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set OutputZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_CONVOLUTION_INTEGER_OPERATOR_DESC (size: 88)
 */
export interface DML_CONVOLUTION_INTEGER_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  FilterTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  FilterZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Dilations: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  GroupCount: number;
}

export const sizeofDML_CONVOLUTION_INTEGER_OPERATOR_DESC = 88;

export function allocDML_CONVOLUTION_INTEGER_OPERATOR_DESC(data?: Partial<DML_CONVOLUTION_INTEGER_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_CONVOLUTION_INTEGER_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.InputZeroPointTensor !== undefined) view.setBigUint64(8, data.InputZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputZeroPointTensor)), true);
  // 0x10: pointer
  if (data?.FilterTensor !== undefined) view.setBigUint64(16, data.FilterTensor === null ? 0n : util.toBigInt(util.toPointer(data.FilterTensor)), true);
  // 0x18: pointer
  if (data?.FilterZeroPointTensor !== undefined) view.setBigUint64(24, data.FilterZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.FilterZeroPointTensor)), true);
  // 0x20: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(32, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x28: u32
  if (data?.DimensionCount !== undefined) view.setUint32(40, Number(data.DimensionCount), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.Strides !== undefined) view.setBigUint64(48, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x38: pointer
  if (data?.Dilations !== undefined) view.setBigUint64(56, data.Dilations === null ? 0n : util.toBigInt(util.toPointer(data.Dilations)), true);
  // 0x40: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(64, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x48: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(72, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x50: u32
  if (data?.GroupCount !== undefined) view.setUint32(80, Number(data.GroupCount), true);
  // 0x54: pad4
  return buf;
}

export class DML_CONVOLUTION_INTEGER_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get FilterTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get FilterZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: u32
  get DimensionCount(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get Dilations(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x48: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(72, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x50: u32
  get GroupCount(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set FilterTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set FilterZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: u32
  set DimensionCount(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set Dilations(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x48: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(72, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x50: u32
  set GroupCount(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC (size: 128)
 */
export interface DML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  FilterTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  FilterScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  FilterZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BiasTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Dilations: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  GroupCount: number;
}

export const sizeofDML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC = 128;

export function allocDML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC(data?: Partial<DML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.InputScaleTensor !== undefined) view.setBigUint64(8, data.InputScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputScaleTensor)), true);
  // 0x10: pointer
  if (data?.InputZeroPointTensor !== undefined) view.setBigUint64(16, data.InputZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputZeroPointTensor)), true);
  // 0x18: pointer
  if (data?.FilterTensor !== undefined) view.setBigUint64(24, data.FilterTensor === null ? 0n : util.toBigInt(util.toPointer(data.FilterTensor)), true);
  // 0x20: pointer
  if (data?.FilterScaleTensor !== undefined) view.setBigUint64(32, data.FilterScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.FilterScaleTensor)), true);
  // 0x28: pointer
  if (data?.FilterZeroPointTensor !== undefined) view.setBigUint64(40, data.FilterZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.FilterZeroPointTensor)), true);
  // 0x30: pointer
  if (data?.BiasTensor !== undefined) view.setBigUint64(48, data.BiasTensor === null ? 0n : util.toBigInt(util.toPointer(data.BiasTensor)), true);
  // 0x38: pointer
  if (data?.OutputScaleTensor !== undefined) view.setBigUint64(56, data.OutputScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputScaleTensor)), true);
  // 0x40: pointer
  if (data?.OutputZeroPointTensor !== undefined) view.setBigUint64(64, data.OutputZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputZeroPointTensor)), true);
  // 0x48: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(72, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x50: u32
  if (data?.DimensionCount !== undefined) view.setUint32(80, Number(data.DimensionCount), true);
  // 0x54: pad4
  // 0x58: pointer
  if (data?.Strides !== undefined) view.setBigUint64(88, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x60: pointer
  if (data?.Dilations !== undefined) view.setBigUint64(96, data.Dilations === null ? 0n : util.toBigInt(util.toPointer(data.Dilations)), true);
  // 0x68: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(104, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x70: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(112, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x78: u32
  if (data?.GroupCount !== undefined) view.setUint32(120, Number(data.GroupCount), true);
  // 0x7c: pad4
  return buf;
}

export class DML_QUANTIZED_LINEAR_CONVOLUTION_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get InputZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get FilterTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get FilterScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get FilterZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get BiasTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get OutputScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get OutputZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x48: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(72, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x50: u32
  get DimensionCount(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(88, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x60: pointer
  get Dilations(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(96, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x68: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(104, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x70: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(112, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x78: u32
  get GroupCount(): number {
    return this.view.getUint32(120, true);
  }

  // 0x7c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set InputZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set FilterTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set FilterScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set FilterZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set BiasTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set OutputScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set OutputZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x48: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(72, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x50: u32
  set DimensionCount(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(88, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x60: pointer
  set Dilations(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(96, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x68: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(104, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x70: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(112, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x78: u32
  set GroupCount(value: number) {
    this.view.setUint32(120, value, true);
  }

  // 0x7c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_BIT_AND_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_BIT_AND_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_BIT_OR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_BIT_OR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_BIT_XOR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC (size: 16)
 */
export interface DML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC = 16;

export function allocDML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_BIT_NOT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC (size: 16)
 */
export interface DML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC = 16;

export function allocDML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_BIT_COUNT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OR_EQUAL_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OR_EQUAL_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_CELU_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_CELU_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Alpha: number;
}

export const sizeofDML_ACTIVATION_CELU_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_CELU_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_CELU_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_CELU_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: f32
  if (data?.Alpha !== undefined) view.setFloat32(16, Number(data.Alpha), true);
  // 0x14: pad4
  return buf;
}

export class DML_ACTIVATION_CELU_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: f32
  get Alpha(): number {
    return this.view.getFloat32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: f32
  set Alpha(value: number) {
    this.view.setFloat32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ACTIVATION_RELU_GRAD_OPERATOR_DESC (size: 24)
 */
export interface DML_ACTIVATION_RELU_GRAD_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ACTIVATION_RELU_GRAD_OPERATOR_DESC = 24;

export function allocDML_ACTIVATION_RELU_GRAD_OPERATOR_DESC(data?: Partial<DML_ACTIVATION_RELU_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ACTIVATION_RELU_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(8, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x10: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(16, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  return buf;
}

export class DML_ACTIVATION_RELU_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_AVERAGE_POOLING_GRAD_OPERATOR_DESC (size: 64)
 */
export interface DML_AVERAGE_POOLING_GRAD_OPERATOR_DESC {
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WindowSize: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Foundation.BOOL */
  IncludePadding: boolean;
}

export const sizeofDML_AVERAGE_POOLING_GRAD_OPERATOR_DESC = 64;

export function allocDML_AVERAGE_POOLING_GRAD_OPERATOR_DESC(data?: Partial<DML_AVERAGE_POOLING_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_AVERAGE_POOLING_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(0, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x08: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(8, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  // 0x10: u32
  if (data?.DimensionCount !== undefined) view.setUint32(16, Number(data.DimensionCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Strides !== undefined) view.setBigUint64(24, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x20: pointer
  if (data?.WindowSize !== undefined) view.setBigUint64(32, data.WindowSize === null ? 0n : util.toBigInt(util.toPointer(data.WindowSize)), true);
  // 0x28: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(40, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x30: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(48, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x38: i32
  if (data?.IncludePadding !== undefined) view.setInt32(56, Number(data.IncludePadding), true);
  // 0x3c: pad4
  return buf;
}

export class DML_AVERAGE_POOLING_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get DimensionCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get WindowSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: i32
  get IncludePadding(): number {
    return this.view.getInt32(56, true);
  }

  // 0x3c: pad4

  // 0x00: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set DimensionCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set WindowSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: i32
  set IncludePadding(value: number) {
    this.view.setInt32(56, value, true);
  }

  // 0x3c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_MAX_POOLING_GRAD_OPERATOR_DESC (size: 72)
 */
export interface DML_MAX_POOLING_GRAD_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Strides: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  WindowSize: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  StartPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  EndPadding: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  Dilations: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_MAX_POOLING_GRAD_OPERATOR_DESC = 72;

export function allocDML_MAX_POOLING_GRAD_OPERATOR_DESC(data?: Partial<DML_MAX_POOLING_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_MAX_POOLING_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(8, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x10: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(16, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  // 0x18: u32
  if (data?.DimensionCount !== undefined) view.setUint32(24, Number(data.DimensionCount), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Strides !== undefined) view.setBigUint64(32, data.Strides === null ? 0n : util.toBigInt(util.toPointer(data.Strides)), true);
  // 0x28: pointer
  if (data?.WindowSize !== undefined) view.setBigUint64(40, data.WindowSize === null ? 0n : util.toBigInt(util.toPointer(data.WindowSize)), true);
  // 0x30: pointer
  if (data?.StartPadding !== undefined) view.setBigUint64(48, data.StartPadding === null ? 0n : util.toBigInt(util.toPointer(data.StartPadding)), true);
  // 0x38: pointer
  if (data?.EndPadding !== undefined) view.setBigUint64(56, data.EndPadding === null ? 0n : util.toBigInt(util.toPointer(data.EndPadding)), true);
  // 0x40: pointer
  if (data?.Dilations !== undefined) view.setBigUint64(64, data.Dilations === null ? 0n : util.toBigInt(util.toPointer(data.Dilations)), true);
  return buf;
}

export class DML_MAX_POOLING_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get DimensionCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Strides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get WindowSize(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get StartPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get EndPadding(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get Dilations(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set DimensionCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Strides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set WindowSize(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set StartPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set EndPadding(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set Dilations(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_RANDOM_GENERATOR_OPERATOR_DESC (size: 32)
 */
export interface DML_RANDOM_GENERATOR_OPERATOR_DESC {
  /** ptr */
  InputStateTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputStateTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_RANDOM_GENERATOR_TYPE */
  Type: DML_RANDOM_GENERATOR_TYPE;
}

export const sizeofDML_RANDOM_GENERATOR_OPERATOR_DESC = 32;

export function allocDML_RANDOM_GENERATOR_OPERATOR_DESC(data?: Partial<DML_RANDOM_GENERATOR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_RANDOM_GENERATOR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputStateTensor !== undefined) view.setBigUint64(0, data.InputStateTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputStateTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.OutputStateTensor !== undefined) view.setBigUint64(16, data.OutputStateTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputStateTensor)), true);
  // 0x18: i32
  if (data?.Type !== undefined) view.setInt32(24, Number(data.Type), true);
  // 0x1c: pad4
  return buf;
}

export class DML_RANDOM_GENERATOR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputStateTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputStateTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: i32
  get Type(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputStateTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputStateTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: i32
  set Type(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_NONZERO_COORDINATES_OPERATOR_DESC (size: 24)
 */
export interface DML_NONZERO_COORDINATES_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputCountTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputCoordinatesTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_NONZERO_COORDINATES_OPERATOR_DESC = 24;

export function allocDML_NONZERO_COORDINATES_OPERATOR_DESC(data?: Partial<DML_NONZERO_COORDINATES_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_NONZERO_COORDINATES_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputCountTensor !== undefined) view.setBigUint64(8, data.OutputCountTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputCountTensor)), true);
  // 0x10: pointer
  if (data?.OutputCoordinatesTensor !== undefined) view.setBigUint64(16, data.OutputCoordinatesTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputCoordinatesTensor)), true);
  return buf;
}

export class DML_NONZERO_COORDINATES_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputCountTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputCoordinatesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputCountTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputCoordinatesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_RESAMPLE_GRAD_OPERATOR_DESC (size: 48)
 */
export interface DML_RESAMPLE_GRAD_OPERATOR_DESC {
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_INTERPOLATION_MODE */
  InterpolationMode: DML_INTERPOLATION_MODE;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  Scales: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputPixelOffsets: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputPixelOffsets: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_RESAMPLE_GRAD_OPERATOR_DESC = 48;

export function allocDML_RESAMPLE_GRAD_OPERATOR_DESC(data?: Partial<DML_RESAMPLE_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_RESAMPLE_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(0, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x08: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(8, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  // 0x10: i32
  if (data?.InterpolationMode !== undefined) view.setInt32(16, Number(data.InterpolationMode), true);
  // 0x14: u32
  if (data?.DimensionCount !== undefined) view.setUint32(20, Number(data.DimensionCount), true);
  // 0x18: pointer
  if (data?.Scales !== undefined) view.setBigUint64(24, data.Scales === null ? 0n : util.toBigInt(util.toPointer(data.Scales)), true);
  // 0x20: pointer
  if (data?.InputPixelOffsets !== undefined) view.setBigUint64(32, data.InputPixelOffsets === null ? 0n : util.toBigInt(util.toPointer(data.InputPixelOffsets)), true);
  // 0x28: pointer
  if (data?.OutputPixelOffsets !== undefined) view.setBigUint64(40, data.OutputPixelOffsets === null ? 0n : util.toBigInt(util.toPointer(data.OutputPixelOffsets)), true);
  return buf;
}

export class DML_RESAMPLE_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: i32
  get InterpolationMode(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: u32
  get DimensionCount(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get Scales(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get InputPixelOffsets(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get OutputPixelOffsets(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: i32
  set InterpolationMode(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: u32
  set DimensionCount(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set Scales(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set InputPixelOffsets(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set OutputPixelOffsets(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_SLICE_GRAD_OPERATOR_DESC (size: 48)
 */
export interface DML_SLICE_GRAD_OPERATOR_DESC {
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DimensionCount: number;
  /** ptr */
  InputWindowOffsets: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputWindowSizes: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputWindowStrides: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_SLICE_GRAD_OPERATOR_DESC = 48;

export function allocDML_SLICE_GRAD_OPERATOR_DESC(data?: Partial<DML_SLICE_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_SLICE_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(0, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x08: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(8, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  // 0x10: u32
  if (data?.DimensionCount !== undefined) view.setUint32(16, Number(data.DimensionCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.InputWindowOffsets !== undefined) view.setBigUint64(24, data.InputWindowOffsets === null ? 0n : util.toBigInt(util.toPointer(data.InputWindowOffsets)), true);
  // 0x20: pointer
  if (data?.InputWindowSizes !== undefined) view.setBigUint64(32, data.InputWindowSizes === null ? 0n : util.toBigInt(util.toPointer(data.InputWindowSizes)), true);
  // 0x28: pointer
  if (data?.InputWindowStrides !== undefined) view.setBigUint64(40, data.InputWindowStrides === null ? 0n : util.toBigInt(util.toPointer(data.InputWindowStrides)), true);
  return buf;
}

export class DML_SLICE_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get DimensionCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get InputWindowOffsets(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get InputWindowSizes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get InputWindowStrides(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set DimensionCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set InputWindowOffsets(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set InputWindowSizes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set InputWindowStrides(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ADAM_OPTIMIZER_OPERATOR_DESC (size: 80)
 */
export interface DML_ADAM_OPTIMIZER_OPERATOR_DESC {
  /** ptr */
  InputParametersTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputFirstMomentTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputSecondMomentTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  GradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  TrainingStepTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputParametersTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputFirstMomentTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputSecondMomentTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  LearningRate: number;
  /** f32 */
  Beta1: number;
  /** f32 */
  Beta2: number;
  /** f32 */
  Epsilon: number;
}

export const sizeofDML_ADAM_OPTIMIZER_OPERATOR_DESC = 80;

export function allocDML_ADAM_OPTIMIZER_OPERATOR_DESC(data?: Partial<DML_ADAM_OPTIMIZER_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ADAM_OPTIMIZER_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputParametersTensor !== undefined) view.setBigUint64(0, data.InputParametersTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputParametersTensor)), true);
  // 0x08: pointer
  if (data?.InputFirstMomentTensor !== undefined) view.setBigUint64(8, data.InputFirstMomentTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputFirstMomentTensor)), true);
  // 0x10: pointer
  if (data?.InputSecondMomentTensor !== undefined) view.setBigUint64(16, data.InputSecondMomentTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputSecondMomentTensor)), true);
  // 0x18: pointer
  if (data?.GradientTensor !== undefined) view.setBigUint64(24, data.GradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.GradientTensor)), true);
  // 0x20: pointer
  if (data?.TrainingStepTensor !== undefined) view.setBigUint64(32, data.TrainingStepTensor === null ? 0n : util.toBigInt(util.toPointer(data.TrainingStepTensor)), true);
  // 0x28: pointer
  if (data?.OutputParametersTensor !== undefined) view.setBigUint64(40, data.OutputParametersTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputParametersTensor)), true);
  // 0x30: pointer
  if (data?.OutputFirstMomentTensor !== undefined) view.setBigUint64(48, data.OutputFirstMomentTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputFirstMomentTensor)), true);
  // 0x38: pointer
  if (data?.OutputSecondMomentTensor !== undefined) view.setBigUint64(56, data.OutputSecondMomentTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputSecondMomentTensor)), true);
  // 0x40: f32
  if (data?.LearningRate !== undefined) view.setFloat32(64, Number(data.LearningRate), true);
  // 0x44: f32
  if (data?.Beta1 !== undefined) view.setFloat32(68, Number(data.Beta1), true);
  // 0x48: f32
  if (data?.Beta2 !== undefined) view.setFloat32(72, Number(data.Beta2), true);
  // 0x4c: f32
  if (data?.Epsilon !== undefined) view.setFloat32(76, Number(data.Epsilon), true);
  return buf;
}

export class DML_ADAM_OPTIMIZER_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputParametersTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputFirstMomentTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get InputSecondMomentTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get GradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get TrainingStepTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get OutputParametersTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get OutputFirstMomentTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get OutputSecondMomentTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: f32
  get LearningRate(): number {
    return this.view.getFloat32(64, true);
  }

  // 0x44: f32
  get Beta1(): number {
    return this.view.getFloat32(68, true);
  }

  // 0x48: f32
  get Beta2(): number {
    return this.view.getFloat32(72, true);
  }

  // 0x4c: f32
  get Epsilon(): number {
    return this.view.getFloat32(76, true);
  }

  // 0x00: pointer
  set InputParametersTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputFirstMomentTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set InputSecondMomentTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set GradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set TrainingStepTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set OutputParametersTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set OutputFirstMomentTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set OutputSecondMomentTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: f32
  set LearningRate(value: number) {
    this.view.setFloat32(64, value, true);
  }

  // 0x44: f32
  set Beta1(value: number) {
    this.view.setFloat32(68, value, true);
  }

  // 0x48: f32
  set Beta2(value: number) {
    this.view.setFloat32(72, value, true);
  }

  // 0x4c: f32
  set Epsilon(value: number) {
    this.view.setFloat32(76, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ARGMIN_OPERATOR_DESC (size: 40)
 */
export interface DML_ARGMIN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  AxisCount: number;
  /** ptr */
  Axes: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_AXIS_DIRECTION */
  AxisDirection: DML_AXIS_DIRECTION;
}

export const sizeofDML_ARGMIN_OPERATOR_DESC = 40;

export function allocDML_ARGMIN_OPERATOR_DESC(data?: Partial<DML_ARGMIN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ARGMIN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.AxisCount !== undefined) view.setUint32(16, Number(data.AxisCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Axes !== undefined) view.setBigUint64(24, data.Axes === null ? 0n : util.toBigInt(util.toPointer(data.Axes)), true);
  // 0x20: i32
  if (data?.AxisDirection !== undefined) view.setInt32(32, Number(data.AxisDirection), true);
  // 0x24: pad4
  return buf;
}

export class DML_ARGMIN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get AxisCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Axes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: i32
  get AxisDirection(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set AxisCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Axes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: i32
  set AxisDirection(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ARGMAX_OPERATOR_DESC (size: 40)
 */
export interface DML_ARGMAX_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  AxisCount: number;
  /** ptr */
  Axes: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_AXIS_DIRECTION */
  AxisDirection: DML_AXIS_DIRECTION;
}

export const sizeofDML_ARGMAX_OPERATOR_DESC = 40;

export function allocDML_ARGMAX_OPERATOR_DESC(data?: Partial<DML_ARGMAX_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ARGMAX_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.AxisCount !== undefined) view.setUint32(16, Number(data.AxisCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Axes !== undefined) view.setBigUint64(24, data.Axes === null ? 0n : util.toBigInt(util.toPointer(data.Axes)), true);
  // 0x20: i32
  if (data?.AxisDirection !== undefined) view.setInt32(32, Number(data.AxisDirection), true);
  // 0x24: pad4
  return buf;
}

export class DML_ARGMAX_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get AxisCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Axes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: i32
  get AxisDirection(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set AxisCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Axes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: i32
  set AxisDirection(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ROI_ALIGN_OPERATOR_DESC (size: 64)
 */
export interface DML_ROI_ALIGN_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ROITensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BatchIndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_REDUCE_FUNCTION */
  ReductionFunction: DML_REDUCE_FUNCTION;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_INTERPOLATION_MODE */
  InterpolationMode: DML_INTERPOLATION_MODE;
  /** f32 */
  SpatialScaleX: number;
  /** f32 */
  SpatialScaleY: number;
  /** f32 */
  OutOfBoundsInputValue: number;
  /** u32 */
  MinimumSamplesPerOutput: number;
  /** u32 */
  MaximumSamplesPerOutput: number;
}

export const sizeofDML_ROI_ALIGN_OPERATOR_DESC = 64;

export function allocDML_ROI_ALIGN_OPERATOR_DESC(data?: Partial<DML_ROI_ALIGN_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ROI_ALIGN_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ROITensor !== undefined) view.setBigUint64(8, data.ROITensor === null ? 0n : util.toBigInt(util.toPointer(data.ROITensor)), true);
  // 0x10: pointer
  if (data?.BatchIndicesTensor !== undefined) view.setBigUint64(16, data.BatchIndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.BatchIndicesTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: i32
  if (data?.ReductionFunction !== undefined) view.setInt32(32, Number(data.ReductionFunction), true);
  // 0x24: i32
  if (data?.InterpolationMode !== undefined) view.setInt32(36, Number(data.InterpolationMode), true);
  // 0x28: f32
  if (data?.SpatialScaleX !== undefined) view.setFloat32(40, Number(data.SpatialScaleX), true);
  // 0x2c: f32
  if (data?.SpatialScaleY !== undefined) view.setFloat32(44, Number(data.SpatialScaleY), true);
  // 0x30: f32
  if (data?.OutOfBoundsInputValue !== undefined) view.setFloat32(48, Number(data.OutOfBoundsInputValue), true);
  // 0x34: u32
  if (data?.MinimumSamplesPerOutput !== undefined) view.setUint32(52, Number(data.MinimumSamplesPerOutput), true);
  // 0x38: u32
  if (data?.MaximumSamplesPerOutput !== undefined) view.setUint32(56, Number(data.MaximumSamplesPerOutput), true);
  // 0x3c: pad4
  return buf;
}

export class DML_ROI_ALIGN_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ROITensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get BatchIndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: i32
  get ReductionFunction(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: i32
  get InterpolationMode(): number {
    return this.view.getInt32(36, true);
  }

  // 0x28: f32
  get SpatialScaleX(): number {
    return this.view.getFloat32(40, true);
  }

  // 0x2c: f32
  get SpatialScaleY(): number {
    return this.view.getFloat32(44, true);
  }

  // 0x30: f32
  get OutOfBoundsInputValue(): number {
    return this.view.getFloat32(48, true);
  }

  // 0x34: u32
  get MinimumSamplesPerOutput(): number {
    return this.view.getUint32(52, true);
  }

  // 0x38: u32
  get MaximumSamplesPerOutput(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ROITensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set BatchIndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: i32
  set ReductionFunction(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: i32
  set InterpolationMode(value: number) {
    this.view.setInt32(36, value, true);
  }

  // 0x28: f32
  set SpatialScaleX(value: number) {
    this.view.setFloat32(40, value, true);
  }

  // 0x2c: f32
  set SpatialScaleY(value: number) {
    this.view.setFloat32(44, value, true);
  }

  // 0x30: f32
  set OutOfBoundsInputValue(value: number) {
    this.view.setFloat32(48, value, true);
  }

  // 0x34: u32
  set MinimumSamplesPerOutput(value: number) {
    this.view.setUint32(52, value, true);
  }

  // 0x38: u32
  set MaximumSamplesPerOutput(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GATHER_ND1_OPERATOR_DESC (size: 40)
 */
export interface DML_GATHER_ND1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  IndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  InputDimensionCount: number;
  /** u32 */
  IndicesDimensionCount: number;
  /** u32 */
  BatchDimensionCount: number;
}

export const sizeofDML_GATHER_ND1_OPERATOR_DESC = 40;

export function allocDML_GATHER_ND1_OPERATOR_DESC(data?: Partial<DML_GATHER_ND1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GATHER_ND1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.IndicesTensor !== undefined) view.setBigUint64(8, data.IndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.IndicesTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x18: u32
  if (data?.InputDimensionCount !== undefined) view.setUint32(24, Number(data.InputDimensionCount), true);
  // 0x1c: u32
  if (data?.IndicesDimensionCount !== undefined) view.setUint32(28, Number(data.IndicesDimensionCount), true);
  // 0x20: u32
  if (data?.BatchDimensionCount !== undefined) view.setUint32(32, Number(data.BatchDimensionCount), true);
  // 0x24: pad4
  return buf;
}

export class DML_GATHER_ND1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get IndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get InputDimensionCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get IndicesDimensionCount(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: u32
  get BatchDimensionCount(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set IndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set InputDimensionCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set IndicesDimensionCount(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: u32
  set BatchDimensionCount(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_ATAN_YX_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC (size: 32)
 */
export interface DML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Min: number;
  /** f32 */
  Max: number;
}

export const sizeofDML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC = 32;

export function allocDML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(8, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x10: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(16, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  // 0x18: f32
  if (data?.Min !== undefined) view.setFloat32(24, Number(data.Min), true);
  // 0x1c: f32
  if (data?.Max !== undefined) view.setFloat32(28, Number(data.Max), true);
  return buf;
}

export class DML_ELEMENT_WISE_CLIP_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: f32
  get Min(): number {
    return this.view.getFloat32(24, true);
  }

  // 0x1c: f32
  get Max(): number {
    return this.view.getFloat32(28, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: f32
  set Min(value: number) {
    this.view.setFloat32(24, value, true);
  }

  // 0x1c: f32
  set Max(value: number) {
    this.view.setFloat32(28, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC (size: 24)
 */
export interface DML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC = 24;

export function allocDML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(8, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x10: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(16, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_DIFFERENCE_SQUARE_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC (size: 48)
 */
export interface DML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Foundation.BOOL */
  CrossChannel: boolean;
  /** u32 */
  LocalSize: number;
  /** f32 */
  Alpha: number;
  /** f32 */
  Beta: number;
  /** f32 */
  Bias: number;
}

export const sizeofDML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC = 48;

export function allocDML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC(data?: Partial<DML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(8, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x10: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(16, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  // 0x18: i32
  if (data?.CrossChannel !== undefined) view.setInt32(24, Number(data.CrossChannel), true);
  // 0x1c: u32
  if (data?.LocalSize !== undefined) view.setUint32(28, Number(data.LocalSize), true);
  // 0x20: f32
  if (data?.Alpha !== undefined) view.setFloat32(32, Number(data.Alpha), true);
  // 0x24: f32
  if (data?.Beta !== undefined) view.setFloat32(36, Number(data.Beta), true);
  // 0x28: f32
  if (data?.Bias !== undefined) view.setFloat32(40, Number(data.Bias), true);
  // 0x2c: pad4
  return buf;
}

export class DML_LOCAL_RESPONSE_NORMALIZATION_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: i32
  get CrossChannel(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: u32
  get LocalSize(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: f32
  get Alpha(): number {
    return this.view.getFloat32(32, true);
  }

  // 0x24: f32
  get Beta(): number {
    return this.view.getFloat32(36, true);
  }

  // 0x28: f32
  get Bias(): number {
    return this.view.getFloat32(40, true);
  }

  // 0x2c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: i32
  set CrossChannel(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: u32
  set LocalSize(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: f32
  set Alpha(value: number) {
    this.view.setFloat32(32, value, true);
  }

  // 0x24: f32
  set Beta(value: number) {
    this.view.setFloat32(36, value, true);
  }

  // 0x28: f32
  set Bias(value: number) {
    this.view.setFloat32(40, value, true);
  }

  // 0x2c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_CUMULATIVE_PRODUCT_OPERATOR_DESC (size: 32)
 */
export interface DML_CUMULATIVE_PRODUCT_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  Axis: number;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_AXIS_DIRECTION */
  AxisDirection: DML_AXIS_DIRECTION;
  /** Windows.Win32.Foundation.BOOL */
  HasExclusiveProduct: boolean;
}

export const sizeofDML_CUMULATIVE_PRODUCT_OPERATOR_DESC = 32;

export function allocDML_CUMULATIVE_PRODUCT_OPERATOR_DESC(data?: Partial<DML_CUMULATIVE_PRODUCT_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_CUMULATIVE_PRODUCT_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: u32
  if (data?.Axis !== undefined) view.setUint32(16, Number(data.Axis), true);
  // 0x14: i32
  if (data?.AxisDirection !== undefined) view.setInt32(20, Number(data.AxisDirection), true);
  // 0x18: i32
  if (data?.HasExclusiveProduct !== undefined) view.setInt32(24, Number(data.HasExclusiveProduct), true);
  // 0x1c: pad4
  return buf;
}

export class DML_CUMULATIVE_PRODUCT_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: u32
  get Axis(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: i32
  get AxisDirection(): number {
    return this.view.getInt32(20, true);
  }

  // 0x18: i32
  get HasExclusiveProduct(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: u32
  set Axis(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: i32
  set AxisDirection(value: number) {
    this.view.setInt32(20, value, true);
  }

  // 0x18: i32
  set HasExclusiveProduct(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC (size: 72)
 */
export interface DML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  InputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  MeanTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  VarianceTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputScaleGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputBiasGradientTensor: Deno.PointerValue | Uint8Array | null;
  /** f32 */
  Epsilon: number;
}

export const sizeofDML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC = 72;

export function allocDML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC(data?: Partial<DML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.InputGradientTensor !== undefined) view.setBigUint64(8, data.InputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputGradientTensor)), true);
  // 0x10: pointer
  if (data?.MeanTensor !== undefined) view.setBigUint64(16, data.MeanTensor === null ? 0n : util.toBigInt(util.toPointer(data.MeanTensor)), true);
  // 0x18: pointer
  if (data?.VarianceTensor !== undefined) view.setBigUint64(24, data.VarianceTensor === null ? 0n : util.toBigInt(util.toPointer(data.VarianceTensor)), true);
  // 0x20: pointer
  if (data?.ScaleTensor !== undefined) view.setBigUint64(32, data.ScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.ScaleTensor)), true);
  // 0x28: pointer
  if (data?.OutputGradientTensor !== undefined) view.setBigUint64(40, data.OutputGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputGradientTensor)), true);
  // 0x30: pointer
  if (data?.OutputScaleGradientTensor !== undefined) view.setBigUint64(48, data.OutputScaleGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputScaleGradientTensor)), true);
  // 0x38: pointer
  if (data?.OutputBiasGradientTensor !== undefined) view.setBigUint64(56, data.OutputBiasGradientTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputBiasGradientTensor)), true);
  // 0x40: f32
  if (data?.Epsilon !== undefined) view.setFloat32(64, Number(data.Epsilon), true);
  // 0x44: pad4
  return buf;
}

export class DML_BATCH_NORMALIZATION_GRAD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get InputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get MeanTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get VarianceTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get ScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get OutputGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get OutputScaleGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get OutputBiasGradientTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: f32
  get Epsilon(): number {
    return this.view.getFloat32(64, true);
  }

  // 0x44: pad4

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set InputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set MeanTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set VarianceTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set ScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set OutputGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set OutputScaleGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set OutputBiasGradientTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: f32
  set Epsilon(value: number) {
    this.view.setFloat32(64, value, true);
  }

  // 0x44: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC (size: 72)
 */
export interface DML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC {
  /** ptr */
  ATensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  AScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  AZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputZeroPointTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC = 72;

export function allocDML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC(data?: Partial<DML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ATensor !== undefined) view.setBigUint64(0, data.ATensor === null ? 0n : util.toBigInt(util.toPointer(data.ATensor)), true);
  // 0x08: pointer
  if (data?.AScaleTensor !== undefined) view.setBigUint64(8, data.AScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.AScaleTensor)), true);
  // 0x10: pointer
  if (data?.AZeroPointTensor !== undefined) view.setBigUint64(16, data.AZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.AZeroPointTensor)), true);
  // 0x18: pointer
  if (data?.BTensor !== undefined) view.setBigUint64(24, data.BTensor === null ? 0n : util.toBigInt(util.toPointer(data.BTensor)), true);
  // 0x20: pointer
  if (data?.BScaleTensor !== undefined) view.setBigUint64(32, data.BScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.BScaleTensor)), true);
  // 0x28: pointer
  if (data?.BZeroPointTensor !== undefined) view.setBigUint64(40, data.BZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.BZeroPointTensor)), true);
  // 0x30: pointer
  if (data?.OutputScaleTensor !== undefined) view.setBigUint64(48, data.OutputScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputScaleTensor)), true);
  // 0x38: pointer
  if (data?.OutputZeroPointTensor !== undefined) view.setBigUint64(56, data.OutputZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputZeroPointTensor)), true);
  // 0x40: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(64, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  return buf;
}

export class DML_ELEMENT_WISE_QUANTIZED_LINEAR_ADD_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ATensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get AScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get AZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get BTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: pointer
  get BScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: pointer
  get BZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(40, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x30: pointer
  get OutputScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: pointer
  get OutputZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(56, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x40: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set ATensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set AScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set AZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set BTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: pointer
  set BScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: pointer
  set BZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(40, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x30: pointer
  set OutputScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: pointer
  set OutputZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(56, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x40: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC (size: 32)
 */
export interface DML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputScaleTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputZeroPointTensor: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC = 32;

export function allocDML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC(data?: Partial<DML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(8, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x10: pointer
  if (data?.OutputScaleTensor !== undefined) view.setBigUint64(16, data.OutputScaleTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputScaleTensor)), true);
  // 0x18: pointer
  if (data?.OutputZeroPointTensor !== undefined) view.setBigUint64(24, data.OutputZeroPointTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputZeroPointTensor)), true);
  return buf;
}

export class DML_DYNAMIC_QUANTIZE_LINEAR_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get OutputScaleTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputZeroPointTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set OutputScaleTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputZeroPointTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_ROI_ALIGN1_OPERATOR_DESC (size: 72)
 */
export interface DML_ROI_ALIGN1_OPERATOR_DESC {
  /** ptr */
  InputTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  ROITensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  BatchIndicesTensor: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  OutputTensor: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_REDUCE_FUNCTION */
  ReductionFunction: DML_REDUCE_FUNCTION;
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_INTERPOLATION_MODE */
  InterpolationMode: DML_INTERPOLATION_MODE;
  /** f32 */
  SpatialScaleX: number;
  /** f32 */
  SpatialScaleY: number;
  /** f32 */
  InputPixelOffset: number;
  /** f32 */
  OutputPixelOffset: number;
  /** f32 */
  OutOfBoundsInputValue: number;
  /** u32 */
  MinimumSamplesPerOutput: number;
  /** u32 */
  MaximumSamplesPerOutput: number;
  /** Windows.Win32.Foundation.BOOL */
  AlignRegionsToCorners: boolean;
}

export const sizeofDML_ROI_ALIGN1_OPERATOR_DESC = 72;

export function allocDML_ROI_ALIGN1_OPERATOR_DESC(data?: Partial<DML_ROI_ALIGN1_OPERATOR_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_ROI_ALIGN1_OPERATOR_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.InputTensor !== undefined) view.setBigUint64(0, data.InputTensor === null ? 0n : util.toBigInt(util.toPointer(data.InputTensor)), true);
  // 0x08: pointer
  if (data?.ROITensor !== undefined) view.setBigUint64(8, data.ROITensor === null ? 0n : util.toBigInt(util.toPointer(data.ROITensor)), true);
  // 0x10: pointer
  if (data?.BatchIndicesTensor !== undefined) view.setBigUint64(16, data.BatchIndicesTensor === null ? 0n : util.toBigInt(util.toPointer(data.BatchIndicesTensor)), true);
  // 0x18: pointer
  if (data?.OutputTensor !== undefined) view.setBigUint64(24, data.OutputTensor === null ? 0n : util.toBigInt(util.toPointer(data.OutputTensor)), true);
  // 0x20: i32
  if (data?.ReductionFunction !== undefined) view.setInt32(32, Number(data.ReductionFunction), true);
  // 0x24: i32
  if (data?.InterpolationMode !== undefined) view.setInt32(36, Number(data.InterpolationMode), true);
  // 0x28: f32
  if (data?.SpatialScaleX !== undefined) view.setFloat32(40, Number(data.SpatialScaleX), true);
  // 0x2c: f32
  if (data?.SpatialScaleY !== undefined) view.setFloat32(44, Number(data.SpatialScaleY), true);
  // 0x30: f32
  if (data?.InputPixelOffset !== undefined) view.setFloat32(48, Number(data.InputPixelOffset), true);
  // 0x34: f32
  if (data?.OutputPixelOffset !== undefined) view.setFloat32(52, Number(data.OutputPixelOffset), true);
  // 0x38: f32
  if (data?.OutOfBoundsInputValue !== undefined) view.setFloat32(56, Number(data.OutOfBoundsInputValue), true);
  // 0x3c: u32
  if (data?.MinimumSamplesPerOutput !== undefined) view.setUint32(60, Number(data.MinimumSamplesPerOutput), true);
  // 0x40: u32
  if (data?.MaximumSamplesPerOutput !== undefined) view.setUint32(64, Number(data.MaximumSamplesPerOutput), true);
  // 0x44: i32
  if (data?.AlignRegionsToCorners !== undefined) view.setInt32(68, Number(data.AlignRegionsToCorners), true);
  return buf;
}

export class DML_ROI_ALIGN1_OPERATOR_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get InputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get ROITensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get BatchIndicesTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: pointer
  get OutputTensor(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(24, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x20: i32
  get ReductionFunction(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: i32
  get InterpolationMode(): number {
    return this.view.getInt32(36, true);
  }

  // 0x28: f32
  get SpatialScaleX(): number {
    return this.view.getFloat32(40, true);
  }

  // 0x2c: f32
  get SpatialScaleY(): number {
    return this.view.getFloat32(44, true);
  }

  // 0x30: f32
  get InputPixelOffset(): number {
    return this.view.getFloat32(48, true);
  }

  // 0x34: f32
  get OutputPixelOffset(): number {
    return this.view.getFloat32(52, true);
  }

  // 0x38: f32
  get OutOfBoundsInputValue(): number {
    return this.view.getFloat32(56, true);
  }

  // 0x3c: u32
  get MinimumSamplesPerOutput(): number {
    return this.view.getUint32(60, true);
  }

  // 0x40: u32
  get MaximumSamplesPerOutput(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: i32
  get AlignRegionsToCorners(): number {
    return this.view.getInt32(68, true);
  }

  // 0x00: pointer
  set InputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set ROITensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set BatchIndicesTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: pointer
  set OutputTensor(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(24, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x20: i32
  set ReductionFunction(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: i32
  set InterpolationMode(value: number) {
    this.view.setInt32(36, value, true);
  }

  // 0x28: f32
  set SpatialScaleX(value: number) {
    this.view.setFloat32(40, value, true);
  }

  // 0x2c: f32
  set SpatialScaleY(value: number) {
    this.view.setFloat32(44, value, true);
  }

  // 0x30: f32
  set InputPixelOffset(value: number) {
    this.view.setFloat32(48, value, true);
  }

  // 0x34: f32
  set OutputPixelOffset(value: number) {
    this.view.setFloat32(52, value, true);
  }

  // 0x38: f32
  set OutOfBoundsInputValue(value: number) {
    this.view.setFloat32(56, value, true);
  }

  // 0x3c: u32
  set MinimumSamplesPerOutput(value: number) {
    this.view.setUint32(60, value, true);
  }

  // 0x40: u32
  set MaximumSamplesPerOutput(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: i32
  set AlignRegionsToCorners(value: number) {
    this.view.setInt32(68, value, true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_FEATURE_QUERY_TENSOR_DATA_TYPE_SUPPORT (size: 8)
 */
export interface DML_FEATURE_QUERY_TENSOR_DATA_TYPE_SUPPORT {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_TENSOR_DATA_TYPE */
  DataType: DML_TENSOR_DATA_TYPE;
}

export const sizeofDML_FEATURE_QUERY_TENSOR_DATA_TYPE_SUPPORT = 8;

export function allocDML_FEATURE_QUERY_TENSOR_DATA_TYPE_SUPPORT(data?: Partial<DML_FEATURE_QUERY_TENSOR_DATA_TYPE_SUPPORT>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_FEATURE_QUERY_TENSOR_DATA_TYPE_SUPPORT);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.DataType !== undefined) view.setInt32(0, Number(data.DataType), true);
  // 0x04: pad4
  return buf;
}

export class DML_FEATURE_QUERY_TENSOR_DATA_TYPE_SUPPORTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get DataType(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x00: i32
  set DataType(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_FEATURE_DATA_TENSOR_DATA_TYPE_SUPPORT (size: 8)
 */
export interface DML_FEATURE_DATA_TENSOR_DATA_TYPE_SUPPORT {
  /** Windows.Win32.Foundation.BOOL */
  IsSupported: boolean;
}

export const sizeofDML_FEATURE_DATA_TENSOR_DATA_TYPE_SUPPORT = 8;

export function allocDML_FEATURE_DATA_TENSOR_DATA_TYPE_SUPPORT(data?: Partial<DML_FEATURE_DATA_TENSOR_DATA_TYPE_SUPPORT>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_FEATURE_DATA_TENSOR_DATA_TYPE_SUPPORT);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.IsSupported !== undefined) view.setInt32(0, Number(data.IsSupported), true);
  // 0x04: pad4
  return buf;
}

export class DML_FEATURE_DATA_TENSOR_DATA_TYPE_SUPPORTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get IsSupported(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x00: i32
  set IsSupported(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_FEATURE_QUERY_FEATURE_LEVELS (size: 16)
 */
export interface DML_FEATURE_QUERY_FEATURE_LEVELS {
  /** u32 */
  RequestedFeatureLevelCount: number;
  /** ptr */
  RequestedFeatureLevels: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_FEATURE_QUERY_FEATURE_LEVELS = 16;

export function allocDML_FEATURE_QUERY_FEATURE_LEVELS(data?: Partial<DML_FEATURE_QUERY_FEATURE_LEVELS>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_FEATURE_QUERY_FEATURE_LEVELS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.RequestedFeatureLevelCount !== undefined) view.setUint32(0, Number(data.RequestedFeatureLevelCount), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.RequestedFeatureLevels !== undefined) view.setBigUint64(8, data.RequestedFeatureLevels === null ? 0n : util.toBigInt(util.toPointer(data.RequestedFeatureLevels)), true);
  return buf;
}

export class DML_FEATURE_QUERY_FEATURE_LEVELSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get RequestedFeatureLevelCount(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get RequestedFeatureLevels(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: u32
  set RequestedFeatureLevelCount(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set RequestedFeatureLevels(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_FEATURE_DATA_FEATURE_LEVELS (size: 8)
 */
export interface DML_FEATURE_DATA_FEATURE_LEVELS {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_FEATURE_LEVEL */
  MaxSupportedFeatureLevel: DML_FEATURE_LEVEL;
}

export const sizeofDML_FEATURE_DATA_FEATURE_LEVELS = 8;

export function allocDML_FEATURE_DATA_FEATURE_LEVELS(data?: Partial<DML_FEATURE_DATA_FEATURE_LEVELS>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_FEATURE_DATA_FEATURE_LEVELS);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.MaxSupportedFeatureLevel !== undefined) view.setInt32(0, Number(data.MaxSupportedFeatureLevel), true);
  // 0x04: pad4
  return buf;
}

export class DML_FEATURE_DATA_FEATURE_LEVELSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get MaxSupportedFeatureLevel(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x00: i32
  set MaxSupportedFeatureLevel(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4
}

/**
 * Windows.Win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE (size: 8)
 */
export interface D3D12_CPU_DESCRIPTOR_HANDLE {
  /** usize */
  ptr: number | bigint;
}

export const sizeofD3D12_CPU_DESCRIPTOR_HANDLE = 8;

export function allocD3D12_CPU_DESCRIPTOR_HANDLE(data?: Partial<D3D12_CPU_DESCRIPTOR_HANDLE>): Uint8Array {
  const buf = new Uint8Array(sizeofD3D12_CPU_DESCRIPTOR_HANDLE);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.ptr !== undefined) view.setBigUint64(0, util.toBigInt(data.ptr), true);
  return buf;
}

export class D3D12_CPU_DESCRIPTOR_HANDLEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: usize
  get ptr(): number | bigint {
    return this.view.getBigUint64(0, true);
  }

  // 0x00: usize
  set ptr(value: number | bigint) {
    this.view.setBigUint64(0, util.toBigInt(value), true);
  }
}

/**
 * Windows.Win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE (size: 8)
 */
export interface D3D12_GPU_DESCRIPTOR_HANDLE {
  /** u64 */
  ptr: number | bigint;
}

export const sizeofD3D12_GPU_DESCRIPTOR_HANDLE = 8;

export function allocD3D12_GPU_DESCRIPTOR_HANDLE(data?: Partial<D3D12_GPU_DESCRIPTOR_HANDLE>): Uint8Array {
  const buf = new Uint8Array(sizeofD3D12_GPU_DESCRIPTOR_HANDLE);
  const view = new DataView(buf.buffer);
  // 0x00: u64
  if (data?.ptr !== undefined) view.setBigUint64(0, util.toBigInt(data.ptr), true);
  return buf;
}

export class D3D12_GPU_DESCRIPTOR_HANDLEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u64
  get ptr(): number | bigint {
    return this.view.getBigUint64(0, true);
  }

  // 0x00: u64
  set ptr(value: number | bigint) {
    this.view.setBigUint64(0, util.toBigInt(value), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BINDING_TABLE_DESC (size: 32)
 */
export interface DML_BINDING_TABLE_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.IDMLDispatchable */
  Dispatchable: Uint8Array | Deno.PointerValue | null;
  /** Windows.Win32.Graphics.Direct3D12.D3D12_CPU_DESCRIPTOR_HANDLE */
  CPUDescriptorHandle: Uint8Array | Deno.PointerValue | null;
  /** Windows.Win32.Graphics.Direct3D12.D3D12_GPU_DESCRIPTOR_HANDLE */
  GPUDescriptorHandle: Uint8Array | Deno.PointerValue | null;
  /** u32 */
  SizeInDescriptors: number;
}

export const sizeofDML_BINDING_TABLE_DESC = 32;

export function allocDML_BINDING_TABLE_DESC(data?: Partial<DML_BINDING_TABLE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BINDING_TABLE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Dispatchable !== undefined) view.setBigUint64(0, data.Dispatchable === null ? 0n : util.toBigInt(util.toPointer(data.Dispatchable)), true);
  // 0x08: pointer
  if (data?.CPUDescriptorHandle !== undefined) view.setBigUint64(8, data.CPUDescriptorHandle === null ? 0n : util.toBigInt(util.toPointer(data.CPUDescriptorHandle)), true);
  // 0x10: pointer
  if (data?.GPUDescriptorHandle !== undefined) view.setBigUint64(16, data.GPUDescriptorHandle === null ? 0n : util.toBigInt(util.toPointer(data.GPUDescriptorHandle)), true);
  // 0x18: u32
  if (data?.SizeInDescriptors !== undefined) view.setUint32(24, Number(data.SizeInDescriptors), true);
  // 0x1c: pad4
  return buf;
}

export class DML_BINDING_TABLE_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Dispatchable(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: pointer
  get CPUDescriptorHandle(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x10: pointer
  get GPUDescriptorHandle(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get SizeInDescriptors(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set Dispatchable(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: pointer
  set CPUDescriptorHandle(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x10: pointer
  set GPUDescriptorHandle(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set SizeInDescriptors(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BINDING_PROPERTIES (size: 24)
 */
export interface DML_BINDING_PROPERTIES {
  /** u32 */
  RequiredDescriptorCount: number;
  /** u64 */
  TemporaryResourceSize: number | bigint;
  /** u64 */
  PersistentResourceSize: number | bigint;
}

export const sizeofDML_BINDING_PROPERTIES = 24;

export function allocDML_BINDING_PROPERTIES(data?: Partial<DML_BINDING_PROPERTIES>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BINDING_PROPERTIES);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.RequiredDescriptorCount !== undefined) view.setUint32(0, Number(data.RequiredDescriptorCount), true);
  // 0x04: pad4
  // 0x08: u64
  if (data?.TemporaryResourceSize !== undefined) view.setBigUint64(8, util.toBigInt(data.TemporaryResourceSize), true);
  // 0x10: u64
  if (data?.PersistentResourceSize !== undefined) view.setBigUint64(16, util.toBigInt(data.PersistentResourceSize), true);
  return buf;
}

export class DML_BINDING_PROPERTIESView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get RequiredDescriptorCount(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: u64
  get TemporaryResourceSize(): number | bigint {
    return this.view.getBigUint64(8, true);
  }

  // 0x10: u64
  get PersistentResourceSize(): number | bigint {
    return this.view.getBigUint64(16, true);
  }

  // 0x00: u32
  set RequiredDescriptorCount(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: u64
  set TemporaryResourceSize(value: number | bigint) {
    this.view.setBigUint64(8, util.toBigInt(value), true);
  }

  // 0x10: u64
  set PersistentResourceSize(value: number | bigint) {
    this.view.setBigUint64(16, util.toBigInt(value), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BINDING_DESC (size: 16)
 */
export interface DML_BINDING_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_BINDING_TYPE */
  Type: DML_BINDING_TYPE;
  /** ptr */
  Desc: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_BINDING_DESC = 16;

export function allocDML_BINDING_DESC(data?: Partial<DML_BINDING_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BINDING_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.Type !== undefined) view.setInt32(0, Number(data.Type), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Desc !== undefined) view.setBigUint64(8, data.Desc === null ? 0n : util.toBigInt(util.toPointer(data.Desc)), true);
  return buf;
}

export class DML_BINDING_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get Type(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Desc(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: i32
  set Type(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Desc(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BUFFER_BINDING (size: 24)
 */
export interface DML_BUFFER_BINDING {
  /** Windows.Win32.Graphics.Direct3D12.ID3D12Resource */
  Buffer: Uint8Array | Deno.PointerValue | null;
  /** u64 */
  Offset: number | bigint;
  /** u64 */
  SizeInBytes: number | bigint;
}

export const sizeofDML_BUFFER_BINDING = 24;

export function allocDML_BUFFER_BINDING(data?: Partial<DML_BUFFER_BINDING>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BUFFER_BINDING);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Buffer !== undefined) view.setBigUint64(0, data.Buffer === null ? 0n : util.toBigInt(util.toPointer(data.Buffer)), true);
  // 0x08: u64
  if (data?.Offset !== undefined) view.setBigUint64(8, util.toBigInt(data.Offset), true);
  // 0x10: u64
  if (data?.SizeInBytes !== undefined) view.setBigUint64(16, util.toBigInt(data.SizeInBytes), true);
  return buf;
}

export class DML_BUFFER_BINDINGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Buffer(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: u64
  get Offset(): number | bigint {
    return this.view.getBigUint64(8, true);
  }

  // 0x10: u64
  get SizeInBytes(): number | bigint {
    return this.view.getBigUint64(16, true);
  }

  // 0x00: pointer
  set Buffer(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: u64
  set Offset(value: number | bigint) {
    this.view.setBigUint64(8, util.toBigInt(value), true);
  }

  // 0x10: u64
  set SizeInBytes(value: number | bigint) {
    this.view.setBigUint64(16, util.toBigInt(value), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_BUFFER_ARRAY_BINDING (size: 16)
 */
export interface DML_BUFFER_ARRAY_BINDING {
  /** u32 */
  BindingCount: number;
  /** ptr */
  Bindings: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_BUFFER_ARRAY_BINDING = 16;

export function allocDML_BUFFER_ARRAY_BINDING(data?: Partial<DML_BUFFER_ARRAY_BINDING>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_BUFFER_ARRAY_BINDING);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.BindingCount !== undefined) view.setUint32(0, Number(data.BindingCount), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Bindings !== undefined) view.setBigUint64(8, data.Bindings === null ? 0n : util.toBigInt(util.toPointer(data.Bindings)), true);
  return buf;
}

export class DML_BUFFER_ARRAY_BINDINGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get BindingCount(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Bindings(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: u32
  set BindingCount(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Bindings(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GRAPH_EDGE_DESC (size: 16)
 */
export interface DML_GRAPH_EDGE_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_GRAPH_EDGE_TYPE */
  Type: DML_GRAPH_EDGE_TYPE;
  /** ptr */
  Desc: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_GRAPH_EDGE_DESC = 16;

export function allocDML_GRAPH_EDGE_DESC(data?: Partial<DML_GRAPH_EDGE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GRAPH_EDGE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.Type !== undefined) view.setInt32(0, Number(data.Type), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Desc !== undefined) view.setBigUint64(8, data.Desc === null ? 0n : util.toBigInt(util.toPointer(data.Desc)), true);
  return buf;
}

export class DML_GRAPH_EDGE_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get Type(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Desc(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: i32
  set Type(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Desc(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

export type PSTR = Deno.PointerValue | Uint8Array | null;

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_INPUT_GRAPH_EDGE_DESC (size: 24)
 */
export interface DML_INPUT_GRAPH_EDGE_DESC {
  /** u32 */
  GraphInputIndex: number;
  /** u32 */
  ToNodeIndex: number;
  /** u32 */
  ToNodeInputIndex: number;
  /** Windows.Win32.Foundation.PSTR */
  Name: string | null | Uint8Array;
}

export const sizeofDML_INPUT_GRAPH_EDGE_DESC = 24;

export function allocDML_INPUT_GRAPH_EDGE_DESC(data?: Partial<DML_INPUT_GRAPH_EDGE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_INPUT_GRAPH_EDGE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.GraphInputIndex !== undefined) view.setUint32(0, Number(data.GraphInputIndex), true);
  // 0x04: u32
  if (data?.ToNodeIndex !== undefined) view.setUint32(4, Number(data.ToNodeIndex), true);
  // 0x08: u32
  if (data?.ToNodeInputIndex !== undefined) view.setUint32(8, Number(data.ToNodeInputIndex), true);
  // 0x0c: pad4
  // 0x10: buffer
  if (data?.Name !== undefined) {
    (buf as any)._f16 = util.pstrToFfi(data.Name);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : util.toBigInt(Deno.UnsafePointer.of((buf as any)._f16)), true);
  }
  return buf;
}

export class DML_INPUT_GRAPH_EDGE_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get GraphInputIndex(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get ToNodeIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get ToNodeInputIndex(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: buffer
  get Name(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: u32
  set GraphInputIndex(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set ToNodeIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set ToNodeInputIndex(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: buffer
  set Name(value: Uint8Array | Deno.PointerValue | null) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, util.toBigInt(util.toPointer((this.buf as any)._f16)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_OUTPUT_GRAPH_EDGE_DESC (size: 24)
 */
export interface DML_OUTPUT_GRAPH_EDGE_DESC {
  /** u32 */
  FromNodeIndex: number;
  /** u32 */
  FromNodeOutputIndex: number;
  /** u32 */
  GraphOutputIndex: number;
  /** Windows.Win32.Foundation.PSTR */
  Name: string | null | Uint8Array;
}

export const sizeofDML_OUTPUT_GRAPH_EDGE_DESC = 24;

export function allocDML_OUTPUT_GRAPH_EDGE_DESC(data?: Partial<DML_OUTPUT_GRAPH_EDGE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_OUTPUT_GRAPH_EDGE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.FromNodeIndex !== undefined) view.setUint32(0, Number(data.FromNodeIndex), true);
  // 0x04: u32
  if (data?.FromNodeOutputIndex !== undefined) view.setUint32(4, Number(data.FromNodeOutputIndex), true);
  // 0x08: u32
  if (data?.GraphOutputIndex !== undefined) view.setUint32(8, Number(data.GraphOutputIndex), true);
  // 0x0c: pad4
  // 0x10: buffer
  if (data?.Name !== undefined) {
    (buf as any)._f16 = util.pstrToFfi(data.Name);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : util.toBigInt(Deno.UnsafePointer.of((buf as any)._f16)), true);
  }
  return buf;
}

export class DML_OUTPUT_GRAPH_EDGE_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get FromNodeIndex(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get FromNodeOutputIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get GraphOutputIndex(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: buffer
  get Name(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: u32
  set FromNodeIndex(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set FromNodeOutputIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set GraphOutputIndex(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: buffer
  set Name(value: Uint8Array | Deno.PointerValue | null) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, util.toBigInt(util.toPointer((this.buf as any)._f16)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_INTERMEDIATE_GRAPH_EDGE_DESC (size: 24)
 */
export interface DML_INTERMEDIATE_GRAPH_EDGE_DESC {
  /** u32 */
  FromNodeIndex: number;
  /** u32 */
  FromNodeOutputIndex: number;
  /** u32 */
  ToNodeIndex: number;
  /** u32 */
  ToNodeInputIndex: number;
  /** Windows.Win32.Foundation.PSTR */
  Name: string | null | Uint8Array;
}

export const sizeofDML_INTERMEDIATE_GRAPH_EDGE_DESC = 24;

export function allocDML_INTERMEDIATE_GRAPH_EDGE_DESC(data?: Partial<DML_INTERMEDIATE_GRAPH_EDGE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_INTERMEDIATE_GRAPH_EDGE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.FromNodeIndex !== undefined) view.setUint32(0, Number(data.FromNodeIndex), true);
  // 0x04: u32
  if (data?.FromNodeOutputIndex !== undefined) view.setUint32(4, Number(data.FromNodeOutputIndex), true);
  // 0x08: u32
  if (data?.ToNodeIndex !== undefined) view.setUint32(8, Number(data.ToNodeIndex), true);
  // 0x0c: u32
  if (data?.ToNodeInputIndex !== undefined) view.setUint32(12, Number(data.ToNodeInputIndex), true);
  // 0x10: buffer
  if (data?.Name !== undefined) {
    (buf as any)._f16 = util.pstrToFfi(data.Name);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : util.toBigInt(Deno.UnsafePointer.of((buf as any)._f16)), true);
  }
  return buf;
}

export class DML_INTERMEDIATE_GRAPH_EDGE_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get FromNodeIndex(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get FromNodeOutputIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get ToNodeIndex(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get ToNodeInputIndex(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: buffer
  get Name(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: u32
  set FromNodeIndex(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set FromNodeOutputIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set ToNodeIndex(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set ToNodeInputIndex(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: buffer
  set Name(value: Uint8Array | Deno.PointerValue | null) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, util.toBigInt(util.toPointer((this.buf as any)._f16)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GRAPH_NODE_DESC (size: 16)
 */
export interface DML_GRAPH_NODE_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.DML_GRAPH_NODE_TYPE */
  Type: DML_GRAPH_NODE_TYPE;
  /** ptr */
  Desc: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_GRAPH_NODE_DESC = 16;

export function allocDML_GRAPH_NODE_DESC(data?: Partial<DML_GRAPH_NODE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GRAPH_NODE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.Type !== undefined) view.setInt32(0, Number(data.Type), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Desc !== undefined) view.setBigUint64(8, data.Desc === null ? 0n : util.toBigInt(util.toPointer(data.Desc)), true);
  return buf;
}

export class DML_GRAPH_NODE_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get Type(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Desc(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: i32
  set Type(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Desc(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(8, util.toBigInt(util.toPointer(value)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_OPERATOR_GRAPH_NODE_DESC (size: 16)
 */
export interface DML_OPERATOR_GRAPH_NODE_DESC {
  /** Windows.Win32.AI.MachineLearning.DirectML.IDMLOperator */
  Operator: Uint8Array | Deno.PointerValue | null;
  /** Windows.Win32.Foundation.PSTR */
  Name: string | null | Uint8Array;
}

export const sizeofDML_OPERATOR_GRAPH_NODE_DESC = 16;

export function allocDML_OPERATOR_GRAPH_NODE_DESC(data?: Partial<DML_OPERATOR_GRAPH_NODE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_OPERATOR_GRAPH_NODE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Operator !== undefined) view.setBigUint64(0, data.Operator === null ? 0n : util.toBigInt(util.toPointer(data.Operator)), true);
  // 0x08: buffer
  if (data?.Name !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.Name);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : util.toBigInt(Deno.UnsafePointer.of((buf as any)._f8)), true);
  }
  return buf;
}

export class DML_OPERATOR_GRAPH_NODE_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Operator(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(0, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x08: buffer
  get Name(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(8, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: pointer
  set Operator(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(0, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x08: buffer
  set Name(value: Uint8Array | Deno.PointerValue | null) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, util.toBigInt(util.toPointer((this.buf as any)._f8)), true);
  }
}

/**
 * Windows.Win32.AI.MachineLearning.DirectML.DML_GRAPH_DESC (size: 72)
 */
export interface DML_GRAPH_DESC {
  /** u32 */
  InputCount: number;
  /** u32 */
  OutputCount: number;
  /** u32 */
  NodeCount: number;
  /** ptr */
  Nodes: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  InputEdgeCount: number;
  /** ptr */
  InputEdges: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  OutputEdgeCount: number;
  /** ptr */
  OutputEdges: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  IntermediateEdgeCount: number;
  /** ptr */
  IntermediateEdges: Deno.PointerValue | Uint8Array | null;
}

export const sizeofDML_GRAPH_DESC = 72;

export function allocDML_GRAPH_DESC(data?: Partial<DML_GRAPH_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofDML_GRAPH_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.InputCount !== undefined) view.setUint32(0, Number(data.InputCount), true);
  // 0x04: u32
  if (data?.OutputCount !== undefined) view.setUint32(4, Number(data.OutputCount), true);
  // 0x08: u32
  if (data?.NodeCount !== undefined) view.setUint32(8, Number(data.NodeCount), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Nodes !== undefined) view.setBigUint64(16, data.Nodes === null ? 0n : util.toBigInt(util.toPointer(data.Nodes)), true);
  // 0x18: u32
  if (data?.InputEdgeCount !== undefined) view.setUint32(24, Number(data.InputEdgeCount), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.InputEdges !== undefined) view.setBigUint64(32, data.InputEdges === null ? 0n : util.toBigInt(util.toPointer(data.InputEdges)), true);
  // 0x28: u32
  if (data?.OutputEdgeCount !== undefined) view.setUint32(40, Number(data.OutputEdgeCount), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.OutputEdges !== undefined) view.setBigUint64(48, data.OutputEdges === null ? 0n : util.toBigInt(util.toPointer(data.OutputEdges)), true);
  // 0x38: u32
  if (data?.IntermediateEdgeCount !== undefined) view.setUint32(56, Number(data.IntermediateEdgeCount), true);
  // 0x3c: pad4
  // 0x40: pointer
  if (data?.IntermediateEdges !== undefined) view.setBigUint64(64, data.IntermediateEdges === null ? 0n : util.toBigInt(util.toPointer(data.IntermediateEdges)), true);
  return buf;
}

export class DML_GRAPH_DESCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get InputCount(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get OutputCount(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get NodeCount(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Nodes(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(16, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x18: u32
  get InputEdgeCount(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get InputEdges(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(32, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x28: u32
  get OutputEdgeCount(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get OutputEdges(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(48, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x38: u32
  get IntermediateEdgeCount(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  get IntermediateEdges(): Uint8Array | Deno.PointerValue | null {
    const ptr = this.view.getBigUint64(64, true);
    return util.pointerFromFfi(ptr);
  }

  // 0x00: u32
  set InputCount(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set OutputCount(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set NodeCount(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Nodes(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(16, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x18: u32
  set InputEdgeCount(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set InputEdges(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(32, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x28: u32
  set OutputEdgeCount(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set OutputEdges(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(48, util.toBigInt(util.toPointer(value)), true);
  }

  // 0x38: u32
  set IntermediateEdgeCount(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  set IntermediateEdges(value: Uint8Array | Deno.PointerValue | null) {
    this.view.setBigUint64(64, util.toBigInt(util.toPointer(value)), true);
  }
}

export type HRESULT = number;

// Native Libraries

try {
  var libDirectML_dll = Deno.dlopen("DirectML.dll", {
    DMLCreateDevice: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    DMLCreateDevice1: {
      parameters: ["pointer", "u32", "i32", "pointer", "pointer"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

// Symbols

export function DMLCreateDevice(
  d3d12Device: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Graphics.Direct3D12.ID3D12Device */,
  flags: DML_CREATE_DEVICE_FLAGS /* Windows.Win32.AI.MachineLearning.DirectML.DML_CREATE_DEVICE_FLAGS */,
  riid: Deno.PointerValue | Uint8Array | null /* ptr */,
  ppv: Deno.PointerValue | Uint8Array | null /* ptr */,
): Deno.PointerValue | null /* Windows.Win32.Foundation.HRESULT */ {
  return util.pointerFromFfi(libDirectML_dll.DMLCreateDevice(util.toPointer(d3d12Device), flags, util.toPointer(riid), util.toPointer(ppv)));
}

export function DMLCreateDevice1(
  d3d12Device: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Graphics.Direct3D12.ID3D12Device */,
  flags: DML_CREATE_DEVICE_FLAGS /* Windows.Win32.AI.MachineLearning.DirectML.DML_CREATE_DEVICE_FLAGS */,
  minimumFeatureLevel: DML_FEATURE_LEVEL /* Windows.Win32.AI.MachineLearning.DirectML.DML_FEATURE_LEVEL */,
  riid: Deno.PointerValue | Uint8Array | null /* ptr */,
  ppv: Deno.PointerValue | Uint8Array | null /* ptr */,
): Deno.PointerValue | null /* Windows.Win32.Foundation.HRESULT */ {
  return util.pointerFromFfi(libDirectML_dll.DMLCreateDevice1(util.toPointer(d3d12Device), flags, minimumFeatureLevel, util.toPointer(riid), util.toPointer(ppv)));
}

