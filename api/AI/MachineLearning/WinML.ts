/// Auto-generated by Deno Win32: Windows.Win32.AI.MachineLearning.WinML.Apis

import * as util from "../../../util.ts";

// Enums
export type WINML_TENSOR_DATA_TYPE = number;
export type WINML_FEATURE_TYPE = number;
export type WINML_BINDING_TYPE = number;
export type WINML_RUNTIME_TYPE = number;
export type MLOperatorAttributeType = number;
export type MLOperatorTensorDataType = number;
export type MLOperatorEdgeType = number;
export type MLOperatorParameterOptions = number;
export type MLOperatorSchemaEdgeTypeFormat = number;
export type MLOperatorKernelOptions = number;
export type MLOperatorExecutionType = number;

// Constants
export const WINML_TENSOR_DIMENSION_COUNT_MAX = 4;
export const WINML_TENSOR_UNDEFINED = 0;
export const WINML_TENSOR_FLOAT = 1;
export const WINML_TENSOR_UINT8 = 2;
export const WINML_TENSOR_INT8 = 3;
export const WINML_TENSOR_UINT16 = 4;
export const WINML_TENSOR_INT16 = 5;
export const WINML_TENSOR_INT32 = 6;
export const WINML_TENSOR_INT64 = 7;
export const WINML_TENSOR_STRING = 8;
export const WINML_TENSOR_BOOLEAN = 9;
export const WINML_TENSOR_FLOAT16 = 10;
export const WINML_TENSOR_DOUBLE = 11;
export const WINML_TENSOR_UINT32 = 12;
export const WINML_TENSOR_UINT64 = 13;
export const WINML_TENSOR_COMPLEX64 = 14;
export const WINML_TENSOR_COMPLEX128 = 15;
export const WINML_FEATURE_UNDEFINED = 0;
export const WINML_FEATURE_TENSOR = 1;
export const WINML_FEATURE_SEQUENCE = 2;
export const WINML_FEATURE_MAP = 3;
export const WINML_FEATURE_IMAGE = 4;
export const WINML_BINDING_UNDEFINED = 0;
export const WINML_BINDING_TENSOR = 1;
export const WINML_BINDING_SEQUENCE = 2;
export const WINML_BINDING_MAP = 3;
export const WINML_BINDING_IMAGE = 4;
export const WINML_BINDING_RESOURCE = 5;
export const WINML_RUNTIME_CNTK = 0;
export const Undefined = 0;
export const Float = 1;
export const Int = 3;
export const String = 8;
export const FloatArray = 7;
export const IntArray = 8;
export const StringArray = 9;
export const UInt8 = 2;
export const Int8 = 3;
export const UInt16 = 4;
export const Int16 = 5;
export const Int32 = 6;
export const Int64 = 7;
export const Bool = 9;
export const Float16 = 10;
export const Double = 11;
export const UInt32 = 12;
export const UInt64 = 13;
export const Complex64 = 14;
export const Complex128 = 15;
export const Tensor = 1;
export const Single = 0;
export const Optional = 1;
export const Variadic = 2;
export const EdgeDescription = 0;
export const Label = 1;
export const None = 0;
export const AllowDynamicInputShapes = 1;
export const Cpu = 1;
export const D3D12 = 2;

// Structs

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_BINDING_DESC (size: 32)
 */
export interface WINML_TENSOR_BINDING_DESC {
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  DataType: WINML_TENSOR_DATA_TYPE;
  /** u32 */
  NumDimensions: number;
  /** ptr */
  pShape: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DataSize: number;
  /** ptr */
  pData: Deno.PointerValue | Uint8Array | null;
}

export const sizeofWINML_TENSOR_BINDING_DESC = 32;

export function allocWINML_TENSOR_BINDING_DESC(data?: Partial<WINML_TENSOR_BINDING_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_TENSOR_BINDING_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.DataType !== undefined) view.setInt32(0, Number(data.DataType), true);
  // 0x04: u32
  if (data?.NumDimensions !== undefined) view.setUint32(4, Number(data.NumDimensions), true);
  // 0x08: pointer
  if (data?.pShape !== undefined) view.setBigUint64(8, data.pShape === null ? 0n : BigInt(util.toPointer(data.pShape)), true);
  // 0x10: u32
  if (data?.DataSize !== undefined) view.setUint32(16, Number(data.DataSize), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pData !== undefined) view.setBigUint64(24, data.pData === null ? 0n : BigInt(util.toPointer(data.pData)), true);
  return buf;
}

/**
 * _Anonymous_e__Struct (size: 16)
 */
export interface _Anonymous_e__Struct {
  /** u64 */
  Alignment: Deno.PointerValue;
  /** u64 */
  Region: Deno.PointerValue;
}

export const sizeof_Anonymous_e__Struct = 16;

export function alloc_Anonymous_e__Struct(data?: Partial<_Anonymous_e__Struct>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous_e__Struct);
  const view = new DataView(buf.buffer);
  // 0x00: u64
  if (data?.Alignment !== undefined) view.setBigUint64(0, BigInt(data.Alignment), true);
  // 0x08: u64
  if (data?.Region !== undefined) view.setBigUint64(8, BigInt(data.Region), true);
  return buf;
}

/**
 * _Anonymous_e__Union (size: 16)
 */
export interface _Anonymous_e__Union {
  /** _Anonymous_e__Struct */
  Anonymous: Uint8Array | Deno.PointerValue | null;
  /** array */
  X: Deno.PointerValue | null;
}

export const sizeof_Anonymous_e__Union = 16;

export function alloc_Anonymous_e__Union(data?: Partial<_Anonymous_e__Union>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous_e__Union);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(0, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  // 0x08: pointer
  if (data?.X !== undefined) view.setBigUint64(8, data.X === null ? 0n : BigInt(util.toPointer(data.X)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_SEQUENCE_BINDING_DESC (size: 16)
 */
export interface WINML_SEQUENCE_BINDING_DESC {
  /** u32 */
  ElementCount: number;
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  ElementType: WINML_TENSOR_DATA_TYPE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue | null;
}

export const sizeofWINML_SEQUENCE_BINDING_DESC = 16;

export function allocWINML_SEQUENCE_BINDING_DESC(data?: Partial<WINML_SEQUENCE_BINDING_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_SEQUENCE_BINDING_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.ElementCount !== undefined) view.setUint32(0, Number(data.ElementCount), true);
  // 0x04: i32
  if (data?.ElementType !== undefined) view.setInt32(4, Number(data.ElementType), true);
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  return buf;
}

export type PWSTR = Deno.PointerValue | Uint8Array | null;

/**
 * _Anonymous1_e__Union (size: 64)
 */
export interface _Anonymous1_e__Union {
  /** usize */
  Data0: Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  String: string | null;
  /** usize */
  u: Deno.PointerValue;
  /** ptr */
  psid: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  pguid: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  LogonId_LowPart: number;
  /** ptr */
  pObjectTypes: Deno.PointerValue | Uint8Array | null;
  /** ptr */
  pIpAddress: Deno.PointerValue | Uint8Array | null;
}

export const sizeof_Anonymous1_e__Union = 64;

export function alloc_Anonymous1_e__Union(data?: Partial<_Anonymous1_e__Union>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous1_e__Union);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.Data0 !== undefined) view.setBigUint64(0, BigInt(data.Data0), true);
  // 0x08: buffer
  if (data?.String !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.String);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f8)), true);
  }
  // 0x10: usize
  if (data?.u !== undefined) view.setBigUint64(16, BigInt(data.u), true);
  // 0x18: pointer
  if (data?.psid !== undefined) view.setBigUint64(24, data.psid === null ? 0n : BigInt(util.toPointer(data.psid)), true);
  // 0x20: pointer
  if (data?.pguid !== undefined) view.setBigUint64(32, data.pguid === null ? 0n : BigInt(util.toPointer(data.pguid)), true);
  // 0x28: u32
  if (data?.LogonId_LowPart !== undefined) view.setUint32(40, Number(data.LogonId_LowPart), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.pObjectTypes !== undefined) view.setBigUint64(48, data.pObjectTypes === null ? 0n : BigInt(util.toPointer(data.pObjectTypes)), true);
  // 0x38: pointer
  if (data?.pIpAddress !== undefined) view.setBigUint64(56, data.pIpAddress === null ? 0n : BigInt(util.toPointer(data.pIpAddress)), true);
  return buf;
}

/**
 * _Anonymous2_e__Union (size: 16)
 */
export interface _Anonymous2_e__Union {
  /** usize */
  Data1: Deno.PointerValue;
  /** i32 */
  LogonId_HighPart: number;
}

export const sizeof_Anonymous2_e__Union = 16;

export function alloc_Anonymous2_e__Union(data?: Partial<_Anonymous2_e__Union>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous2_e__Union);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.Data1 !== undefined) view.setBigUint64(0, BigInt(data.Data1), true);
  // 0x08: i32
  if (data?.LogonId_HighPart !== undefined) view.setInt32(8, Number(data.LogonId_HighPart), true);
  // 0x0c: pad4
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_MAP_BINDING_DESC (size: 32)
 */
export interface WINML_MAP_BINDING_DESC {
  /** u32 */
  ElementCount: number;
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  KeyType: WINML_TENSOR_DATA_TYPE;
  /** _Anonymous1_e__Union */
  Anonymous1: Uint8Array | Deno.PointerValue | null;
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  Fields: WINML_TENSOR_DATA_TYPE;
  /** _Anonymous2_e__Union */
  Anonymous2: Uint8Array | Deno.PointerValue | null;
}

export const sizeofWINML_MAP_BINDING_DESC = 32;

export function allocWINML_MAP_BINDING_DESC(data?: Partial<WINML_MAP_BINDING_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_MAP_BINDING_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.ElementCount !== undefined) view.setUint32(0, Number(data.ElementCount), true);
  // 0x04: i32
  if (data?.KeyType !== undefined) view.setInt32(4, Number(data.KeyType), true);
  // 0x08: pointer
  if (data?.Anonymous1 !== undefined) view.setBigUint64(8, data.Anonymous1 === null ? 0n : BigInt(util.toPointer(data.Anonymous1)), true);
  // 0x10: i32
  if (data?.Fields !== undefined) view.setInt32(16, Number(data.Fields), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Anonymous2 !== undefined) view.setBigUint64(24, data.Anonymous2 === null ? 0n : BigInt(util.toPointer(data.Anonymous2)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_IMAGE_BINDING_DESC (size: 32)
 */
export interface WINML_IMAGE_BINDING_DESC {
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  ElementType: WINML_TENSOR_DATA_TYPE;
  /** u32 */
  NumDimensions: number;
  /** ptr */
  pShape: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  DataSize: number;
  /** ptr */
  pData: Deno.PointerValue | Uint8Array | null;
}

export const sizeofWINML_IMAGE_BINDING_DESC = 32;

export function allocWINML_IMAGE_BINDING_DESC(data?: Partial<WINML_IMAGE_BINDING_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_IMAGE_BINDING_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.ElementType !== undefined) view.setInt32(0, Number(data.ElementType), true);
  // 0x04: u32
  if (data?.NumDimensions !== undefined) view.setUint32(4, Number(data.NumDimensions), true);
  // 0x08: pointer
  if (data?.pShape !== undefined) view.setBigUint64(8, data.pShape === null ? 0n : BigInt(util.toPointer(data.pShape)), true);
  // 0x10: u32
  if (data?.DataSize !== undefined) view.setUint32(16, Number(data.DataSize), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pData !== undefined) view.setBigUint64(24, data.pData === null ? 0n : BigInt(util.toPointer(data.pData)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_RESOURCE_BINDING_DESC (size: 24)
 */
export interface WINML_RESOURCE_BINDING_DESC {
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  ElementType: WINML_TENSOR_DATA_TYPE;
  /** u32 */
  NumDimensions: number;
  /** ptr */
  pShape: Deno.PointerValue | Uint8Array | null;
  /** Windows.Win32.Graphics.Direct3D12.ID3D12Resource */
  pResource: Uint8Array | Deno.PointerValue | null;
}

export const sizeofWINML_RESOURCE_BINDING_DESC = 24;

export function allocWINML_RESOURCE_BINDING_DESC(data?: Partial<WINML_RESOURCE_BINDING_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_RESOURCE_BINDING_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.ElementType !== undefined) view.setInt32(0, Number(data.ElementType), true);
  // 0x04: u32
  if (data?.NumDimensions !== undefined) view.setUint32(4, Number(data.NumDimensions), true);
  // 0x08: pointer
  if (data?.pShape !== undefined) view.setBigUint64(8, data.pShape === null ? 0n : BigInt(util.toPointer(data.pShape)), true);
  // 0x10: pointer
  if (data?.pResource !== undefined) view.setBigUint64(16, data.pResource === null ? 0n : BigInt(util.toPointer(data.pResource)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_BINDING_DESC (size: 24)
 */
export interface WINML_BINDING_DESC {
  /** Windows.Win32.Foundation.PWSTR */
  Name: string | null;
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_BINDING_TYPE */
  BindType: WINML_BINDING_TYPE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue | null;
}

export const sizeofWINML_BINDING_DESC = 24;

export function allocWINML_BINDING_DESC(data?: Partial<WINML_BINDING_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_BINDING_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.Name !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.Name);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: i32
  if (data?.BindType !== undefined) view.setInt32(8, Number(data.BindType), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(16, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_VARIABLE_DESC (size: 16)
 */
export interface WINML_TENSOR_VARIABLE_DESC {
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  ElementType: WINML_TENSOR_DATA_TYPE;
  /** u32 */
  NumDimensions: number;
  /** ptr */
  pShape: Deno.PointerValue | Uint8Array | null;
}

export const sizeofWINML_TENSOR_VARIABLE_DESC = 16;

export function allocWINML_TENSOR_VARIABLE_DESC(data?: Partial<WINML_TENSOR_VARIABLE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_TENSOR_VARIABLE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.ElementType !== undefined) view.setInt32(0, Number(data.ElementType), true);
  // 0x04: u32
  if (data?.NumDimensions !== undefined) view.setUint32(4, Number(data.NumDimensions), true);
  // 0x08: pointer
  if (data?.pShape !== undefined) view.setBigUint64(8, data.pShape === null ? 0n : BigInt(util.toPointer(data.pShape)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_SEQUENCE_VARIABLE_DESC (size: 8)
 */
export interface WINML_SEQUENCE_VARIABLE_DESC {
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  ElementType: WINML_TENSOR_DATA_TYPE;
}

export const sizeofWINML_SEQUENCE_VARIABLE_DESC = 8;

export function allocWINML_SEQUENCE_VARIABLE_DESC(data?: Partial<WINML_SEQUENCE_VARIABLE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_SEQUENCE_VARIABLE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.ElementType !== undefined) view.setInt32(0, Number(data.ElementType), true);
  // 0x04: pad4
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_MAP_VARIABLE_DESC (size: 8)
 */
export interface WINML_MAP_VARIABLE_DESC {
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  KeyType: WINML_TENSOR_DATA_TYPE;
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  Fields: WINML_TENSOR_DATA_TYPE;
}

export const sizeofWINML_MAP_VARIABLE_DESC = 8;

export function allocWINML_MAP_VARIABLE_DESC(data?: Partial<WINML_MAP_VARIABLE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_MAP_VARIABLE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.KeyType !== undefined) view.setInt32(0, Number(data.KeyType), true);
  // 0x04: i32
  if (data?.Fields !== undefined) view.setInt32(4, Number(data.Fields), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_IMAGE_VARIABLE_DESC (size: 16)
 */
export interface WINML_IMAGE_VARIABLE_DESC {
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_TENSOR_DATA_TYPE */
  ElementType: WINML_TENSOR_DATA_TYPE;
  /** u32 */
  NumDimensions: number;
  /** ptr */
  pShape: Deno.PointerValue | Uint8Array | null;
}

export const sizeofWINML_IMAGE_VARIABLE_DESC = 16;

export function allocWINML_IMAGE_VARIABLE_DESC(data?: Partial<WINML_IMAGE_VARIABLE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_IMAGE_VARIABLE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.ElementType !== undefined) view.setInt32(0, Number(data.ElementType), true);
  // 0x04: u32
  if (data?.NumDimensions !== undefined) view.setUint32(4, Number(data.NumDimensions), true);
  // 0x08: pointer
  if (data?.pShape !== undefined) view.setBigUint64(8, data.pShape === null ? 0n : BigInt(util.toPointer(data.pShape)), true);
  return buf;
}

export type BOOL = number;

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_VARIABLE_DESC (size: 32)
 */
export interface WINML_VARIABLE_DESC {
  /** Windows.Win32.Foundation.PWSTR */
  Name: string | null;
  /** Windows.Win32.Foundation.PWSTR */
  Description: string | null;
  /** Windows.Win32.AI.MachineLearning.WinML.WINML_FEATURE_TYPE */
  FeatureType: WINML_FEATURE_TYPE;
  /** Windows.Win32.Foundation.BOOL */
  Required: boolean;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue | null;
}

export const sizeofWINML_VARIABLE_DESC = 32;

export function allocWINML_VARIABLE_DESC(data?: Partial<WINML_VARIABLE_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_VARIABLE_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.Name !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.Name);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: buffer
  if (data?.Description !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.Description);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f8)), true);
  }
  // 0x10: i32
  if (data?.FeatureType !== undefined) view.setInt32(16, Number(data.FeatureType), true);
  // 0x14: i32
  if (data?.Required !== undefined) view.setInt32(20, Number(data.Required), true);
  // 0x18: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(24, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.WINML_MODEL_DESC (size: 40)
 */
export interface WINML_MODEL_DESC {
  /** Windows.Win32.Foundation.PWSTR */
  Author: string | null;
  /** Windows.Win32.Foundation.PWSTR */
  Name: string | null;
  /** Windows.Win32.Foundation.PWSTR */
  Domain: string | null;
  /** Windows.Win32.Foundation.PWSTR */
  Description: string | null;
  /** usize */
  Version: Deno.PointerValue;
}

export const sizeofWINML_MODEL_DESC = 40;

export function allocWINML_MODEL_DESC(data?: Partial<WINML_MODEL_DESC>): Uint8Array {
  const buf = new Uint8Array(sizeofWINML_MODEL_DESC);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.Author !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.Author);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: buffer
  if (data?.Name !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.Name);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f8)), true);
  }
  // 0x10: buffer
  if (data?.Domain !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.Domain);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f16)), true);
  }
  // 0x18: buffer
  if (data?.Description !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.Description);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f24)), true);
  }
  // 0x20: usize
  if (data?.Version !== undefined) view.setBigUint64(32, BigInt(data.Version), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorEdgeDescription (size: 16)
 */
export interface MLOperatorEdgeDescription {
  /** Windows.Win32.AI.MachineLearning.WinML.MLOperatorEdgeType */
  edgeType: MLOperatorEdgeType;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue | null;
}

export const sizeofMLOperatorEdgeDescription = 16;

export function allocMLOperatorEdgeDescription(data?: Partial<MLOperatorEdgeDescription>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorEdgeDescription);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.edgeType !== undefined) view.setUint32(0, Number(data.edgeType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorSchemaEdgeDescription (size: 16)
 */
export interface MLOperatorSchemaEdgeDescription {
  /** Windows.Win32.AI.MachineLearning.WinML.MLOperatorParameterOptions */
  options: MLOperatorParameterOptions;
  /** Windows.Win32.AI.MachineLearning.WinML.MLOperatorSchemaEdgeTypeFormat */
  typeFormat: MLOperatorSchemaEdgeTypeFormat;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue | null;
}

export const sizeofMLOperatorSchemaEdgeDescription = 16;

export function allocMLOperatorSchemaEdgeDescription(data?: Partial<MLOperatorSchemaEdgeDescription>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorSchemaEdgeDescription);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.options !== undefined) view.setUint32(0, Number(data.options), true);
  // 0x04: i32
  if (data?.typeFormat !== undefined) view.setInt32(4, Number(data.typeFormat), true);
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  return buf;
}

export type PSTR = Deno.PointerValue | Uint8Array | null;

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorEdgeTypeConstraint (size: 24)
 */
export interface MLOperatorEdgeTypeConstraint {
  /** Windows.Win32.Foundation.PSTR */
  typeLabel: string | null;
  /** ptr */
  allowedTypes: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  allowedTypeCount: number;
}

export const sizeofMLOperatorEdgeTypeConstraint = 24;

export function allocMLOperatorEdgeTypeConstraint(data?: Partial<MLOperatorEdgeTypeConstraint>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorEdgeTypeConstraint);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.typeLabel !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.typeLabel);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: pointer
  if (data?.allowedTypes !== undefined) view.setBigUint64(8, data.allowedTypes === null ? 0n : BigInt(util.toPointer(data.allowedTypes)), true);
  // 0x10: u32
  if (data?.allowedTypeCount !== undefined) view.setUint32(16, Number(data.allowedTypeCount), true);
  // 0x14: pad4
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorAttribute (size: 16)
 */
export interface MLOperatorAttribute {
  /** Windows.Win32.Foundation.PSTR */
  name: string | null;
  /** Windows.Win32.AI.MachineLearning.WinML.MLOperatorAttributeType */
  type: MLOperatorAttributeType;
  /** u8 */
  required: number;
}

export const sizeofMLOperatorAttribute = 16;

export function allocMLOperatorAttribute(data?: Partial<MLOperatorAttribute>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorAttribute);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.name !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.name);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: u32
  if (data?.type !== undefined) view.setUint32(8, Number(data.type), true);
  // 0x0c: u8
  if (data?.required !== undefined) view.setUint8(12, Number(data.required));
  // 0x0d: pad3
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorAttributeNameValue (size: 24)
 */
export interface MLOperatorAttributeNameValue {
  /** Windows.Win32.Foundation.PSTR */
  name: string | null;
  /** Windows.Win32.AI.MachineLearning.WinML.MLOperatorAttributeType */
  type: MLOperatorAttributeType;
  /** u32 */
  valueCount: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue | null;
}

export const sizeofMLOperatorAttributeNameValue = 24;

export function allocMLOperatorAttributeNameValue(data?: Partial<MLOperatorAttributeNameValue>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorAttributeNameValue);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.name !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.name);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: u32
  if (data?.type !== undefined) view.setUint32(8, Number(data.type), true);
  // 0x0c: u32
  if (data?.valueCount !== undefined) view.setUint32(12, Number(data.valueCount), true);
  // 0x10: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(16, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorSchemaDescription (size: 96)
 */
export interface MLOperatorSchemaDescription {
  /** Windows.Win32.Foundation.PSTR */
  name: string | null;
  /** i32 */
  operatorSetVersionAtLastChange: number;
  /** ptr */
  inputs: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  inputCount: number;
  /** ptr */
  outputs: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  outputCount: number;
  /** ptr */
  typeConstraints: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  typeConstraintCount: number;
  /** ptr */
  attributes: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  attributeCount: number;
  /** ptr */
  defaultAttributes: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  defaultAttributeCount: number;
}

export const sizeofMLOperatorSchemaDescription = 96;

export function allocMLOperatorSchemaDescription(data?: Partial<MLOperatorSchemaDescription>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorSchemaDescription);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.name !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.name);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: i32
  if (data?.operatorSetVersionAtLastChange !== undefined) view.setInt32(8, Number(data.operatorSetVersionAtLastChange), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.inputs !== undefined) view.setBigUint64(16, data.inputs === null ? 0n : BigInt(util.toPointer(data.inputs)), true);
  // 0x18: u32
  if (data?.inputCount !== undefined) view.setUint32(24, Number(data.inputCount), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.outputs !== undefined) view.setBigUint64(32, data.outputs === null ? 0n : BigInt(util.toPointer(data.outputs)), true);
  // 0x28: u32
  if (data?.outputCount !== undefined) view.setUint32(40, Number(data.outputCount), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.typeConstraints !== undefined) view.setBigUint64(48, data.typeConstraints === null ? 0n : BigInt(util.toPointer(data.typeConstraints)), true);
  // 0x38: u32
  if (data?.typeConstraintCount !== undefined) view.setUint32(56, Number(data.typeConstraintCount), true);
  // 0x3c: pad4
  // 0x40: pointer
  if (data?.attributes !== undefined) view.setBigUint64(64, data.attributes === null ? 0n : BigInt(util.toPointer(data.attributes)), true);
  // 0x48: u32
  if (data?.attributeCount !== undefined) view.setUint32(72, Number(data.attributeCount), true);
  // 0x4c: pad4
  // 0x50: pointer
  if (data?.defaultAttributes !== undefined) view.setBigUint64(80, data.defaultAttributes === null ? 0n : BigInt(util.toPointer(data.defaultAttributes)), true);
  // 0x58: u32
  if (data?.defaultAttributeCount !== undefined) view.setUint32(88, Number(data.defaultAttributeCount), true);
  // 0x5c: pad4
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorSetId (size: 16)
 */
export interface MLOperatorSetId {
  /** Windows.Win32.Foundation.PSTR */
  domain: string | null;
  /** i32 */
  version: number;
}

export const sizeofMLOperatorSetId = 16;

export function allocMLOperatorSetId(data?: Partial<MLOperatorSetId>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorSetId);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.domain !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.domain);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: i32
  if (data?.version !== undefined) view.setInt32(8, Number(data.version), true);
  // 0x0c: pad4
  return buf;
}

/**
 * Windows.Win32.AI.MachineLearning.WinML.MLOperatorKernelDescription (size: 64)
 */
export interface MLOperatorKernelDescription {
  /** Windows.Win32.Foundation.PSTR */
  domain: string | null;
  /** Windows.Win32.Foundation.PSTR */
  name: string | null;
  /** i32 */
  minimumOperatorSetVersion: number;
  /** Windows.Win32.AI.MachineLearning.WinML.MLOperatorExecutionType */
  executionType: MLOperatorExecutionType;
  /** ptr */
  typeConstraints: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  typeConstraintCount: number;
  /** ptr */
  defaultAttributes: Deno.PointerValue | Uint8Array | null;
  /** u32 */
  defaultAttributeCount: number;
  /** Windows.Win32.AI.MachineLearning.WinML.MLOperatorKernelOptions */
  options: MLOperatorKernelOptions;
  /** u32 */
  executionOptions: number;
}

export const sizeofMLOperatorKernelDescription = 64;

export function allocMLOperatorKernelDescription(data?: Partial<MLOperatorKernelDescription>): Uint8Array {
  const buf = new Uint8Array(sizeofMLOperatorKernelDescription);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.domain !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.domain);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f0)), true);
  }
  // 0x08: buffer
  if (data?.name !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.name);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.of((buf as any)._f8)), true);
  }
  // 0x10: i32
  if (data?.minimumOperatorSetVersion !== undefined) view.setInt32(16, Number(data.minimumOperatorSetVersion), true);
  // 0x14: u32
  if (data?.executionType !== undefined) view.setUint32(20, Number(data.executionType), true);
  // 0x18: pointer
  if (data?.typeConstraints !== undefined) view.setBigUint64(24, data.typeConstraints === null ? 0n : BigInt(util.toPointer(data.typeConstraints)), true);
  // 0x20: u32
  if (data?.typeConstraintCount !== undefined) view.setUint32(32, Number(data.typeConstraintCount), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.defaultAttributes !== undefined) view.setBigUint64(40, data.defaultAttributes === null ? 0n : BigInt(util.toPointer(data.defaultAttributes)), true);
  // 0x30: u32
  if (data?.defaultAttributeCount !== undefined) view.setUint32(48, Number(data.defaultAttributeCount), true);
  // 0x34: u32
  if (data?.options !== undefined) view.setUint32(52, Number(data.options), true);
  // 0x38: u32
  if (data?.executionOptions !== undefined) view.setUint32(56, Number(data.executionOptions), true);
  // 0x3c: pad4
  return buf;
}

export type HRESULT = number;

// Native Libraries

try {
  var libwinml_dll = Deno.dlopen("winml.dll", {
    WinMLCreateRuntime: {
      parameters: ["pointer"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libwindows_ai_machinelearning_dll = Deno.dlopen("windows.ai.machinelearning.dll", {
    MLCreateOperatorRegistry: {
      parameters: ["pointer"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

// Symbols

export function WinMLCreateRuntime(
  runtime: Deno.PointerValue | Uint8Array | null /* ptr */,
): Deno.PointerValue | null /* Windows.Win32.Foundation.HRESULT */ {
  return util.pointerFromFfi(libwinml_dll.WinMLCreateRuntime(util.toPointer(runtime)));
}

export function MLCreateOperatorRegistry(
  registry: Deno.PointerValue | Uint8Array | null /* ptr */,
): Deno.PointerValue | null /* Windows.Win32.Foundation.HRESULT */ {
  return util.pointerFromFfi(libwindows_ai_machinelearning_dll.MLCreateOperatorRegistry(util.toPointer(registry)));
}

