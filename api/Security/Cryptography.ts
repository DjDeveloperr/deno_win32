/// Auto-generated by Deno Win32: Windows.Win32.Security.Cryptography.Apis

import * as util from "../../util.ts";

// Enums
export type CRYPTCAT_VERSION = number;
export type CRYPTCAT_OPEN_FLAGS = number;
export type CERT_VIEW_COLUMN_INDEX = number;
export type CERT_DELETE_ROW_FLAGS = number;
export type FULL_RESPONSE_PROPERTY_ID = number;
export type CVRC_COLUMN = number;
export type CERT_IMPORT_FLAGS = number;
export type CERT_GET_CONFIG_FLAGS = number;
export type ENUM_CERT_COLUMN_VALUE_FLAGS = number;
export type PENDING_REQUEST_DESIRED_PROPERTY = number;
export type CERTADMIN_GET_ROLES_FLAGS = number;
export type CR_DISP = number;
export type XEKL_KEYSIZE = number;
export type CERT_CREATE_REQUEST_FLAGS = number;
export type CERT_EXIT_EVENT_MASK = number;
export type ADDED_CERT_TYPE = number;
export type CVRC_TABLE = number;
export type CERT_PROPERTY_TYPE = number;
export type CERT_ALT_NAME = number;
export type CSBACKUP_TYPE = number;
export type XEKL_KEYSPEC = number;
export type CERT_REQUEST_OUT_TYPE = number;
export type CERT_VIEW_SEEK_OPERATOR_FLAGS = number;
export type BCRYPT_OPERATION = number;
export type NCRYPT_OPERATION = number;
export type CERT_FIND_FLAGS = number;
export type CERT_QUERY_OBJECT_TYPE = number;
export type CERT_QUERY_CONTENT_TYPE = number;
export type CERT_QUERY_CONTENT_TYPE_FLAGS = number;
export type CERT_QUERY_FORMAT_TYPE = number;
export type CERT_QUERY_FORMAT_TYPE_FLAGS = number;
export type CERT_QUERY_ENCODING_TYPE = number;
export type CERT_RDN_ATTR_VALUE_TYPE = number;
export type CERT_STRING_TYPE = number;
export type BCRYPT_TABLE = number;
export type CERT_KEY_SPEC = number;
export type BCRYPT_INTERFACE = number;
export type NCRYPT_FLAGS = number;
export type CRYPT_STRING = number;
export type CRYPT_IMPORT_PUBLIC_KEY_FLAGS = number;
export type CRYPT_XML_FLAGS = number;
export type CRYPT_ENCODE_OBJECT_FLAGS = number;
export type CRYPT_OBJECT_LOCATOR_RELEASE_REASON = number;
export type CRYPT_ACQUIRE_FLAGS = number;
export type CRYPT_GET_URL_FLAGS = number;
export type CERT_STORE_SAVE_AS = number;
export type BCRYPT_QUERY_PROVIDER_MODE = number;
export type CERT_FIND_CHAIN_IN_STORE_FLAGS = number;
export type CERT_CONTROL_STORE_FLAGS = number;
export type BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS = number;
export type CERT_STORE_SAVE_TO = number;
export type CRYPT_SET_PROV_PARAM_ID = number;
export type CRYPT_KEY_PARAM_ID = number;
export type CRYPT_KEY_FLAGS = number;
export type CRYPT_MSG_TYPE = number;
export type CERT_OPEN_STORE_FLAGS = number;
export type CRYPT_DEFAULT_CONTEXT_FLAGS = number;
export type CRYPT_VERIFY_CERT_FLAGS = number;
export type CRYPT_SET_HASH_PARAM = number;
export type CERT_SYSTEM_STORE_FLAGS = number;
export type CERT_CREATE_SELFSIGN_FLAGS = number;
export type CRYPT_DEFAULT_CONTEXT_TYPE = number;
export type BCRYPT_RESOLVE_PROVIDERS_FLAGS = number;
export type CERT_FIND_TYPE = number;
export type CRYPT_FIND_FLAGS = number;
export type CRYPT_IMAGE_REF_FLAGS = number;
export type CERT_REVOCATION_STATUS_REASON = number;
export type CERT_ROOT_PROGRAM_FLAGS = number;
export type CRYPT_XML_KEY_VALUE_TYPE = number;
export type CERT_LOGOTYPE_CHOICE = number;
export type CMSG_KEY_AGREE_OPTION = number;
export type CERT_LOGOTYPE_OPTION = number;
export type CERT_STORE_PROV_FLAGS = number;
export type CMSG_KEY_AGREE_ORIGINATOR = number;
export type CRYPT_CONTEXT_CONFIG_FLAGS = number;
export type BCRYPT_DSA_MAGIC = number;
export type CRYPT_XML_X509DATA_TYPE = number;
export type CERT_BIOMETRIC_DATA_TYPE = number;
export type CERT_CHAIN_POLICY_FLAGS = number;
export type CERT_STRONG_SIGN_FLAGS = number;
export type CERT_LOGOTYPE_IMAGE_INFO_TYPE = number;
export type CRYPT_XML_STATUS_INFO_STATUS = number;
export type CRYPT_XML_TRANSFORM_FLAGS = number;
export type CRYPT_XML_GROUP_ID = number;
export type CERT_SELECT_CRITERIA_TYPE = number;
export type BCRYPT_RSAKEY_BLOB_MAGIC = number;
export type CRYPT_XML_KEYINFO_TYPE = number;
export type CRYPT_TIMESTAMP_VERSION = number;
export type CERT_ID_OPTION = number;
export type HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE = number;
export type BCRYPT_DH_KEY_BLOB_MAGIC = number;
export type CRYPT_XML_STATUS_ERROR_STATUS = number;
export type CRYPT_TIMESTAMP_RESPONSE_STATUS = number;
export type NCRYPT_ALGORITHM_NAME_CLASS = number;
export type CRYPTUI_WIZ_FLAGS = number;
export type CRYPTUI_VIEWCERTIFICATE_FLAGS = number;
export type CERT_SELECT_STRUCT_FLAGS = number;
export type CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION = number;
export type CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT = number;
export type CRYPTUI_WIZ_DIGITAL_SIGN = number;
export type CRYPTUI_WIZ_EXPORT_SUBJECT = number;
export type CRYPTUI_WIZ_DIGITAL_SIGN_SIG_TYPE = number;
export type CRYPTUI_WIZ_DIGITAL_SIGN_PVK_OPTION = number;
export type CERT_VIEWPROPERTIES_STRUCT_FLAGS = number;
export type CRYPTUI_WIZ_EXPORT_FORMAT = number;
export type CRYPTUI_WIZ_DIGITAL_ADDITIONAL_CERT_CHOICE = number;
export type CTL_MODIFY_REQUEST_OPERATION = number;
export type OCSPSigningFlag = number;
export type OCSPRequestFlag = number;
export type X509EnrollmentAuthFlags = number;
export type X509SCEPMessageType = number;
export type X509SCEPDisposition = number;
export type X509SCEPFailInfo = number;
export type CERTENROLL_OBJECTID = number;
export type WebSecurityLevel = number;
export type EncodingType = number;
export type PFXExportOptions = number;
export type ObjectIdGroupId = number;
export type ObjectIdPublicKeyFlags = number;
export type AlgorithmFlags = number;
export type X500NameFlags = number;
export type X509CertificateEnrollmentContext = number;
export type EnrollmentEnrollStatus = number;
export type EnrollmentSelectionStatus = number;
export type EnrollmentDisplayStatus = number;
export type X509ProviderType = number;
export type AlgorithmType = number;
export type AlgorithmOperationFlags = number;
export type X509KeySpec = number;
export type KeyIdentifierHashAlgorithm = number;
export type X509PrivateKeyExportFlags = number;
export type X509PrivateKeyUsageFlags = number;
export type X509PrivateKeyProtection = number;
export type X509PrivateKeyVerify = number;
export type X509HardwareKeyUsageFlags = number;
export type X509KeyParametersExportType = number;
export type X509KeyUsageFlags = number;
export type AlternativeNameType = number;
export type PolicyQualifierType = number;
export type RequestClientInfoClientId = number;
export type CERTENROLL_PROPERTYID = number;
export type EnrollmentPolicyServerPropertyFlags = number;
export type PolicyServerUrlFlags = number;
export type EnrollmentTemplateProperty = number;
export type CommitTemplateFlags = number;
export type EnrollmentCAProperty = number;
export type X509EnrollmentPolicyLoadOption = number;
export type EnrollmentPolicyFlags = number;
export type PolicyServerUrlPropertyID = number;
export type X509EnrollmentPolicyExportFlags = number;
export type X509RequestType = number;
export type X509RequestInheritOptions = number;
export type InnerRequestLevel = number;
export type Pkcs10AllowedSignatureTypes = number;
export type KeyAttestationClaimType = number;
export type InstallResponseRestrictionFlags = number;
export type WebEnrollmentFlags = number;
export type CRLRevocationReason = number;
export type X509SCEPProcessMessageFlags = number;
export type DelayRetryAction = number;
export type X509CertificateTemplateGeneralFlag = number;
export type X509CertificateTemplateEnrollmentFlag = number;
export type X509CertificateTemplateSubjectNameFlag = number;
export type X509CertificateTemplatePrivateKeyFlag = number;
export type ImportPFXFlags = number;
export type ENUM_CATYPES = number;
export type ECC_CURVE_TYPE_ENUM = number;
export type ECC_CURVE_ALG_ID_ENUM = number;
export type HASHALGORITHM_ENUM = number;
export type DSAFIPSVERSION_ENUM = number;
export type BCRYPT_HASH_OPERATION_TYPE = number;
export type BCRYPT_MULTI_OPERATION_TYPE = number;
export type CertKeyType = number;
export type CRYPT_XML_CHARSET = number;
export type CRYPT_XML_PROPERTY_ID = number;
export type CRYPT_XML_KEYINFO_SPEC = number;
export type HandleType = number;
export type PaddingMode = number;
export type Direction = number;
export type CASetupProperty = number;
export type MSCEPSetupProperty = number;
export type CESSetupProperty = number;
export type CEPSetupProperty = number;
export type OBJECT_SECURITY_INFORMATION = number;
export type REG_VALUE_TYPE = number;

// Constants
export const wszREGKEYNOSYSTEMCERTSVCPATH = `CurrentControlSet\\Services\\CertSvc`;
export const wszREGKEYCERTSVCPATH = `SYSTEM\\CurrentControlSet\\Services\\CertSvc`;
export const CA_DISP_INCOMPLETE = 0;
export const CA_DISP_ERROR = 1;
export const CA_DISP_REVOKED = 2;
export const CA_DISP_VALID = 3;
export const CA_DISP_INVALID = 4;
export const CA_DISP_UNDER_SUBMISSION = 5;
export const KRA_DISP_EXPIRED = 0;
export const KRA_DISP_NOTFOUND = 1;
export const KRA_DISP_REVOKED = 2;
export const KRA_DISP_VALID = 3;
export const KRA_DISP_INVALID = 4;
export const KRA_DISP_UNTRUSTED = 5;
export const KRA_DISP_NOTLOADED = 6;
export const CA_ACCESS_MASKROLES = 255;
export const CA_CRL_BASE = 1;
export const CA_CRL_DELTA = 2;
export const CA_CRL_REPUBLISH = 16;
export const ICF_ALLOWFOREIGN = 65536;
export const ICF_EXISTINGROW = 131072;
export const IKF_OVERWRITE = 65536;
export const wszOCSPCAPROP_CACERTIFICATE = `CACertificate`;
export const wszOCSPCAPROP_HASHALGORITHMID = `HashAlgorithmId`;
export const wszOCSPCAPROP_SIGNINGFLAGS = `SigningFlags`;
export const wszOCSPCAPROP_REMINDERDURATION = `ReminderDuration`;
export const wszOCSPCAPROP_SIGNINGCERTIFICATE = `SigningCertificate`;
export const wszOCSPCAPROP_CSPNAME = `CSPName`;
export const wszOCSPCAPROP_KEYSPEC = `KeySpec`;
export const wszOCSPCAPROP_ERRORCODE = `ErrorCode`;
export const wszOCSPCAPROP_PROVIDERCLSID = `ProviderCLSID`;
export const wszOCSPCAPROP_PROVIDERPROPERTIES = `Provider`;
export const wszOCSPCAPROP_LOCALREVOCATIONINFORMATION = `LocalRevocationInformation`;
export const wszOCSPCAPROP_SIGNINGCERTIFICATETEMPLATE = `SigningCertificateTemplate`;
export const wszOCSPCAPROP_CACONFIG = `CAConfig`;
export const wszOCSPPROP_LOGLEVEL = `LogLevel`;
export const wszOCSPPROP_DEBUG = `Debug`;
export const wszOCSPPROP_AUDITFILTER = `AuditFilter`;
export const wszOCSPPROP_ARRAYCONTROLLER = `ArrayController`;
export const wszOCSPPROP_ARRAYMEMBERS = `ArrayMembers`;
export const wszOCSPPROP_ENROLLPOLLINTERVAL = `EnrollPollInterval`;
export const wszOCSPISAPIPROP_VIRTUALROOTNAME = `VirtualRootName`;
export const wszOCSPISAPIPROP_NUMOFTHREADS = `NumOfThreads`;
export const wszOCSPISAPIPROP_NUMOFBACKENDCONNECTIONS = `NumOfBackendConnections`;
export const wszOCSPISAPIPROP_REFRESHRATE = `RefreshRate`;
export const wszOCSPISAPIPROP_MAXNUMOFCACHEENTRIES = `MaxNumOfCacheEntries`;
export const wszOCSPISAPIPROP_MAXAGE = `MaxAge`;
export const wszOCSPISAPIPROP_DEBUG = `ISAPIDebug`;
export const wszOCSPCOMMONPROP_REQFLAGS = `RequestFlags`;
export const wszOCSPCOMMONPROP_MAXINCOMINGMESSAGESIZE = `MaxIncomingMessageSize`;
export const wszOCSPCOMMONPROP_MAXNUMOFREQUESTENTRIES = `MaxNumOfRequestEntries`;
export const wszOCSPREVPROP_CRLURLTIMEOUT = `CrlUrlTimeOut`;
export const wszOCSPREVPROP_BASECRLURLS = `BaseCrlUrls`;
export const wszOCSPREVPROP_SERIALNUMBERSDIRS = `IssuedSerialNumbersDirectories`;
export const wszOCSPREVPROP_BASECRL = `BaseCrl`;
export const wszOCSPREVPROP_DELTACRLURLS = `DeltaCrlUrls`;
export const wszOCSPREVPROP_DELTACRL = `DeltaCrl`;
export const wszOCSPREVPROP_REFRESHTIMEOUT = `RefreshTimeOut`;
export const wszOCSPREVPROP_ERRORCODE = `RevocationErrorCode`;
export const szBACKUPANNOTATION = `Cert Server Backup Interface`;
export const szRESTOREANNOTATION = `Cert Server Restore Interface`;
export const CSBACKUP_TYPE_MASK = 3;
export const CSRESTORE_TYPE_FULL = 1;
export const CSRESTORE_TYPE_ONLINE = 2;
export const CSRESTORE_TYPE_CATCHUP = 4;
export const CSRESTORE_TYPE_MASK = 5;
export const CSBACKUP_DISABLE_INCREMENTAL = 4294967295;
export const CSBFT_DIRECTORY = 128;
export const CSBFT_DATABASE_DIRECTORY = 64;
export const CSBFT_LOG_DIRECTORY = 32;
export const CSCONTROL_SHUTDOWN = 1;
export const CSCONTROL_SUSPEND = 2;
export const CSCONTROL_RESTART = 3;
export const wszCONFIG_COMMONNAME = `CommonName`;
export const wszCONFIG_ORGUNIT = `OrgUnit`;
export const wszCONFIG_ORGANIZATION = `Organization`;
export const wszCONFIG_LOCALITY = `Locality`;
export const wszCONFIG_STATE = `State`;
export const wszCONFIG_COUNTRY = `Country`;
export const wszCONFIG_CONFIG = `Config`;
export const wszCONFIG_EXCHANGECERTIFICATE = `ExchangeCertificate`;
export const wszCONFIG_SIGNATURECERTIFICATE = `SignatureCertificate`;
export const wszCONFIG_DESCRIPTION = `Description`;
export const wszCONFIG_COMMENT = `Comment`;
export const wszCONFIG_SERVER = `Server`;
export const wszCONFIG_AUTHORITY = `Authority`;
export const wszCONFIG_SANITIZEDNAME = `SanitizedName`;
export const wszCONFIG_SHORTNAME = `ShortName`;
export const wszCONFIG_SANITIZEDSHORTNAME = `SanitizedShortName`;
export const wszCONFIG_FLAGS = `Flags`;
export const wszCONFIG_WEBENROLLMENTSERVERS = `WebEnrollmentServers`;
export const CAIF_DSENTRY = 1;
export const CAIF_SHAREDFOLDERENTRY = 2;
export const CAIF_REGISTRY = 4;
export const CAIF_LOCAL = 8;
export const CAIF_REGISTRYPARENT = 16;
export const CR_IN_ENCODEANY = 255;
export const CR_IN_ENCODEMASK = 255;
export const CR_IN_FORMATANY = 0;
export const CR_IN_PKCS10 = 256;
export const CR_IN_KEYGEN = 512;
export const CR_IN_PKCS7 = 768;
export const CR_IN_CMC = 1024;
export const CR_IN_CHALLENGERESPONSE = 1280;
export const CR_IN_SIGNEDCERTIFICATETIMESTAMPLIST = 1536;
export const CR_IN_FORMATMASK = 65280;
export const CR_IN_SCEP = 65536;
export const CR_IN_RPC = 131072;
export const CR_IN_HTTP = 196608;
export const CR_IN_FULLRESPONSE = 262144;
export const CR_IN_CRLS = 524288;
export const CR_IN_MACHINE = 1048576;
export const CR_IN_ROBO = 2097152;
export const CR_IN_CLIENTIDNONE = 4194304;
export const CR_IN_CONNECTONLY = 8388608;
export const CR_IN_RETURNCHALLENGE = 16777216;
export const CR_IN_SCEPPOST = 33554432;
export const CR_IN_CERTIFICATETRANSPARENCY = 67108864;
export const CR_DISP_REVOKED = 6;
export const CR_OUT_BASE64REQUESTHEADER = 3;
export const CR_OUT_HEX = 4;
export const CR_OUT_HEXASCII = 5;
export const CR_OUT_BASE64X509CRLHEADER = 9;
export const CR_OUT_HEXADDR = 10;
export const CR_OUT_HEXASCIIADDR = 11;
export const CR_OUT_HEXRAW = 12;
export const CR_OUT_ENCODEMASK = 255;
export const CR_OUT_CHAIN = 256;
export const CR_OUT_CRLS = 512;
export const CR_OUT_NOCRLF = 1073741824;
export const CR_OUT_NOCR = 2147483648;
export const CR_GEMT_DEFAULT = 0;
export const CR_GEMT_HRESULT_STRING = 1;
export const CR_GEMT_HTTP_ERROR = 2;
export const CR_PROP_NONE = 0;
export const CR_PROP_FILEVERSION = 1;
export const CR_PROP_PRODUCTVERSION = 2;
export const CR_PROP_EXITCOUNT = 3;
export const CR_PROP_EXITDESCRIPTION = 4;
export const CR_PROP_POLICYDESCRIPTION = 5;
export const CR_PROP_CANAME = 6;
export const CR_PROP_SANITIZEDCANAME = 7;
export const CR_PROP_SHAREDFOLDER = 8;
export const CR_PROP_PARENTCA = 9;
export const CR_PROP_CATYPE = 10;
export const CR_PROP_CASIGCERTCOUNT = 11;
export const CR_PROP_CASIGCERT = 12;
export const CR_PROP_CASIGCERTCHAIN = 13;
export const CR_PROP_CAXCHGCERTCOUNT = 14;
export const CR_PROP_CAXCHGCERT = 15;
export const CR_PROP_CAXCHGCERTCHAIN = 16;
export const CR_PROP_BASECRL = 17;
export const CR_PROP_DELTACRL = 18;
export const CR_PROP_CACERTSTATE = 19;
export const CR_PROP_CRLSTATE = 20;
export const CR_PROP_CAPROPIDMAX = 21;
export const CR_PROP_DNSNAME = 22;
export const CR_PROP_ROLESEPARATIONENABLED = 23;
export const CR_PROP_KRACERTUSEDCOUNT = 24;
export const CR_PROP_KRACERTCOUNT = 25;
export const CR_PROP_KRACERT = 26;
export const CR_PROP_KRACERTSTATE = 27;
export const CR_PROP_ADVANCEDSERVER = 28;
export const CR_PROP_TEMPLATES = 29;
export const CR_PROP_BASECRLPUBLISHSTATUS = 30;
export const CR_PROP_DELTACRLPUBLISHSTATUS = 31;
export const CR_PROP_CASIGCERTCRLCHAIN = 32;
export const CR_PROP_CAXCHGCERTCRLCHAIN = 33;
export const CR_PROP_CACERTSTATUSCODE = 34;
export const CR_PROP_CAFORWARDCROSSCERT = 35;
export const CR_PROP_CABACKWARDCROSSCERT = 36;
export const CR_PROP_CAFORWARDCROSSCERTSTATE = 37;
export const CR_PROP_CABACKWARDCROSSCERTSTATE = 38;
export const CR_PROP_CACERTVERSION = 39;
export const CR_PROP_SANITIZEDCASHORTNAME = 40;
export const CR_PROP_CERTCDPURLS = 41;
export const CR_PROP_CERTAIAURLS = 42;
export const CR_PROP_CERTAIAOCSPURLS = 43;
export const CR_PROP_LOCALENAME = 44;
export const CR_PROP_SUBJECTTEMPLATE_OIDS = 45;
export const CR_PROP_SCEPSERVERCERTS = 1000;
export const CR_PROP_SCEPSERVERCAPABILITIES = 1001;
export const CR_PROP_SCEPSERVERCERTSCHAIN = 1002;
export const CR_PROP_SCEPMIN = 1000;
export const CR_PROP_SCEPMAX = 1002;
export const FR_PROP_CLAIMCHALLENGE = 22;
export const EAN_NAMEOBJECTID = 2147483648;
export const EANR_SUPPRESS_IA5CONVERSION = 2147483648;
export const CERTENROLL_INDEX_BASE = 0;
export const EXITEVENT_INVALID = 0;
export const EXITEVENT_STARTUP = 128;
export const EXITEVENT_CERTIMPORTED = 512;
export const ENUMEXT_OBJECTID = 1;
export const CMM_REFRESHONLY = 1;
export const CMM_READONLY = 2;
export const DBG_CERTSRV = 1;
export const wszSERVICE_NAME = `CertSvc`;
export const wszREGKEYBASE = `SYSTEM\\CurrentControlSet\\Services\\CertSvc`;
export const wszREGKEYCONFIG = `Configuration`;
export const wszREGACTIVE = `Active`;
export const wszREGDIRECTORY = `ConfigurationDirectory`;
export const wszREGDBDIRECTORY = `DBDirectory`;
export const wszREGDBLOGDIRECTORY = `DBLogDirectory`;
export const wszREGDBSYSDIRECTORY = `DBSystemDirectory`;
export const wszREGDBTEMPDIRECTORY = `DBTempDirectory`;
export const wszREGDBSESSIONCOUNT = `DBSessionCount`;
export const wszREGDBMAXREADSESSIONCOUNT = `DBMaxReadSessionCount`;
export const wszREGDBFLAGS = `DBFlags`;
export const wszREGDBLASTFULLBACKUP = `DBLastFullBackup`;
export const wszREGDBLASTINCREMENTALBACKUP = `DBLastIncrementalBackup`;
export const wszREGDBLASTRECOVERY = `DBLastRecovery`;
export const wszREGWEBCLIENTCAMACHINE = `WebClientCAMachine`;
export const wszREGVERSION = `Version`;
export const wszREGWEBCLIENTCANAME = `WebClientCAName`;
export const wszREGWEBCLIENTCATYPE = `WebClientCAType`;
export const wszREGLDAPFLAGS = `LDAPFlags`;
export const wszREGCERTSRVDEBUG = `Debug`;
export const DBSESSIONCOUNTDEFAULT = 100;
export const DBFLAGS_READONLY = 1;
export const DBFLAGS_CREATEIFNEEDED = 2;
export const DBFLAGS_CIRCULARLOGGING = 4;
export const DBFLAGS_LAZYFLUSH = 8;
export const DBFLAGS_MAXCACHESIZEX100 = 16;
export const DBFLAGS_CHECKPOINTDEPTH60MB = 32;
export const DBFLAGS_LOGBUFFERSLARGE = 64;
export const DBFLAGS_LOGBUFFERSHUGE = 128;
export const DBFLAGS_LOGFILESIZE16MB = 256;
export const DBFLAGS_MULTITHREADTRANSACTIONS = 512;
export const DBFLAGS_DISABLESNAPSHOTBACKUP = 1024;
export const DBFLAGS_ENABLEVOLATILEREQUESTS = 2048;
export const LDAPF_SSLENABLE = 1;
export const LDAPF_SIGNDISABLE = 2;
export const CSVER_MAJOR_WIN2K = 1;
export const CSVER_MINOR_WIN2K = 1;
export const CSVER_MAJOR_WHISTLER = 2;
export const CSVER_MINOR_WHISTLER_BETA2 = 1;
export const CSVER_MINOR_WHISTLER_BETA3 = 2;
export const CSVER_MAJOR_LONGHORN = 3;
export const CSVER_MINOR_LONGHORN_BETA1 = 1;
export const CSVER_MAJOR_WIN7 = 4;
export const CSVER_MINOR_WIN7 = 1;
export const CSVER_MAJOR_WIN8 = 5;
export const CSVER_MINOR_WIN8 = 1;
export const CSVER_MAJOR_WINBLUE = 6;
export const CSVER_MINOR_WINBLUE = 1;
export const CSVER_MAJOR_THRESHOLD = 7;
export const CSVER_MINOR_THRESHOLD = 1;
export const CSVER_MAJOR = 7;
export const CSVER_MINOR = 1;
export const wszREGKEYRESTOREINPROGRESS = `RestoreInProgress`;
export const wszREGKEYDBPARAMETERS = `DBParameters`;
export const wszREGCADESCRIPTION = `CADescription`;
export const wszREGCACERTHASH = `CACertHash`;
export const wszREGCASERIALNUMBER = `CACertSerialNumber`;
export const wszREGCAXCHGCERTHASH = `CAXchgCertHash`;
export const wszREGKRACERTHASH = `KRACertHash`;
export const wszREGKRACERTCOUNT = `KRACertCount`;
export const wszREGKRAFLAGS = `KRAFlags`;
export const wszREGCATYPE = `CAType`;
export const wszREGCERTENROLLCOMPATIBLE = `CertEnrollCompatible`;
export const wszREGENFORCEX500NAMELENGTHS = `EnforceX500NameLengths`;
export const wszREGCOMMONNAME = `CommonName`;
export const wszREGCLOCKSKEWMINUTES = `ClockSkewMinutes`;
export const wszREGCRLNEXTPUBLISH = `CRLNextPublish`;
export const wszREGCRLPERIODSTRING = `CRLPeriod`;
export const wszREGCRLPERIODCOUNT = `CRLPeriodUnits`;
export const wszREGCRLOVERLAPPERIODSTRING = `CRLOverlapPeriod`;
export const wszREGCRLOVERLAPPERIODCOUNT = `CRLOverlapUnits`;
export const wszREGCRLDELTANEXTPUBLISH = `CRLDeltaNextPublish`;
export const wszREGCRLDELTAPERIODSTRING = `CRLDeltaPeriod`;
export const wszREGCRLDELTAPERIODCOUNT = `CRLDeltaPeriodUnits`;
export const wszREGCRLDELTAOVERLAPPERIODSTRING = `CRLDeltaOverlapPeriod`;
export const wszREGCRLDELTAOVERLAPPERIODCOUNT = `CRLDeltaOverlapUnits`;
export const wszREGCRLPUBLICATIONURLS = `CRLPublicationURLs`;
export const wszREGCACERTPUBLICATIONURLS = `CACertPublicationURLs`;
export const wszREGCAXCHGVALIDITYPERIODSTRING = `CAXchgValidityPeriod`;
export const wszREGCAXCHGVALIDITYPERIODCOUNT = `CAXchgValidityPeriodUnits`;
export const wszREGCAXCHGOVERLAPPERIODSTRING = `CAXchgOverlapPeriod`;
export const wszREGCAXCHGOVERLAPPERIODCOUNT = `CAXchgOverlapPeriodUnits`;
export const wszREGCRLPATH_OLD = `CRLPath`;
export const wszREGCRLEDITFLAGS = `CRLEditFlags`;
export const wszREGCRLFLAGS = `CRLFlags`;
export const wszREGCRLATTEMPTREPUBLISH = `CRLAttemptRepublish`;
export const wszREGENABLED = `Enabled`;
export const wszREGFORCETELETEX = `ForceTeletex`;
export const wszREGLOGLEVEL = `LogLevel`;
export const wszREGHIGHSERIAL = `HighSerial`;
export const wszREGPOLICYFLAGS = `PolicyFlags`;
export const wszREGNAMESEPARATOR = `SubjectNameSeparator`;
export const wszREGSUBJECTTEMPLATE = `SubjectTemplate`;
export const wszREGCAUSEDS = `UseDS`;
export const wszREGVALIDITYPERIODSTRING = `ValidityPeriod`;
export const wszREGVALIDITYPERIODCOUNT = `ValidityPeriodUnits`;
export const wszREGPARENTCAMACHINE = `ParentCAMachine`;
export const wszREGPARENTCANAME = `ParentCAName`;
export const wszREGREQUESTFILENAME = `RequestFileName`;
export const wszREGREQUESTID = `RequestId`;
export const wszREGREQUESTKEYCONTAINER = `RequestKeyContainer`;
export const wszREGREQUESTKEYINDEX = `RequestKeyIndex`;
export const wszREGCASERVERNAME = `CAServerName`;
export const wszREGCACERTFILENAME = `CACertFileName`;
export const wszREGCASECURITY = `Security`;
export const wszREGAUDITFILTER = `AuditFilter`;
export const wszREGOFFICERRIGHTS = `OfficerRights`;
export const wszENROLLMENTAGENTRIGHTS = `EnrollmentAgentRights`;
export const wszREGMAXINCOMINGMESSAGESIZE = `MaxIncomingMessageSize`;
export const wszREGMAXINCOMINGALLOCSIZE = `MaxIncomingAllocSize`;
export const wszREGROLESEPARATIONENABLED = `RoleSeparationEnabled`;
export const wszREGALTERNATEPUBLISHDOMAINS = `AlternatePublishDomains`;
export const wszREGSETUPSTATUS = `SetupStatus`;
export const wszREGINTERFACEFLAGS = `InterfaceFlags`;
export const wszREGDSCONFIGDN = `DSConfigDN`;
export const wszREGDSDOMAINDN = `DSDomainDN`;
export const wszREGVIEWAGEMINUTES = `ViewAgeMinutes`;
export const wszREGVIEWIDLEMINUTES = `ViewIdleMinutes`;
export const wszREGEKPUBLISTDIRECTORIES = `EndorsementKeyListDirectories`;
export const wszCERTIFICATETRANSPARENCYFLAGS = `CertificateTransparencyFlags`;
export const wszREGMAXSCTLISTSIZE = `MaxSCTListSize`;
export const wszREGCERTIFICATETRANSPARENCYINFOOID = `CTInformationExtensionOid`;
export const wszREGPROCESSINGFLAGS = `ProcessingFlags`;
export const wszREGUSEDEFINEDCACERTINREQ = `UseDefinedCACertInRequest`;
export const wszREGENABLEDEKUFORDEFINEDCACERT = `EnabledEKUForDefinedCACert`;
export const wszREGEKUOIDSFORPUBLISHEXPIREDCERTINCRL = `EKUOIDsForPublishExpiredCertInCRL`;
export const wszCRTFILENAMEEXT = `.crt`;
export const wszPFXFILENAMEEXT = `.p12`;
export const wszDATFILENAMEEXT = `.dat`;
export const wszLOGFILENAMEEXT = `.log`;
export const wszDBFILENAMEEXT = `.edb`;
export const szDBBASENAMEPARM = `edb`;
export const wszLOGPATH = `CertLog`;
export const wszDBBACKUPSUBDIR = `DataBase`;
export const wszDBBACKUPCERTBACKDAT = `certbkxp.dat`;
export const CCLOCKSKEWMINUTESDEFAULT = 10;
export const CVIEWAGEMINUTESDEFAULT = 16;
export const dwVALIDITYPERIODCOUNTDEFAULT_ROOT = 5;
export const dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE = 2;
export const dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE = 1;
export const dwCAXCHGVALIDITYPERIODCOUNTDEFAULT = 1;
export const dwCAXCHGOVERLAPPERIODCOUNTDEFAULT = 1;
export const dwCRLPERIODCOUNTDEFAULT = 1;
export const dwCRLOVERLAPPERIODCOUNTDEFAULT = 0;
export const dwCRLDELTAPERIODCOUNTDEFAULT = 1;
export const dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT = 0;
export const SETUP_SERVER_FLAG = 1;
export const SETUP_CLIENT_FLAG = 2;
export const SETUP_SUSPEND_FLAG = 4;
export const SETUP_REQUEST_FLAG = 8;
export const SETUP_ONLINE_FLAG = 16;
export const SETUP_DENIED_FLAG = 32;
export const SETUP_CREATEDB_FLAG = 64;
export const SETUP_ATTEMPT_VROOT_CREATE = 128;
export const SETUP_FORCECRL_FLAG = 256;
export const SETUP_UPDATE_CAOBJECT_SVRTYPE = 512;
export const SETUP_SERVER_UPGRADED_FLAG = 1024;
export const SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG = 2048;
export const SETUP_SECURITY_CHANGED = 4096;
export const SETUP_DCOM_SECURITY_UPDATED_FLAG = 8192;
export const SETUP_SERVER_IS_UP_TO_DATE_FLAG = 16384;
export const CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE = 1;
export const CRLF_DELETE_EXPIRED_CRLS = 2;
export const CRLF_CRLNUMBER_CRITICAL = 4;
export const CRLF_REVCHECK_IGNORE_OFFLINE = 8;
export const CRLF_IGNORE_INVALID_POLICIES = 16;
export const CRLF_REBUILD_MODIFIED_SUBJECT_ONLY = 32;
export const CRLF_SAVE_FAILED_CERTS = 64;
export const CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES = 128;
export const CRLF_IGNORE_CROSS_CERT_TRUST_ERROR = 256;
export const CRLF_PUBLISH_EXPIRED_CERT_CRLS = 512;
export const CRLF_ENFORCE_ENROLLMENT_AGENT = 1024;
export const CRLF_DISABLE_RDN_REORDER = 2048;
export const CRLF_DISABLE_ROOT_CROSS_CERTS = 4096;
export const CRLF_LOG_FULL_RESPONSE = 8192;
export const CRLF_USE_XCHG_CERT_TEMPLATE = 16384;
export const CRLF_USE_CROSS_CERT_TEMPLATE = 32768;
export const CRLF_ALLOW_REQUEST_ATTRIBUTE_SUBJECT = 65536;
export const CRLF_REVCHECK_IGNORE_NOREVCHECK = 131072;
export const CRLF_PRESERVE_EXPIRED_CA_CERTS = 262144;
export const CRLF_PRESERVE_REVOKED_CA_CERTS = 524288;
export const CRLF_DISABLE_CHAIN_VERIFICATION = 1048576;
export const CRLF_BUILD_ROOTCA_CRLENTRIES_BASEDONKEY = 2097152;
export const KRAF_ENABLEFOREIGN = 1;
export const KRAF_SAVEBADREQUESTKEY = 2;
export const KRAF_ENABLEARCHIVEALL = 4;
export const KRAF_DISABLEUSEDEFAULTPROVIDER = 8;
export const IF_LOCKICERTREQUEST = 1;
export const IF_NOREMOTEICERTREQUEST = 2;
export const IF_NOLOCALICERTREQUEST = 4;
export const IF_NORPCICERTREQUEST = 8;
export const IF_NOREMOTEICERTADMIN = 16;
export const IF_NOLOCALICERTADMIN = 32;
export const IF_NOREMOTEICERTADMINBACKUP = 64;
export const IF_NOLOCALICERTADMINBACKUP = 128;
export const IF_NOSNAPSHOTBACKUP = 256;
export const IF_ENFORCEENCRYPTICERTREQUEST = 512;
export const IF_ENFORCEENCRYPTICERTADMIN = 1024;
export const IF_ENABLEEXITKEYRETRIEVAL = 2048;
export const IF_ENABLEADMINASAUDITOR = 4096;
export const PROCFLG_NONE = 0;
export const PROCFLG_ENFORCEGOODKEYS = 1;
export const CSURL_SERVERPUBLISH = 1;
export const CSURL_ADDTOCERTCDP = 2;
export const CSURL_ADDTOFRESHESTCRL = 4;
export const CSURL_ADDTOCRLCDP = 8;
export const CSURL_PUBLISHRETRY = 16;
export const CSURL_ADDTOCERTOCSP = 32;
export const CSURL_SERVERPUBLISHDELTA = 64;
export const CSURL_ADDTOIDP = 128;
export const wszREGKEYCSP = `CSP`;
export const wszREGKEYENCRYPTIONCSP = `EncryptionCSP`;
export const wszREGKEYEXITMODULES = `ExitModules`;
export const wszREGKEYPOLICYMODULES = `PolicyModules`;
export const wszSECUREDATTRIBUTES = `SignedAttributes`;
export const wszzDEFAULTSIGNEDATTRIBUTES = `RequesterName\0`;
export const wszREGBACKUPLOGDIRECTORY = `BackupLogDirectory`;
export const wszREGCHECKPOINTFILE = `CheckPointFile`;
export const wszREGHIGHLOGNUMBER = `HighLogNumber`;
export const wszREGLOWLOGNUMBER = `LowLogNumber`;
export const wszREGLOGPATH = `LogPath`;
export const wszREGRESTOREMAPCOUNT = `RestoreMapCount`;
export const wszREGRESTOREMAP = `RestoreMap`;
export const wszREGDATABASERECOVERED = `DatabaseRecovered`;
export const wszREGRESTORESTATUS = `RestoreStatus`;
export const wszREGB2ICERTMANAGEMODULE = `ICertManageModule`;
export const wszREGSP4DEFAULTCONFIGURATION = `DefaultConfiguration`;
export const wszREGSP4KEYSETNAME = `KeySetName`;
export const wszREGSP4SUBJECTNAMESEPARATOR = `SubjectNameSeparator`;
export const wszREGSP4NAMES = `Names`;
export const wszREGSP4QUERIES = `Queries`;
export const wszREGNETSCAPECERTTYPE = `NetscapeCertType`;
export const wszNETSCAPEREVOCATIONTYPE = `Netscape`;
export const wszREGPROVIDERTYPE = `ProviderType`;
export const wszREGPROVIDER = `Provider`;
export const wszHASHALGORITHM = `HashAlgorithm`;
export const wszENCRYPTIONALGORITHM = `EncryptionAlgorithm`;
export const wszMACHINEKEYSET = `MachineKeyset`;
export const wszREGKEYSIZE = `KeySize`;
export const wszREGSYMMETRICKEYSIZE = `SymmetricKeySize`;
export const wszCNGPUBLICKEYALGORITHM = `CNGPublicKeyAlgorithm`;
export const wszCNGHASHALGORITHM = `CNGHashAlgorithm`;
export const wszCNGENCRYPTIONALGORITHM = `CNGEncryptionAlgorithm`;
export const wszREGALTERNATESIGNATUREALGORITHM = `AlternateSignatureAlgorithm`;
export const szNAMESEPARATORDEFAULT = `\n`;
export const wszPERIODYEARS = `Years`;
export const wszPERIODMONTHS = `Months`;
export const wszPERIODWEEKS = `Weeks`;
export const wszPERIODDAYS = `Days`;
export const wszPERIODHOURS = `Hours`;
export const wszPERIODMINUTES = `Minutes`;
export const wszPERIODSECONDS = `Seconds`;
export const wszREGISSUERCERTURLFLAGS = `IssuerCertURLFlags`;
export const wszREGEDITFLAGS = `EditFlags`;
export const wszREGUPNMAP = `UPNMap`;
export const wszREGSUBJECTALTNAME = `SubjectAltName`;
export const wszREGSUBJECTALTNAME2 = `SubjectAltName2`;
export const wszREGREQUESTDISPOSITION = `RequestDisposition`;
export const wszREGCAPATHLENGTH = `CAPathLength`;
export const wszREGREVOCATIONTYPE = `RevocationType`;
export const wszREGLDAPREVOCATIONCRLURL_OLD = `LDAPRevocationCRLURL`;
export const wszREGREVOCATIONCRLURL_OLD = `RevocationCRLURL`;
export const wszREGFTPREVOCATIONCRLURL_OLD = `FTPRevocationCRLURL`;
export const wszREGFILEREVOCATIONCRLURL_OLD = `FileRevocationCRLURL`;
export const wszREGREVOCATIONURL = `RevocationURL`;
export const wszREGLDAPISSUERCERTURL_OLD = `LDAPIssuerCertURL`;
export const wszREGISSUERCERTURL_OLD = `IssuerCertURL`;
export const wszREGFTPISSUERCERTURL_OLD = `FTPIssuerCertURL`;
export const wszREGFILEISSUERCERTURL_OLD = `FileIssuerCertURL`;
export const wszREGENABLEREQUESTEXTENSIONLIST = `EnableRequestExtensionList`;
export const wszREGENABLEENROLLEEREQUESTEXTENSIONLIST = `EnableEnrolleeRequestExtensionList`;
export const wszREGDISABLEEXTENSIONLIST = `DisableExtensionList`;
export const wszREGEKUOIDSFORVOLATILEREQUESTS = `EKUOIDsforVolatileRequests`;
export const wszREGLDAPSESSIONOPTIONS = `LDAPSessionOptions`;
export const wszLDAPSESSIONOPTIONVALUE = `LDAPSessionOptionValue`;
export const wszREGDEFAULTSMIME = `DefaultSMIME`;
export const CAPATHLENGTH_INFINITE = 4294967295;
export const REQDISP_PENDING = 0;
export const REQDISP_ISSUE = 1;
export const REQDISP_DENY = 2;
export const REQDISP_USEREQUESTATTRIBUTE = 3;
export const REQDISP_MASK = 255;
export const REQDISP_PENDINGFIRST = 256;
export const REQDISP_DEFAULT_ENTERPRISE = 1;
export const REVEXT_CDPLDAPURL_OLD = 1;
export const REVEXT_CDPHTTPURL_OLD = 2;
export const REVEXT_CDPFTPURL_OLD = 4;
export const REVEXT_CDPFILEURL_OLD = 8;
export const REVEXT_CDPURLMASK_OLD = 255;
export const REVEXT_CDPENABLE = 256;
export const REVEXT_ASPENABLE = 512;
export const REVEXT_DEFAULT_NODS = 256;
export const REVEXT_DEFAULT_DS = 256;
export const ISSCERT_LDAPURL_OLD = 1;
export const ISSCERT_HTTPURL_OLD = 2;
export const ISSCERT_FTPURL_OLD = 4;
export const ISSCERT_FILEURL_OLD = 8;
export const ISSCERT_URLMASK_OLD = 255;
export const ISSCERT_ENABLE = 256;
export const ISSCERT_DEFAULT_NODS = 256;
export const ISSCERT_DEFAULT_DS = 256;
export const EDITF_ENABLEREQUESTEXTENSIONS = 1;
export const EDITF_REQUESTEXTENSIONLIST = 2;
export const EDITF_DISABLEEXTENSIONLIST = 4;
export const EDITF_ADDOLDKEYUSAGE = 8;
export const EDITF_ADDOLDCERTTYPE = 16;
export const EDITF_ATTRIBUTEENDDATE = 32;
export const EDITF_BASICCONSTRAINTSCRITICAL = 64;
export const EDITF_BASICCONSTRAINTSCA = 128;
export const EDITF_ENABLEAKIKEYID = 256;
export const EDITF_ATTRIBUTECA = 512;
export const EDITF_IGNOREREQUESTERGROUP = 1024;
export const EDITF_ENABLEAKIISSUERNAME = 2048;
export const EDITF_ENABLEAKIISSUERSERIAL = 4096;
export const EDITF_ENABLEAKICRITICAL = 8192;
export const EDITF_SERVERUPGRADED = 16384;
export const EDITF_ATTRIBUTEEKU = 32768;
export const EDITF_ENABLEDEFAULTSMIME = 65536;
export const EDITF_EMAILOPTIONAL = 131072;
export const EDITF_ATTRIBUTESUBJECTALTNAME2 = 262144;
export const EDITF_ENABLELDAPREFERRALS = 524288;
export const EDITF_ENABLECHASECLIENTDC = 1048576;
export const EDITF_AUDITCERTTEMPLATELOAD = 2097152;
export const EDITF_DISABLEOLDOSCNUPN = 4194304;
export const EDITF_DISABLELDAPPACKAGELIST = 8388608;
export const EDITF_ENABLEUPNMAP = 16777216;
export const EDITF_ENABLEOCSPREVNOCHECK = 33554432;
export const EDITF_ENABLERENEWONBEHALFOF = 67108864;
export const EDITF_ENABLEKEYENCIPHERMENTCACERT = 134217728;
export const wszREGLDAPREVOCATIONDN_OLD = `LDAPRevocationDN`;
export const wszREGLDAPREVOCATIONDNTEMPLATE_OLD = `LDAPRevocationDNTemplate`;
export const wszCRLPUBLISHRETRYCOUNT = `CRLPublishRetryCount`;
export const wszREGCERTPUBLISHFLAGS = `PublishCertFlags`;
export const EXITPUB_FILE = 1;
export const EXITPUB_ACTIVEDIRECTORY = 2;
export const EXITPUB_REMOVEOLDCERTS = 16;
export const EXITPUB_DEFAULT_ENTERPRISE = 2;
export const EXITPUB_DEFAULT_STANDALONE = 1;
export const wszCLASS_CERTADMIN = `CertificateAuthority.Admin`;
export const wszCLASS_CERTCONFIG = `CertificateAuthority.Config`;
export const wszCLASS_CERTGETCONFIG = `CertificateAuthority.GetConfig`;
export const wszCLASS_CERTENCODE = `CertificateAuthority.Encode`;
export const wszCLASS_CERTDBMEM = `CertificateAuthority.DBMem`;
export const wszCLASS_CERTREQUEST = `CertificateAuthority.Request`;
export const wszCLASS_CERTSERVEREXIT = `CertificateAuthority.ServerExit`;
export const wszCLASS_CERTSERVERPOLICY = `CertificateAuthority.ServerPolicy`;
export const wszCLASS_CERTVIEW = `CertificateAuthority.View`;
export const wszMICROSOFTCERTMODULE_PREFIX = `CertificateAuthority_MicrosoftDefault`;
export const wszCERTMANAGE_SUFFIX = `Manage`;
export const wszCERTEXITMODULE_POSTFIX = `.Exit`;
export const wszCERTPOLICYMODULE_POSTFIX = `.Policy`;
export const wszCAPOLICYFILE = `CAPolicy.inf`;
export const wszINFSECTION_CDP = `CRLDistributionPoint`;
export const wszINFSECTION_AIA = `AuthorityInformationAccess`;
export const wszINFSECTION_EKU = `EnhancedKeyUsageExtension`;
export const wszINFSECTION_CCDP = `CrossCertificateDistributionPointsExtension`;
export const wszINFSECTION_CERTSERVER = `certsrv_server`;
export const wszINFKEY_RENEWALKEYLENGTH = `RenewalKeyLength`;
export const wszINFKEY_RENEWALVALIDITYPERIODSTRING = `RenewalValidityPeriod`;
export const wszINFKEY_RENEWALVALIDITYPERIODCOUNT = `RenewalValidityPeriodUnits`;
export const wszINFKEY_UTF8 = `UTF8`;
export const wszINFKEY_CRLPERIODSTRING = `CRLPeriod`;
export const wszINFKEY_CRLPERIODCOUNT = `CRLPeriodUnits`;
export const wszINFKEY_CRLDELTAPERIODSTRING = `CRLDeltaPeriod`;
export const wszINFKEY_CRLDELTAPERIODCOUNT = `CRLDeltaPeriodUnits`;
export const wszINFKEY_LOADDEFAULTTEMPLATES = `LoadDefaultTemplates`;
export const wszINFKEY_ENABLEKEYCOUNTING = `EnableKeyCounting`;
export const wszINFKEY_FORCEUTF8 = `ForceUTF8`;
export const wszINFKEY_ALTERNATESIGNATUREALGORITHM = `AlternateSignatureAlgorithm`;
export const wszINFKEY_SHOWALLCSPS = `ShowAllCSPs`;
export const wszINFKEY_CRITICAL = `Critical`;
export const wszINFKEY_EMPTY = `Empty`;
export const wszINFKEY_CCDPSYNCDELTATIME = `SyncDeltaTime`;
export const wszINFSECTION_CAPOLICY = `CAPolicy`;
export const wszINFSECTION_POLICYSTATEMENT = `PolicyStatementExtension`;
export const wszINFSECTION_APPLICATIONPOLICYSTATEMENT = `ApplicationPolicyStatementExtension`;
export const wszINFKEY_POLICIES = `Policies`;
export const wszINFKEY_OID = `OID`;
export const wszINFKEY_NOTICE = `Notice`;
export const wszINFKEY_FLAGS = `Flags`;
export const wszINFSECTION_REQUESTATTRIBUTES = `RequestAttributes`;
export const wszINFSECTION_NAMECONSTRAINTS = `NameConstraintsExtension`;
export const wszINFKEY_INCLUDE = `Include`;
export const wszINFKEY_EXCLUDE = `Exclude`;
export const wszINFKEY_SUBTREE = `SubTree`;
export const wszINFKEY_UPN = `UPN`;
export const wszINFKEY_EMAIL = `EMail`;
export const wszINFKEY_DNS = `DNS`;
export const wszINFKEY_DIRECTORYNAME = `DirectoryName`;
export const wszINFKEY_URL = `URL`;
export const wszINFKEY_IPADDRESS = `IPAddress`;
export const wszINFKEY_REGISTEREDID = `RegisteredId`;
export const wszINFKEY_OTHERNAME = `OtherName`;
export const wszINFSECTION_POLICYMAPPINGS = `PolicyMappingsExtension`;
export const wszINFSECTION_APPLICATIONPOLICYMAPPINGS = `ApplicationPolicyMappingsExtension`;
export const wszINFSECTION_POLICYCONSTRAINTS = `PolicyConstraintsExtension`;
export const wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS = `ApplicationPolicyConstraintsExtension`;
export const wszINFKEY_REQUIREEXPLICITPOLICY = `RequireExplicitPolicy`;
export const wszINFKEY_INHIBITPOLICYMAPPING = `InhibitPolicyMapping`;
export const wszINFSECTION_BASICCONSTRAINTS = `BasicConstraintsExtension`;
export const wszINFKEY_PATHLENGTH = `PathLength`;
export const wszINFSECTION_EXTENSIONS = `Extensions`;
export const wszINFSECTION_PROPERTIES = `Properties`;
export const wszINFKEY_CONTINUE = `_continue_`;
export const wszINFSECTION_NEWREQUEST = `NewRequest`;
export const wszINFKEY_SUBJECT = `Subject`;
export const wszINFKEY_SUBJECTNAMEFLAGS = `SubjectNameFlags`;
export const wszINFKEY_X500NAMEFLAGS = `X500NameFlags`;
export const wszINFKEY_EXPORTABLE = `Exportable`;
export const wszINFKEY_EXPORTABLEENCRYPTED = `ExportableEncrypted`;
export const wszINFKEY_HASHALGORITHM = `HashAlgorithm`;
export const wszINFKEY_KEYALGORITHM = `KeyAlgorithm`;
export const wszINFKEY_KEYALGORITHMPARMETERS = `KeyAlgorithmParameters`;
export const wszINFKEY_KEYCONTAINER = `KeyContainer`;
export const wszINFKEY_READERNAME = `ReaderName`;
export const wszINFKEY_KEYLENGTH = `KeyLength`;
export const wszINFKEY_LEGACYKEYSPEC = `KeySpec`;
export const wszINFKEY_KEYUSAGEEXTENSION = `KeyUsage`;
export const wszINFKEY_KEYUSAGEPROPERTY = `KeyUsageProperty`;
export const wszINFKEY_MACHINEKEYSET = `MachineKeySet`;
export const wszINFKEY_PRIVATEKEYARCHIVE = `PrivateKeyArchive`;
export const wszINFKEY_ENCRYPTIONALGORITHM = `EncryptionAlgorithm`;
export const wszINFKEY_ENCRYPTIONLENGTH = `EncryptionLength`;
export const wszINFKEY_PROVIDERNAME = `ProviderName`;
export const wszINFKEY_PROVIDERTYPE = `ProviderType`;
export const wszINFKEY_RENEWALCERT = `RenewalCert`;
export const wszINFKEY_REQUESTTYPE = `RequestType`;
export const wszINFKEY_SECURITYDESCRIPTOR = `SecurityDescriptor`;
export const wszINFKEY_SILENT = `Silent`;
export const wszINFKEY_SMIME = `SMIME`;
export const wszINFKEY_SUPPRESSDEFAULTS = `SuppressDefaults`;
export const wszINFKEY_USEEXISTINGKEY = `UseExistingKeySet`;
export const wszINFKEY_USERPROTECTED = `UserProtected`;
export const wszINFKEY_KEYPROTECTION = `KeyProtection`;
export const wszINFKEY_UICONTEXTMESSAGE = `UIContextMessage`;
export const wszINFKEY_FRIENDLYNAME = `FriendlyName`;
export const wszINFKEY_NOTBEFORE = `NotBefore`;
export const wszINFKEY_NOTAFTER = `NotAfter`;
export const wszINFKEY_ATTESTPRIVATEKEY = `AttestPrivateKey`;
export const wszINFKEY_PUBLICKEY = `PublicKey`;
export const wszINFKEY_PUBLICKEYPARAMETERS = `PublicKeyParameters`;
export const wszINFKEY_ECCKEYPARAMETERS = `EccKeyParameters`;
export const wszINFKEY_ECCKEYPARAMETERS_P = `EccKeyParameters_P`;
export const wszINFKEY_ECCKEYPARAMETERS_A = `EccKeyParameters_A`;
export const wszINFKEY_ECCKEYPARAMETERS_B = `EccKeyParameters_B`;
export const wszINFKEY_ECCKEYPARAMETERS_SEED = `EccKeyParameters_Seed`;
export const wszINFKEY_ECCKEYPARAMETERS_BASE = `EccKeyParameters_Base`;
export const wszINFKEY_ECCKEYPARAMETERS_ORDER = `EccKeyParameters_Order`;
export const wszINFKEY_ECCKEYPARAMETERS_COFACTOR = `EccKeyParameters_Cofactor`;
export const wszINFKEY_ECCKEYPARAMETERSTYPE = `EccKeyParametersType`;
export const wszINFKEY_SERIALNUMBER = `SerialNumber`;
export const wszINFKEY_CATHUMBPRINT = `CAThumbprint`;
export const wszINFKEY_CACERTS = `CACerts`;
export const wszINFKEY_CACAPABILITIES = `CACapabilities`;
export const wszINFKEY_CHALLENGEPASSWORD = `ChallengePassword`;
export const wszINFVALUE_REQUESTTYPE_PKCS10 = `PKCS10`;
export const wszINFVALUE_REQUESTTYPE_PKCS7 = `PKCS7`;
export const wszINFVALUE_REQUESTTYPE_CMC = `CMC`;
export const wszINFVALUE_REQUESTTYPE_CERT = `Cert`;
export const wszINFVALUE_REQUESTTYPE_SCEP = `SCEP`;
export const wszINFVALUE_ENDORSEMENTKEY = `EndorsementKey`;
export const wszREGEXITSMTPKEY = `SMTP`;
export const wszREGEXITSMTPTEMPLATES = `Templates`;
export const wszREGEXITSMTPEVENTFILTER = `EventFilter`;
export const wszREGEXITSMTPSERVER = `SMTPServer`;
export const wszREGEXITSMTPAUTHENTICATE = `SMTPAuthenticate`;
export const wszREGEXITDENIEDKEY = `Denied`;
export const wszREGEXITISSUEDKEY = `Issued`;
export const wszREGEXITPENDINGKEY = `Pending`;
export const wszREGEXITREVOKEDKEY = `Revoked`;
export const wszREGEXITCRLISSUEDKEY = `CRLIssued`;
export const wszREGEXITSHUTDOWNKEY = `Shutdown`;
export const wszREGEXITSTARTUPKEY = `Startup`;
export const wszREGEXITIMPORTEDKEY = `Imported`;
export const wszREGEXITSMTPFROM = `From`;
export const wszREGEXITSMTPTO = `To`;
export const wszREGEXITSMTPCC = `Cc`;
export const wszREGEXITTITLEFORMAT = `TitleFormat`;
export const wszREGEXITTITLEARG = `TitleArg`;
export const wszREGEXITBODYFORMAT = `BodyFormat`;
export const wszREGEXITBODYARG = `BodyArg`;
export const wszREGEXITPROPNOTFOUND = `???`;
export const wszREGKEYENROLLMENT = `Software\\Microsoft\\Cryptography\\AutoEnrollment`;
export const wszREGKEYGROUPPOLICYENROLLMENT = `Software\\Policies\\Microsoft\\Cryptography\\AutoEnrollment`;
export const wszREGMAXPENDINGREQUESTDAYS = `MaxPendingRequestDays`;
export const wszREGAELOGLEVEL_OLD = `AEEventLogLevel`;
export const wszREGENROLLFLAGS = `EnrollFlags`;
export const wszREGVERIFYFLAGS = `VerifyFlags`;
export const wszREGUNICODE = `Unicode`;
export const wszREGAIKCLOUDCAURL = `AIKCloudCAURL`;
export const wszREGAIKKEYALGORITHM = `AIKKeyAlgorithm`;
export const wszREGAIKKEYLENGTH = `AIKKeyLength`;
export const wszREGPRESERVESCEPDUMMYCERTS = `PreserveSCEPDummyCerts`;
export const wszREGALLPROVIDERS = `All`;
export const TP_MACHINEPOLICY = 1;
export const wszREGKEYREPAIR = `KeyRepair`;
export const KR_ENABLE_MACHINE = 1;
export const KR_ENABLE_USER = 2;
export const wszPROPDISTINGUISHEDNAME = `DistinguishedName`;
export const wszPROPRAWNAME = `RawName`;
export const wszPROPCOUNTRY = `Country`;
export const wszPROPORGANIZATION = `Organization`;
export const wszPROPORGUNIT = `OrgUnit`;
export const wszPROPCOMMONNAME = `CommonName`;
export const wszPROPLOCALITY = `Locality`;
export const wszPROPSTATE = `State`;
export const wszPROPTITLE = `Title`;
export const wszPROPGIVENNAME = `GivenName`;
export const wszPROPINITIALS = `Initials`;
export const wszPROPSURNAME = `SurName`;
export const wszPROPDOMAINCOMPONENT = `DomainComponent`;
export const wszPROPEMAIL = `EMail`;
export const wszPROPSTREETADDRESS = `StreetAddress`;
export const wszPROPUNSTRUCTUREDNAME = `UnstructuredName`;
export const wszPROPUNSTRUCTUREDADDRESS = `UnstructuredAddress`;
export const wszPROPDEVICESERIALNUMBER = `DeviceSerialNumber`;
export const wszPROPSUBJECTDOT = `Subject.`;
export const wszPROPREQUESTDOT = `Request.`;
export const wszPROPREQUESTREQUESTID = `RequestID`;
export const wszPROPREQUESTRAWREQUEST = `RawRequest`;
export const wszPROPREQUESTRAWARCHIVEDKEY = `RawArchivedKey`;
export const wszPROPREQUESTARCHIVEDKEY = `ArchivedKey`;
export const wszPROPREQUESTKEYRECOVERYHASHES = `KeyRecoveryHashes`;
export const wszPROPREQUESTRAWOLDCERTIFICATE = `RawOldCertificate`;
export const wszPROPREQUESTATTRIBUTES = `RequestAttributes`;
export const wszPROPREQUESTTYPE = `RequestType`;
export const wszPROPREQUESTFLAGS = `RequestFlags`;
export const wszPROPREQUESTSTATUSCODE = `StatusCode`;
export const wszPROPREQUESTDISPOSITION = `Disposition`;
export const wszPROPREQUESTDISPOSITIONMESSAGE = `DispositionMessage`;
export const wszPROPREQUESTSUBMITTEDWHEN = `SubmittedWhen`;
export const wszPROPREQUESTRESOLVEDWHEN = `ResolvedWhen`;
export const wszPROPREQUESTREVOKEDWHEN = `RevokedWhen`;
export const wszPROPREQUESTREVOKEDEFFECTIVEWHEN = `RevokedEffectiveWhen`;
export const wszPROPREQUESTREVOKEDREASON = `RevokedReason`;
export const wszPROPREQUESTERNAME = `RequesterName`;
export const wszPROPCALLERNAME = `CallerName`;
export const wszPROPSIGNERPOLICIES = `SignerPolicies`;
export const wszPROPSIGNERAPPLICATIONPOLICIES = `SignerApplicationPolicies`;
export const wszPROPOFFICER = `Officer`;
export const wszPROPPUBLISHEXPIREDCERTINCRL = `PublishExpiredCertInCRL`;
export const wszPROPREQUESTERNAMEFROMOLDCERTIFICATE = `RequesterNameFromOldCertificate`;
export const wszPROPATTESTATIONCHALLENGE = `AttestationChallenge`;
export const wszPROPENDORSEMENTKEYHASH = `EndorsementKeyHash`;
export const wszPROPENDORSEMENTCERTIFICATEHASH = `EndorsementCertificateHash`;
export const wszPROPRAWPRECERTIFICATE = `RawPrecertificate`;
export const wszPROPCHALLENGE = `Challenge`;
export const wszPROPEXPECTEDCHALLENGE = `ExpectedChallenge`;
export const wszPROPDISPOSITION = `Disposition`;
export const wszPROPDISPOSITIONDENY = `Deny`;
export const wszPROPDISPOSITIONPENDING = `Pending`;
export const wszPROPVALIDITYPERIODSTRING = `ValidityPeriod`;
export const wszPROPVALIDITYPERIODCOUNT = `ValidityPeriodUnits`;
export const wszPROPEXPIRATIONDATE = `ExpirationDate`;
export const wszPROPCERTTYPE = `CertType`;
export const wszPROPCERTTEMPLATE = `CertificateTemplate`;
export const wszPROPCERTUSAGE = `CertificateUsage`;
export const wszPROPREQUESTOSVERSION = `RequestOSVersion`;
export const wszPROPREQUESTCSPPROVIDER = `RequestCSPProvider`;
export const wszPROPEXITCERTFILE = `CertFile`;
export const wszPROPCLIENTBROWSERMACHINE = `cbm`;
export const wszPROPCERTCLIENTMACHINE = `ccm`;
export const wszPROPCLIENTDCDNS = `cdc`;
export const wszPROPREQUESTMACHINEDNS = `rmd`;
export const wszPROPSUBJECTALTNAME2 = `san`;
export const wszPROPDNS = `dns`;
export const wszPROPDN = `dn`;
export const wszPROPURL = `url`;
export const wszPROPIPADDRESS = `ipaddress`;
export const wszPROPGUID = `guid`;
export const wszPROPOID = `oid`;
export const wszPROPUPN = `upn`;
export const szPROPASNTAG = `{asn}`;
export const wszPROPCRITICALTAG = `{critical}`;
export const wszPROPUTF8TAG = `{utf8}`;
export const wszPROPOCTETTAG = `{octet}`;
export const wszPROPHEXTAG = `{hex}`;
export const wszPROPTEXTTAG = `{text}`;
export const wszPROPDECIMALTAG = `{decimal}`;
export const wszPROPFILETAG = `{file}`;
export const wszAT_EKCERTINF = `@EKCert`;
export const wszAT_TESTROOT = `@TestRoot`;
export const wszPROPCATYPE = `CAType`;
export const wszPROPSANITIZEDCANAME = `SanitizedCAName`;
export const wszPROPSANITIZEDSHORTNAME = `SanitizedShortName`;
export const wszPROPMACHINEDNSNAME = `MachineDNSName`;
export const wszPROPMODULEREGLOC = `ModuleRegistryLocation`;
export const wszPROPUSEDS = `fUseDS`;
export const wszPROPDELTACRLSDISABLED = `fDeltaCRLsDisabled`;
export const wszPROPSERVERUPGRADED = `fServerUpgraded`;
export const wszPROPCONFIGDN = `ConfigDN`;
export const wszPROPDOMAINDN = `DomainDN`;
export const wszPROPLOGLEVEL = `LogLevel`;
export const wszPROPSESSIONCOUNT = `SessionCount`;
export const wszPROPTEMPLATECHANGESEQUENCENUMBER = `TemplateChangeSequenceNumber`;
export const wszPROPVOLATILEMODE = `VolatileMode`;
export const wszLOCALIZEDTIMEPERIODUNITS = `LocalizedTimePeriodUnits`;
export const wszPROPREQUESTERCAACCESS = `RequesterCAAccess`;
export const wszPROPUSERDN = `UserDN`;
export const wszPROPKEYARCHIVED = `KeyArchived`;
export const wszPROPCERTCOUNT = `CertCount`;
export const wszPROPRAWCACERTIFICATE = `RawCACertificate`;
export const wszPROPCERTSTATE = `CertState`;
export const wszPROPCERTSUFFIX = `CertSuffix`;
export const wszPROPRAWCRL = `RawCRL`;
export const wszPROPRAWDELTACRL = `RawDeltaCRL`;
export const wszPROPCRLINDEX = `CRLIndex`;
export const wszPROPCRLSTATE = `CRLState`;
export const wszPROPCRLSUFFIX = `CRLSuffix`;
export const wszPROPEVENTLOGTERSE = `EventLogTerse`;
export const wszPROPEVENTLOGERROR = `EventLogError`;
export const wszPROPEVENTLOGWARNING = `EventLogWarning`;
export const wszPROPEVENTLOGVERBOSE = `EventLogVerbose`;
export const wszPROPEVENTLOGEXHAUSTIVE = `EventLogExhaustive`;
export const wszPROPDCNAME = `DCName`;
export const wszPROPCROSSFOREST = `CrossForest`;
export const wszPROPREQUESTERSAMNAME = `RequesterSAMName`;
export const wszPROPREQUESTERUPN = `RequesterUPN`;
export const wszPROPREQUESTERDN = `RequesterDN`;
export const wszPROPSEAUDITID = `SEAuditId`;
export const wszPROPSEAUDITFILTER = `SEAuditFilter`;
export const wszPROPCERTIFICATEREQUESTID = `RequestID`;
export const wszPROPRAWCERTIFICATE = `RawCertificate`;
export const wszPROPCERTIFICATEHASH = `CertificateHash`;
export const wszPROPCERTIFICATETEMPLATE = `CertificateTemplate`;
export const wszPROPCERTIFICATEENROLLMENTFLAGS = `EnrollmentFlags`;
export const wszPROPCERTIFICATEGENERALFLAGS = `GeneralFlags`;
export const wszPROPCERTIFICATEPRIVATEKEYFLAGS = `PrivatekeyFlags`;
export const wszPROPCERTIFICATESERIALNUMBER = `SerialNumber`;
export const wszPROPCERTIFICATENOTBEFOREDATE = `NotBefore`;
export const wszPROPCERTIFICATENOTAFTERDATE = `NotAfter`;
export const wszPROPCERTIFICATESUBJECTKEYIDENTIFIER = `SubjectKeyIdentifier`;
export const wszPROPCERTIFICATERAWPUBLICKEY = `RawPublicKey`;
export const wszPROPCERTIFICATEPUBLICKEYLENGTH = `PublicKeyLength`;
export const wszPROPCERTIFICATEPUBLICKEYALGORITHM = `PublicKeyAlgorithm`;
export const wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS = `RawPublicKeyAlgorithmParameters`;
export const wszPROPCERTIFICATEUPN = `UPN`;
export const wszPROPCERTIFICATETYPE = `CertificateType`;
export const wszPROPCERTIFICATERAWSMIMECAPABILITIES = `RawSMIMECapabilities`;
export const wszPROPNAMETYPE = `NameType`;
export const EXTENSION_CRITICAL_FLAG = 1;
export const EXTENSION_DISABLE_FLAG = 2;
export const EXTENSION_DELETE_FLAG = 4;
export const EXTENSION_POLICY_MASK = 65535;
export const EXTENSION_ORIGIN_REQUEST = 65536;
export const EXTENSION_ORIGIN_POLICY = 131072;
export const EXTENSION_ORIGIN_ADMIN = 196608;
export const EXTENSION_ORIGIN_SERVER = 262144;
export const EXTENSION_ORIGIN_RENEWALCERT = 327680;
export const EXTENSION_ORIGIN_IMPORTEDCERT = 393216;
export const EXTENSION_ORIGIN_PKCS7 = 458752;
export const EXTENSION_ORIGIN_CMC = 524288;
export const EXTENSION_ORIGIN_CACERT = 589824;
export const EXTENSION_ORIGIN_MASK = 983040;
export const wszPROPEXTREQUESTID = `ExtensionRequestId`;
export const wszPROPEXTNAME = `ExtensionName`;
export const wszPROPEXTFLAGS = `ExtensionFlags`;
export const wszPROPEXTRAWVALUE = `ExtensionRawValue`;
export const wszPROPATTRIBREQUESTID = `AttributeRequestId`;
export const wszPROPATTRIBNAME = `AttributeName`;
export const wszPROPATTRIBVALUE = `AttributeValue`;
export const wszPROPCRLROWID = `CRLRowId`;
export const wszPROPCRLNUMBER = `CRLNumber`;
export const wszPROPCRLMINBASE = `CRLMinBase`;
export const wszPROPCRLNAMEID = `CRLNameId`;
export const wszPROPCRLCOUNT = `CRLCount`;
export const wszPROPCRLTHISUPDATE = `CRLThisUpdate`;
export const wszPROPCRLNEXTUPDATE = `CRLNextUpdate`;
export const wszPROPCRLTHISPUBLISH = `CRLThisPublish`;
export const wszPROPCRLNEXTPUBLISH = `CRLNextPublish`;
export const wszPROPCRLEFFECTIVE = `CRLEffective`;
export const wszPROPCRLPROPAGATIONCOMPLETE = `CRLPropagationComplete`;
export const wszPROPCRLLASTPUBLISHED = `CRLLastPublished`;
export const wszPROPCRLPUBLISHATTEMPTS = `CRLPublishAttempts`;
export const wszPROPCRLPUBLISHFLAGS = `CRLPublishFlags`;
export const wszPROPCRLPUBLISHSTATUSCODE = `CRLPublishStatusCode`;
export const wszPROPCRLPUBLISHERROR = `CRLPublishError`;
export const wszPROPCRLRAWCRL = `CRLRawCRL`;
export const CPF_BASE = 1;
export const CPF_DELTA = 2;
export const CPF_COMPLETE = 4;
export const CPF_SHADOW = 8;
export const CPF_CASTORE_ERROR = 16;
export const CPF_BADURL_ERROR = 32;
export const CPF_MANUAL = 64;
export const CPF_SIGNATURE_ERROR = 128;
export const CPF_LDAP_ERROR = 256;
export const CPF_FILE_ERROR = 512;
export const CPF_FTP_ERROR = 1024;
export const CPF_HTTP_ERROR = 2048;
export const CPF_POSTPONED_BASE_LDAP_ERROR = 4096;
export const CPF_POSTPONED_BASE_FILE_ERROR = 8192;
export const PROPTYPE_MASK = 255;
export const PROPCALLER_SERVER = 256;
export const PROPCALLER_POLICY = 512;
export const PROPCALLER_EXIT = 768;
export const PROPCALLER_ADMIN = 1024;
export const PROPCALLER_REQUEST = 1280;
export const PROPCALLER_MASK = 3840;
export const PROPFLAGS_INDEXED = 65536;
export const CR_FLG_FORCETELETEX = 1;
export const CR_FLG_RENEWAL = 2;
export const CR_FLG_FORCEUTF8 = 4;
export const CR_FLG_CAXCHGCERT = 8;
export const CR_FLG_ENROLLONBEHALFOF = 16;
export const CR_FLG_SUBJECTUNMODIFIED = 32;
export const CR_FLG_VALIDENCRYPTEDKEYHASH = 64;
export const CR_FLG_CACROSSCERT = 128;
export const CR_FLG_ENFORCEUTF8 = 256;
export const CR_FLG_DEFINEDCACERT = 512;
export const CR_FLG_CHALLENGEPENDING = 1024;
export const CR_FLG_CHALLENGESATISFIED = 2048;
export const CR_FLG_TRUSTONUSE = 4096;
export const CR_FLG_TRUSTEKCERT = 8192;
export const CR_FLG_TRUSTEKKEY = 16384;
export const CR_FLG_PUBLISHERROR = 2147483648;
export const DB_DISP_ACTIVE = 8;
export const DB_DISP_PENDING = 9;
export const DB_DISP_QUEUE_MAX = 9;
export const DB_DISP_FOREIGN = 12;
export const DB_DISP_CA_CERT = 15;
export const DB_DISP_CA_CERT_CHAIN = 16;
export const DB_DISP_KRA_CERT = 17;
export const DB_DISP_LOG_MIN = 20;
export const DB_DISP_ISSUED = 20;
export const DB_DISP_REVOKED = 21;
export const DB_DISP_LOG_FAILED_MIN = 30;
export const DB_DISP_ERROR = 30;
export const DB_DISP_DENIED = 31;
export const VR_PENDING = 0;
export const VR_INSTANT_OK = 1;
export const VR_INSTANT_BAD = 2;
export const wszCERT_TYPE = `RequestType`;
export const wszCERT_TYPE_CLIENT = `Client`;
export const wszCERT_TYPE_SERVER = `Server`;
export const wszCERT_TYPE_CODESIGN = `CodeSign`;
export const wszCERT_TYPE_CUSTOMER = `SetCustomer`;
export const wszCERT_TYPE_MERCHANT = `SetMerchant`;
export const wszCERT_TYPE_PAYMENT = `SetPayment`;
export const wszCERT_VERSION = `Version`;
export const wszCERT_VERSION_1 = 1;
export const wszCERT_VERSION_2 = 2;
export const wszCERT_VERSION_3 = 3;
export const CV_OUT_HEXRAW = 12;
export const CV_OUT_ENCODEMASK = 255;
export const CV_OUT_NOCRLF = 1073741824;
export const CV_OUT_NOCR = 2147483648;
export const CVR_SEEK_NONE = 0;
export const CVR_SEEK_MASK = 255;
export const CVR_SEEK_NODELTA = 4096;
export const CVR_SORT_NONE = 0;
export const CVR_SORT_ASCEND = 1;
export const CVR_SORT_DESCEND = 2;
export const CV_COLUMN_EXTENSION_DEFAULT = `-4`;
export const CV_COLUMN_ATTRIBUTE_DEFAULT = `-5`;
export const CV_COLUMN_CRL_DEFAULT = `-6`;
export const CV_COLUMN_LOG_REVOKED_DEFAULT = `-7`;
export const CVRC_TABLE_MASK = 61440;
export const CVRC_TABLE_SHIFT = 12;
export const CRYPT_ENUM_ALL_PROVIDERS = 1;
export const XEPR_ENUM_FIRST = `-1`;
export const XEPR_DATE = 5;
export const XEPR_TEMPLATENAME = 6;
export const XEPR_VERSION = 7;
export const XEPR_V1TEMPLATENAME = 9;
export const XEPR_V2TEMPLATEOID = 16;
export const XEKL_KEYSIZE_DEFAULT = 4;
export const XECP_STRING_PROPERTY = 1;
export const XECI_DISABLE = 0;
export const XECI_XENROLL = 1;
export const XECI_AUTOENROLL = 2;
export const XECI_REQWIZARD = 3;
export const XECI_CERTREQ = 4;
export const wszCMM_PROP_NAME = `Name`;
export const wszCMM_PROP_DESCRIPTION = `Description`;
export const wszCMM_PROP_COPYRIGHT = `Copyright`;
export const wszCMM_PROP_FILEVER = `File Version`;
export const wszCMM_PROP_PRODUCTVER = `Product Version`;
export const wszCMM_PROP_DISPLAY_HWND = `HWND`;
export const wszCMM_PROP_ISMULTITHREADED = `IsMultiThreaded`;
export const CRYPTCAT_VERSION_1 = 256;
export const CRYPTCAT_VERSION_2 = 512;
export const CRYPTCAT_OPEN_ALWAYS = 2;
export const CRYPTCAT_OPEN_CREATENEW = 1;
export const CRYPTCAT_OPEN_EXISTING = 4;
export const CRYPTCAT_OPEN_EXCLUDE_PAGE_HASHES = 65536;
export const CRYPTCAT_OPEN_INCLUDE_PAGE_HASHES = 131072;
export const CRYPTCAT_OPEN_VERIFYSIGHASH = 268435456;
export const CRYPTCAT_OPEN_NO_CONTENT_HCRYPTMSG = 536870912;
export const CRYPTCAT_OPEN_SORTED = 1073741824;
export const CRYPTCAT_OPEN_FLAGS_MASK = 4294901760;
export const CV_COLUMN_LOG_DEFAULT = `-2`;
export const CV_COLUMN_LOG_FAILED_DEFAULT = `-3`;
export const CV_COLUMN_QUEUE_DEFAULT = `-1`;
export const CDR_EXPIRED = 1;
export const CDR_REQUEST_LAST_CHANGED = 2;
export const FR_PROP_NONE = 0;
export const FR_PROP_FULLRESPONSE = 1;
export const FR_PROP_STATUSINFOCOUNT = 2;
export const FR_PROP_BODYPARTSTRING = 3;
export const FR_PROP_STATUS = 4;
export const FR_PROP_STATUSSTRING = 5;
export const FR_PROP_OTHERINFOCHOICE = 6;
export const FR_PROP_FAILINFO = 7;
export const FR_PROP_PENDINFOTOKEN = 8;
export const FR_PROP_PENDINFOTIME = 9;
export const FR_PROP_ISSUEDCERTIFICATEHASH = 10;
export const FR_PROP_ISSUEDCERTIFICATE = 11;
export const FR_PROP_ISSUEDCERTIFICATECHAIN = 12;
export const FR_PROP_ISSUEDCERTIFICATECRLCHAIN = 13;
export const FR_PROP_ENCRYPTEDKEYHASH = 14;
export const FR_PROP_FULLRESPONSENOPKCS7 = 15;
export const FR_PROP_CAEXCHANGECERTIFICATEHASH = 16;
export const FR_PROP_CAEXCHANGECERTIFICATE = 17;
export const FR_PROP_CAEXCHANGECERTIFICATECHAIN = 18;
export const FR_PROP_CAEXCHANGECERTIFICATECRLCHAIN = 19;
export const FR_PROP_ATTESTATIONCHALLENGE = 20;
export const FR_PROP_ATTESTATIONPROVIDERNAME = 21;
export const CVRC_COLUMN_SCHEMA = 0;
export const CVRC_COLUMN_RESULT = 1;
export const CVRC_COLUMN_VALUE = 2;
export const CVRC_COLUMN_MASK = 4095;
export const CR_IN_BASE64HEADER = 0;
export const CR_IN_BASE64 = 1;
export const CR_IN_BINARY = 2;
export const CC_DEFAULTCONFIG = 0;
export const CC_FIRSTCONFIG = 2;
export const CC_LOCALACTIVECONFIG = 4;
export const CC_LOCALCONFIG = 3;
export const CC_UIPICKCONFIG = 1;
export const CC_UIPICKCONFIGSKIPLOCALCA = 5;
export const CV_OUT_BASE64 = 1;
export const CV_OUT_BASE64HEADER = 0;
export const CV_OUT_BASE64REQUESTHEADER = 3;
export const CV_OUT_BASE64X509CRLHEADER = 9;
export const CV_OUT_BINARY = 2;
export const CV_OUT_HEX = 4;
export const CV_OUT_HEXADDR = 10;
export const CV_OUT_HEXASCII = 5;
export const CV_OUT_HEXASCIIADDR = 11;
export const XEPR_CADNS = 1;
export const XEPR_CAFRIENDLYNAME = 3;
export const XEPR_CANAME = 2;
export const XEPR_HASH = 8;
export const XEPR_REQUESTID = 4;
export const CA_ACCESS_ADMIN = 1;
export const CA_ACCESS_AUDITOR = 4;
export const CA_ACCESS_ENROLL = 512;
export const CA_ACCESS_OFFICER = 2;
export const CA_ACCESS_OPERATOR = 8;
export const CA_ACCESS_READ = 256;
export const CR_DISP_DENIED = 2;
export const CR_DISP_ERROR = 1;
export const CR_DISP_INCOMPLETE = 0;
export const CR_DISP_ISSUED = 3;
export const CR_DISP_ISSUED_OUT_OF_BAND = 4;
export const CR_DISP_UNDER_SUBMISSION = 5;
export const XEKL_KEYSIZE_MIN = 1;
export const XEKL_KEYSIZE_MAX = 2;
export const XEKL_KEYSIZE_INC = 3;
export const XECR_CMC = 3;
export const XECR_PKCS10_V1_5 = 4;
export const XECR_PKCS10_V2_0 = 1;
export const XECR_PKCS7 = 2;
export const EXITEVENT_CERTDENIED = 4;
export const EXITEVENT_CERTISSUED = 1;
export const EXITEVENT_CERTPENDING = 2;
export const EXITEVENT_CERTRETRIEVEPENDING = 16;
export const EXITEVENT_CERTREVOKED = 8;
export const EXITEVENT_CRLISSUED = 32;
export const EXITEVENT_SHUTDOWN = 64;
export const XECT_EXTENSION_V1 = 1;
export const XECT_EXTENSION_V2 = 2;
export const CVRC_TABLE_ATTRIBUTES = 16384;
export const CVRC_TABLE_CRL = 20480;
export const CVRC_TABLE_EXTENSIONS = 12288;
export const CVRC_TABLE_REQCERT = 0;
export const PROPTYPE_BINARY = 3;
export const PROPTYPE_DATE = 2;
export const PROPTYPE_LONG = 1;
export const PROPTYPE_STRING = 4;
export const CERT_ALT_NAME_RFC822_NAME = 2;
export const CERT_ALT_NAME_DNS_NAME = 3;
export const CERT_ALT_NAME_URL = 7;
export const CERT_ALT_NAME_REGISTERED_ID = 9;
export const CERT_ALT_NAME_DIRECTORY_NAME = 5;
export const CERT_ALT_NAME_IP_ADDRESS = 8;
export const CERT_ALT_NAME_OTHER_NAME = 1;
export const CSBACKUP_TYPE_FULL = 1;
export const CSBACKUP_TYPE_LOGS_ONLY = 2;
export const XEKL_KEYSPEC_KEYX = 1;
export const XEKL_KEYSPEC_SIG = 2;
export const CR_OUT_BASE64HEADER = 0;
export const CR_OUT_BASE64 = 1;
export const CR_OUT_BINARY = 2;
export const CVR_SEEK_EQ = 1;
export const CVR_SEEK_LE = 4;
export const CVR_SEEK_LT = 2;
export const CVR_SEEK_GE = 8;
export const CVR_SEEK_GT = 16;
export const BCRYPT_CIPHER_OPERATION = 1;
export const BCRYPT_HASH_OPERATION = 2;
export const BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = 4;
export const BCRYPT_SECRET_AGREEMENT_OPERATION = 8;
export const BCRYPT_SIGNATURE_OPERATION = 16;
export const BCRYPT_RNG_OPERATION = 32;
export const NCRYPT_CIPHER_OPERATION = 1;
export const NCRYPT_HASH_OPERATION = 2;
export const NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = 4;
export const NCRYPT_SECRET_AGREEMENT_OPERATION = 8;
export const NCRYPT_SIGNATURE_OPERATION = 16;
export const CERT_FIND_ANY = 0;
export const CERT_FIND_CERT_ID = 1048576;
export const CERT_FIND_CTL_USAGE = 655360;
export const CERT_FIND_ENHKEY_USAGE = 655360;
export const CERT_FIND_EXISTING = 851968;
export const CERT_FIND_HASH = 65536;
export const CERT_FIND_HAS_PRIVATE_KEY = 1376256;
export const CERT_FIND_ISSUER_ATTR = 196612;
export const CERT_FIND_ISSUER_NAME = 131076;
export const CERT_FIND_ISSUER_OF = 786432;
export const CERT_FIND_ISSUER_STR = 524292;
export const CERT_FIND_KEY_IDENTIFIER = 983040;
export const CERT_FIND_KEY_SPEC = 589824;
export const CERT_FIND_MD5_HASH = 262144;
export const CERT_FIND_PROPERTY = 327680;
export const CERT_FIND_PUBLIC_KEY = 393216;
export const CERT_FIND_SHA1_HASH = 65536;
export const CERT_FIND_SIGNATURE_HASH = 917504;
export const CERT_FIND_SUBJECT_ATTR = 196615;
export const CERT_FIND_SUBJECT_CERT = 720896;
export const CERT_FIND_SUBJECT_NAME = 131079;
export const CERT_FIND_SUBJECT_STR = 524295;
export const CERT_FIND_CROSS_CERT_DIST_POINTS = 1114112;
export const CERT_FIND_PUBKEY_MD5_HASH = 1179648;
export const CERT_FIND_SUBJECT_STR_A = 458759;
export const CERT_FIND_SUBJECT_STR_W = 524295;
export const CERT_FIND_ISSUER_STR_A = 458756;
export const CERT_FIND_ISSUER_STR_W = 524292;
export const CERT_FIND_SUBJECT_INFO_ACCESS = 1245184;
export const CERT_FIND_HASH_STR = 1310720;
export const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG = 1;
export const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG = 2;
export const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG = 4;
export const CERT_FIND_NO_ENHKEY_USAGE_FLAG = 8;
export const CERT_FIND_OR_ENHKEY_USAGE_FLAG = 16;
export const CERT_FIND_VALID_ENHKEY_USAGE_FLAG = 32;
export const CERT_FIND_OPTIONAL_CTL_USAGE_FLAG = 1;
export const CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG = 2;
export const CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG = 4;
export const CERT_FIND_NO_CTL_USAGE_FLAG = 8;
export const CERT_FIND_OR_CTL_USAGE_FLAG = 16;
export const CERT_FIND_VALID_CTL_USAGE_FLAG = 32;
export const CERT_QUERY_OBJECT_FILE = 1;
export const CERT_QUERY_OBJECT_BLOB = 2;
export const CERT_QUERY_CONTENT_CERT = 1;
export const CERT_QUERY_CONTENT_CTL = 2;
export const CERT_QUERY_CONTENT_CRL = 3;
export const CERT_QUERY_CONTENT_SERIALIZED_STORE = 4;
export const CERT_QUERY_CONTENT_SERIALIZED_CERT = 5;
export const CERT_QUERY_CONTENT_SERIALIZED_CTL = 6;
export const CERT_QUERY_CONTENT_SERIALIZED_CRL = 7;
export const CERT_QUERY_CONTENT_PKCS7_SIGNED = 8;
export const CERT_QUERY_CONTENT_PKCS7_UNSIGNED = 9;
export const CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED = 10;
export const CERT_QUERY_CONTENT_PKCS10 = 11;
export const CERT_QUERY_CONTENT_PFX = 12;
export const CERT_QUERY_CONTENT_CERT_PAIR = 13;
export const CERT_QUERY_CONTENT_PFX_AND_LOAD = 14;
export const CERT_QUERY_CONTENT_FLAG_CERT = 2;
export const CERT_QUERY_CONTENT_FLAG_CTL = 4;
export const CERT_QUERY_CONTENT_FLAG_CRL = 8;
export const CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE = 16;
export const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT = 32;
export const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL = 64;
export const CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL = 128;
export const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED = 256;
export const CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED = 512;
export const CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED = 1024;
export const CERT_QUERY_CONTENT_FLAG_PKCS10 = 2048;
export const CERT_QUERY_CONTENT_FLAG_PFX = 4096;
export const CERT_QUERY_CONTENT_FLAG_CERT_PAIR = 8192;
export const CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD = 16384;
export const CERT_QUERY_CONTENT_FLAG_ALL = 16382;
export const CERT_QUERY_CONTENT_FLAG_ALL_ISSUER_CERT = 818;
export const CERT_QUERY_FORMAT_BINARY = 1;
export const CERT_QUERY_FORMAT_BASE64_ENCODED = 2;
export const CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED = 3;
export const CERT_QUERY_FORMAT_FLAG_BINARY = 2;
export const CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED = 4;
export const CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED = 8;
export const CERT_QUERY_FORMAT_FLAG_ALL = 14;
export const X509_ASN_ENCODING = 1;
export const PKCS_7_ASN_ENCODING = 65536;
export const CERT_RDN_ANY_TYPE = 0;
export const CERT_RDN_NUMERIC_STRING = 3;
export const CERT_RDN_PRINTABLE_STRING = 4;
export const CERT_RDN_T61_STRING = 5;
export const CERT_RDN_VIDEOTEX_STRING = 6;
export const CERT_RDN_IA5_STRING = 7;
export const CERT_RDN_GRAPHIC_STRING = 8;
export const CERT_RDN_ISO646_STRING = 9;
export const CERT_RDN_GENERAL_STRING = 10;
export const CERT_RDN_INT4_STRING = 11;
export const CERT_RDN_UNICODE_STRING = 12;
export const CERT_RDN_BMP_STRING = 12;
export const CERT_RDN_ENCODED_BLOB = 1;
export const CERT_RDN_OCTET_STRING = 2;
export const CERT_RDN_TELETEX_STRING = 5;
export const CERT_RDN_UNIVERSAL_STRING = 11;
export const CERT_RDN_UTF8_STRING = 13;
export const CERT_RDN_VISIBLE_STRING = 9;
export const CERT_SIMPLE_NAME_STR = 1;
export const CERT_OID_NAME_STR = 2;
export const CERT_X500_NAME_STR = 3;
export const CRYPT_LOCAL = 1;
export const CRYPT_DOMAIN = 2;
export const AT_KEYEXCHANGE = 1;
export const AT_SIGNATURE = 2;
export const CERT_NCRYPT_KEY_SPEC = 4294967295;
export const BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3;
export const BCRYPT_CIPHER_INTERFACE = 1;
export const BCRYPT_HASH_INTERFACE = 2;
export const BCRYPT_RNG_INTERFACE = 6;
export const BCRYPT_SECRET_AGREEMENT_INTERFACE = 4;
export const BCRYPT_SIGNATURE_INTERFACE = 5;
export const NCRYPT_KEY_STORAGE_INTERFACE = 65537;
export const NCRYPT_SCHANNEL_INTERFACE = 65538;
export const NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = 65539;
export const BCRYPT_PAD_NONE = 1;
export const BCRYPT_PAD_OAEP = 4;
export const BCRYPT_PAD_PKCS1 = 2;
export const BCRYPT_PAD_PSS = 8;
export const NCRYPT_SILENT_FLAG = 64;
export const NCRYPT_NO_PADDING_FLAG = 1;
export const NCRYPT_PAD_OAEP_FLAG = 4;
export const NCRYPT_PAD_PKCS1_FLAG = 2;
export const NCRYPT_REGISTER_NOTIFY_FLAG = 1;
export const NCRYPT_UNREGISTER_NOTIFY_FLAG = 2;
export const NCRYPT_MACHINE_KEY_FLAG = 32;
export const NCRYPT_UNPROTECT_NO_DECRYPT = 1;
export const NCRYPT_OVERWRITE_KEY_FLAG = 128;
export const NCRYPT_NO_KEY_VALIDATION = 8;
export const NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = 512;
export const NCRYPT_PAD_PSS_FLAG = 8;
export const NCRYPT_PERSIST_FLAG = 2147483648;
export const NCRYPT_PERSIST_ONLY_FLAG = 1073741824;
export const CRYPT_STRING_BASE64HEADER = 0;
export const CRYPT_STRING_BASE64 = 1;
export const CRYPT_STRING_BINARY = 2;
export const CRYPT_STRING_BASE64REQUESTHEADER = 3;
export const CRYPT_STRING_HEX = 4;
export const CRYPT_STRING_HEXASCII = 5;
export const CRYPT_STRING_BASE64X509CRLHEADER = 9;
export const CRYPT_STRING_HEXADDR = 10;
export const CRYPT_STRING_HEXASCIIADDR = 11;
export const CRYPT_STRING_HEXRAW = 12;
export const CRYPT_STRING_STRICT = 536870912;
export const CRYPT_STRING_BASE64_ANY = 6;
export const CRYPT_STRING_ANY = 7;
export const CRYPT_STRING_HEX_ANY = 8;
export const CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = 2147483648;
export const CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = 1073741824;
export const CRYPT_XML_FLAG_DISABLE_EXTENSIONS = 268435456;
export const CRYPT_XML_FLAG_NO_SERIALIZE = 2147483648;
export const CRYPT_XML_SIGN_ADD_KEYVALUE = 1;
export const CRYPT_ENCODE_ALLOC_FLAG = 32768;
export const CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG = 131072;
export const CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG = 1073741824;
export const CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG = 2147483648;
export const CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG = 536870912;
export const CRYPT_OBJECT_LOCATOR_RELEASE_SYSTEM_SHUTDOWN = 1;
export const CRYPT_OBJECT_LOCATOR_RELEASE_SERVICE_STOP = 2;
export const CRYPT_OBJECT_LOCATOR_RELEASE_PROCESS_EXIT = 3;
export const CRYPT_OBJECT_LOCATOR_RELEASE_DLL_UNLOAD = 4;
export const CRYPT_ACQUIRE_CACHE_FLAG = 1;
export const CRYPT_ACQUIRE_COMPARE_KEY_FLAG = 4;
export const CRYPT_ACQUIRE_NO_HEALING = 8;
export const CRYPT_ACQUIRE_SILENT_FLAG = 64;
export const CRYPT_ACQUIRE_USE_PROV_INFO_FLAG = 2;
export const CRYPT_GET_URL_FROM_PROPERTY = 1;
export const CRYPT_GET_URL_FROM_EXTENSION = 2;
export const CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE = 4;
export const CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE = 8;
export const CERT_STORE_SAVE_AS_PKCS7 = 2;
export const CERT_STORE_SAVE_AS_STORE = 1;
export const CRYPT_ANY = 4;
export const CRYPT_UM = 1;
export const CRYPT_KM = 2;
export const CRYPT_MM = 3;
export const CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG = 1;
export const CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG = 2;
export const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG = 32768;
export const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG = 4;
export const CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG = 8;
export const CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG = 16384;
export const CERT_STORE_CTRL_COMMIT_FORCE_FLAG = 1;
export const CERT_STORE_CTRL_COMMIT_CLEAR_FLAG = 2;
export const CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG = 1;
export const BCRYPT_ALG_HANDLE_HMAC_FLAG = 8;
export const BCRYPT_PROV_DISPATCH = 1;
export const BCRYPT_HASH_REUSABLE_FLAG = 32;
export const CERT_STORE_SAVE_TO_FILE = 1;
export const CERT_STORE_SAVE_TO_FILENAME = 4;
export const CERT_STORE_SAVE_TO_FILENAME_A = 3;
export const CERT_STORE_SAVE_TO_FILENAME_W = 4;
export const CERT_STORE_SAVE_TO_MEMORY = 2;
export const PP_CLIENT_HWND = 1;
export const PP_DELETEKEY = 24;
export const PP_KEYEXCHANGE_ALG = 14;
export const PP_KEYEXCHANGE_PIN = 32;
export const PP_KEYEXCHANGE_KEYSIZE = 12;
export const PP_KEYSET_SEC_DESCR = 8;
export const PP_PIN_PROMPT_STRING = 44;
export const PP_ROOT_CERTSTORE = 46;
export const PP_SIGNATURE_ALG = 15;
export const PP_SIGNATURE_PIN = 33;
export const PP_SIGNATURE_KEYSIZE = 13;
export const PP_UI_PROMPT = 21;
export const PP_USE_HARDWARE_RNG = 38;
export const PP_USER_CERTSTORE = 42;
export const PP_SECURE_KEYEXCHANGE_PIN = 47;
export const PP_SECURE_SIGNATURE_PIN = 48;
export const PP_SMARTCARD_READER = 43;
export const KP_ALGID = 7;
export const KP_CERTIFICATE = 26;
export const KP_PERMISSIONS = 6;
export const KP_SALT = 2;
export const KP_SALT_EX = 10;
export const KP_BLOCKLEN = 8;
export const KP_GET_USE_COUNT = 42;
export const KP_KEYLEN = 9;
export const CRYPT_EXPORTABLE = 1;
export const CRYPT_USER_PROTECTED = 2;
export const CRYPT_ARCHIVABLE = 16384;
export const CRYPT_CREATE_IV = 512;
export const CRYPT_CREATE_SALT = 4;
export const CRYPT_DATA_KEY = 2048;
export const CRYPT_FORCE_KEY_PROTECTION_HIGH = 32768;
export const CRYPT_KEK = 1024;
export const CRYPT_INITIATOR = 64;
export const CRYPT_NO_SALT = 16;
export const CRYPT_ONLINE = 128;
export const CRYPT_PREGEN = 64;
export const CRYPT_RECIPIENT = 16;
export const CRYPT_SF = 256;
export const CRYPT_SGCKEY = 8192;
export const CRYPT_VOLATILE = 4096;
export const CRYPT_MACHINE_KEYSET = 32;
export const CRYPT_USER_KEYSET = 4096;
export const PKCS12_PREFER_CNG_KSP = 256;
export const PKCS12_ALWAYS_CNG_KSP = 512;
export const PKCS12_ALLOW_OVERWRITE_KEY = 16384;
export const PKCS12_NO_PERSIST_KEY = 32768;
export const PKCS12_INCLUDE_EXTENDED_PROPERTIES = 16;
export const CRYPT_OAEP = 64;
export const CRYPT_BLOB_VER3 = 128;
export const CRYPT_DESTROYKEY = 4;
export const CRYPT_SSL2_FALLBACK = 2;
export const CRYPT_Y_ONLY = 1;
export const CRYPT_IPSEC_HMAC_KEY = 256;
export const CERT_SET_KEY_PROV_HANDLE_PROP_ID = 1;
export const CERT_SET_KEY_CONTEXT_PROP_ID = 1;
export const CMSG_DATA = 1;
export const CMSG_SIGNED = 2;
export const CMSG_ENVELOPED = 3;
export const CMSG_SIGNED_AND_ENVELOPED = 4;
export const CMSG_HASHED = 5;
export const CERT_STORE_BACKUP_RESTORE_FLAG = 2048;
export const CERT_STORE_CREATE_NEW_FLAG = 8192;
export const CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 4;
export const CERT_STORE_DELETE_FLAG = 16;
export const CERT_STORE_ENUM_ARCHIVED_FLAG = 512;
export const CERT_STORE_MAXIMUM_ALLOWED_FLAG = 4096;
export const CERT_STORE_NO_CRYPT_RELEASE_FLAG = 1;
export const CERT_STORE_OPEN_EXISTING_FLAG = 16384;
export const CERT_STORE_READONLY_FLAG = 32768;
export const CERT_STORE_SET_LOCALIZED_NAME_FLAG = 2;
export const CERT_STORE_SHARE_CONTEXT_FLAG = 128;
export const CERT_STORE_UPDATE_KEYID_FLAG = 1024;
export const CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG = 1;
export const CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG = 2;
export const CRYPT_VERIFY_CERT_SIGN_DISABLE_MD2_MD4_FLAG = 1;
export const CRYPT_VERIFY_CERT_SIGN_SET_STRONG_PROPERTIES_FLAG = 2;
export const CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG = 4;
export const HP_HMAC_INFO = 5;
export const HP_HASHVAL = 2;
export const CERT_SYSTEM_STORE_LOCATION_MASK = 16711680;
export const CERT_SYSTEM_STORE_RELOCATE_FLAG = 2147483648;
export const CERT_CREATE_SELFSIGN_NO_KEY_INFO = 2;
export const CERT_CREATE_SELFSIGN_NO_SIGN = 1;
export const CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID = 1;
export const CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID = 2;
export const CRYPT_ALL_FUNCTIONS = 1;
export const CRYPT_ALL_PROVIDERS = 2;
export const CTL_FIND_ANY = 0;
export const CTL_FIND_SHA1_HASH = 1;
export const CTL_FIND_MD5_HASH = 2;
export const CTL_FIND_USAGE = 3;
export const CTL_FIND_SAME_USAGE_FLAG = 1;
export const CTL_FIND_EXISTING = 5;
export const CTL_FIND_SUBJECT = 4;
export const CRYPT_FIND_USER_KEYSET_FLAG = 1;
export const CRYPT_FIND_MACHINE_KEYSET_FLAG = 2;
export const CRYPT_FIND_SILENT_KEYSET_FLAG = 64;
export const CRYPT_MIN_DEPENDENCIES = 1;
export const CRYPT_PROCESS_ISOLATE = 65536;
export const CRL_REASON_UNSPECIFIED = 0;
export const CRL_REASON_KEY_COMPROMISE = 1;
export const CRL_REASON_CA_COMPROMISE = 2;
export const CRL_REASON_AFFILIATION_CHANGED = 3;
export const CRL_REASON_SUPERSEDED = 4;
export const CRL_REASON_CESSATION_OF_OPERATION = 5;
export const CRL_REASON_CERTIFICATE_HOLD = 6;
export const CRL_REASON_REMOVE_FROM_CRL = 8;
export const CERT_ROOT_PROGRAM_FLAG_LSC = 64;
export const CERT_ROOT_PROGRAM_FLAG_ORG = 128;
export const CERT_ROOT_PROGRAM_FLAG_SUBJECT_LOGO = 32;
export const CRYPT_XML_KEY_VALUE_TYPE_DSA = 1;
export const CRYPT_XML_KEY_VALUE_TYPE_RSA = 2;
export const CRYPT_XML_KEY_VALUE_TYPE_ECDSA = 3;
export const CRYPT_XML_KEY_VALUE_TYPE_CUSTOM = 4;
export const CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE = 0;
export const CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE = 1;
export const CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = 2;
export const CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE = 1;
export const CMSG_KEY_AGREE_STATIC_KEY_CHOICE = 2;
export const CERT_LOGOTYPE_DIRECT_INFO_CHOICE = 1;
export const CERT_LOGOTYPE_INDIRECT_INFO_CHOICE = 2;
export const CERT_STORE_PROV_EXTERNAL_FLAG = 1;
export const CERT_STORE_PROV_DELETED_FLAG = 2;
export const CERT_STORE_PROV_NO_PERSIST_FLAG = 4;
export const CERT_STORE_PROV_SYSTEM_STORE_FLAG = 8;
export const CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG = 16;
export const CMSG_KEY_AGREE_ORIGINATOR_CERT = 1;
export const CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY = 2;
export const CRYPT_EXCLUSIVE = 1;
export const CRYPT_OVERRIDE = 65536;
export const BCRYPT_DSA_PUBLIC_MAGIC = 1112560452;
export const BCRYPT_DSA_PRIVATE_MAGIC = 1448104772;
export const CRYPT_XML_X509DATA_TYPE_ISSUER_SERIAL = 1;
export const CRYPT_XML_X509DATA_TYPE_SKI = 2;
export const CRYPT_XML_X509DATA_TYPE_SUBJECT_NAME = 3;
export const CRYPT_XML_X509DATA_TYPE_CERTIFICATE = 4;
export const CRYPT_XML_X509DATA_TYPE_CRL = 5;
export const CRYPT_XML_X509DATA_TYPE_CUSTOM = 6;
export const CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE = 1;
export const CERT_BIOMETRIC_OID_DATA_CHOICE = 2;
export const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG = 1;
export const CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG = 2;
export const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG = 4;
export const CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = 7;
export const CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 8;
export const CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = 16;
export const CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = 32;
export const CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = 64;
export const CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = 128;
export const CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG = 256;
export const CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = 512;
export const CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG = 1024;
export const CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG = 2048;
export const CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = 3840;
export const CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = 32768;
export const CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = 16384;
export const CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = 8192;
export const CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG = 4096;
export const CERT_STRONG_SIGN_ENABLE_CRL_CHECK = 1;
export const CERT_STRONG_SIGN_ENABLE_OCSP_CHECK = 2;
export const CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE = 1;
export const CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE = 2;
export const CRYPT_XML_STATUS_INTERNAL_REFERENCE = 1;
export const CRYPT_XML_STATUS_KEY_AVAILABLE = 2;
export const CRYPT_XML_STATUS_DIGESTING = 4;
export const CRYPT_XML_STATUS_DIGEST_VALID = 8;
export const CRYPT_XML_STATUS_SIGNATURE_VALID = 65536;
export const CRYPT_XML_STATUS_OPENED_TO_ENCODE = 2147483648;
export const CRYPT_XML_TRANSFORM_ON_STREAM = 1;
export const CRYPT_XML_TRANSFORM_ON_NODESET = 2;
export const CRYPT_XML_TRANSFORM_URI_QUERY_STRING = 3;
export const CRYPT_XML_GROUP_ID_HASH = 1;
export const CRYPT_XML_GROUP_ID_SIGN = 2;
export const CERT_SELECT_BY_ENHKEY_USAGE = 1;
export const CERT_SELECT_BY_KEY_USAGE = 2;
export const CERT_SELECT_BY_POLICY_OID = 3;
export const CERT_SELECT_BY_PROV_NAME = 4;
export const CERT_SELECT_BY_EXTENSION = 5;
export const CERT_SELECT_BY_SUBJECT_HOST_NAME = 6;
export const CERT_SELECT_BY_ISSUER_ATTR = 7;
export const CERT_SELECT_BY_SUBJECT_ATTR = 8;
export const CERT_SELECT_BY_ISSUER_NAME = 9;
export const CERT_SELECT_BY_PUBLIC_KEY = 10;
export const CERT_SELECT_BY_TLS_SIGNATURES = 11;
export const BCRYPT_RSAPUBLIC_MAGIC = 826364754;
export const BCRYPT_RSAPRIVATE_MAGIC = 843141970;
export const BCRYPT_RSAFULLPRIVATE_MAGIC = 859919186;
export const CRYPT_XML_KEYINFO_TYPE_KEYNAME = 1;
export const CRYPT_XML_KEYINFO_TYPE_KEYVALUE = 2;
export const CRYPT_XML_KEYINFO_TYPE_RETRIEVAL = 3;
export const CRYPT_XML_KEYINFO_TYPE_X509DATA = 4;
export const CRYPT_XML_KEYINFO_TYPE_CUSTOM = 5;
export const TIMESTAMP_VERSION = 1;
export const CERT_ID_ISSUER_SERIAL_NUMBER = 1;
export const CERT_ID_KEY_IDENTIFIER = 2;
export const CERT_ID_SHA1_HASH = 3;
export const AUTHTYPE_CLIENT = 1;
export const AUTHTYPE_SERVER = 2;
export const BCRYPT_DH_PUBLIC_MAGIC = 1112557636;
export const BCRYPT_DH_PRIVATE_MAGIC = 1448101956;
export const CRYPT_XML_STATUS_ERROR_NOT_RESOLVED = 1;
export const CRYPT_XML_STATUS_ERROR_DIGEST_INVALID = 2;
export const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_ALGORITHM = 5;
export const CRYPT_XML_STATUS_ERROR_NOT_SUPPORTED_TRANSFORM = 8;
export const CRYPT_XML_STATUS_ERROR_SIGNATURE_INVALID = 65536;
export const CRYPT_XML_STATUS_ERROR_KEYINFO_NOT_PARSED = 131072;
export const TIMESTAMP_STATUS_GRANTED = 0;
export const TIMESTAMP_STATUS_GRANTED_WITH_MODS = 1;
export const TIMESTAMP_STATUS_REJECTED = 2;
export const TIMESTAMP_STATUS_WAITING = 3;
export const TIMESTAMP_STATUS_REVOCATION_WARNING = 4;
export const TIMESTAMP_STATUS_REVOKED = 5;
export const NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3;
export const NCRYPT_SECRET_AGREEMENT_INTERFACE = 4;
export const NCRYPT_SIGNATURE_INTERFACE = 5;
export const CRYPTUI_WIZ_NO_UI = 1;
export const CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS = 2;
export const CRYPTUI_WIZ_NO_UI_EXCEPT_CSP = 3;
export const CRYPTUI_WIZ_IMPORT_ALLOW_CERT = 131072;
export const CRYPTUI_WIZ_IMPORT_ALLOW_CRL = 262144;
export const CRYPTUI_WIZ_IMPORT_ALLOW_CTL = 524288;
export const CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE = 65536;
export const CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE = 1048576;
export const CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER = 2097152;
export const CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE = 4194304;
export const CRYPTUI_WIZ_EXPORT_PRIVATE_KEY = 256;
export const CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY = 512;
export const CRYPTUI_HIDE_HIERARCHYPAGE = 1;
export const CRYPTUI_HIDE_DETAILPAGE = 2;
export const CRYPTUI_DISABLE_EDITPROPERTIES = 4;
export const CRYPTUI_ENABLE_EDITPROPERTIES = 8;
export const CRYPTUI_DISABLE_ADDTOSTORE = 16;
export const CRYPTUI_ENABLE_ADDTOSTORE = 32;
export const CRYPTUI_ACCEPT_DECLINE_STYLE = 64;
export const CRYPTUI_IGNORE_UNTRUSTED_ROOT = 128;
export const CRYPTUI_DONT_OPEN_STORES = 256;
export const CRYPTUI_ONLY_OPEN_ROOT_STORE = 512;
export const CRYPTUI_WARN_UNTRUSTED_ROOT = 1024;
export const CRYPTUI_ENABLE_REVOCATION_CHECKING = 2048;
export const CRYPTUI_WARN_REMOTE_TRUST = 4096;
export const CRYPTUI_DISABLE_EXPORT = 8192;
export const CRYPTUI_ENABLE_REVOCATION_CHECK_END_CERT = 16384;
export const CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN = 32768;
export const CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = 2048;
export const CRYPTUI_DISABLE_HTMLLINK = 65536;
export const CRYPTUI_DISABLE_ISSUERSTATEMENT = 131072;
export const CRYPTUI_CACHE_ONLY_URL_RETRIEVAL = 262144;
export const CSS_HIDE_PROPERTIES = 1;
export const CSS_ENABLEHOOK = 2;
export const CSS_ALLOWMULTISELECT = 4;
export const CSS_SHOW_HELP = 16;
export const CSS_ENABLETEMPLATE = 32;
export const CSS_ENABLETEMPLATEHANDLE = 64;
export const CRYPTUI_WIZ_IMPORT_SUBJECT_FILE = 1;
export const CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT = 2;
export const CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT = 3;
export const CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT = 4;
export const CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE = 5;
export const CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB = 2;
export const CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE = 1;
export const CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_NONE = 0;
export const CRYPTUI_WIZ_DIGITAL_SIGN_CERT = 1;
export const CRYPTUI_WIZ_DIGITAL_SIGN_STORE = 2;
export const CRYPTUI_WIZ_DIGITAL_SIGN_PVK = 3;
export const CRYPTUI_WIZ_DIGITAL_SIGN_NONE = 0;
export const CRYPTUI_WIZ_EXPORT_CERT_CONTEXT = 1;
export const CRYPTUI_WIZ_EXPORT_CTL_CONTEXT = 2;
export const CRYPTUI_WIZ_EXPORT_CRL_CONTEXT = 3;
export const CRYPTUI_WIZ_EXPORT_CERT_STORE = 4;
export const CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY = 5;
export const CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL = 1;
export const CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL = 2;
export const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE = 1;
export const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV = 2;
export const CM_ENABLEHOOK = 1;
export const CM_SHOW_HELP = 2;
export const CM_SHOW_HELPICON = 4;
export const CM_ENABLETEMPLATE = 8;
export const CM_HIDE_ADVANCEPAGE = 16;
export const CM_HIDE_TRUSTPAGE = 32;
export const CM_NO_NAMECHANGE = 64;
export const CM_NO_EDITTRUST = 128;
export const CM_HIDE_DETAILPAGE = 256;
export const CM_ADD_CERT_STORES = 512;
export const CRYPTUI_WIZ_EXPORT_FORMAT_DER = 1;
export const CRYPTUI_WIZ_EXPORT_FORMAT_PFX = 2;
export const CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7 = 3;
export const CRYPTUI_WIZ_EXPORT_FORMAT_BASE64 = 4;
export const CRYPTUI_WIZ_EXPORT_FORMAT_CRL = 6;
export const CRYPTUI_WIZ_EXPORT_FORMAT_CTL = 7;
export const CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN = 1;
export const CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT = 2;
export const CRYPTUI_WIZ_DIGITAL_SIGN_ADD_NONE = 0;
export const CTL_MODIFY_REQUEST_ADD_TRUSTED = 3;
export const CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED = 1;
export const CTL_MODIFY_REQUEST_REMOVE = 2;
export const CERT_COMPARE_SHIFT = 16;
export const BCRYPT_OBJECT_ALIGNMENT = 16;
export const BCRYPT_KDF_HASH = `HASH`;
export const BCRYPT_KDF_HMAC = `HMAC`;
export const BCRYPT_KDF_TLS_PRF = `TLS_PRF`;
export const BCRYPT_KDF_SP80056A_CONCAT = `SP800_56A_CONCAT`;
export const BCRYPT_KDF_RAW_SECRET = `TRUNCATE`;
export const BCRYPT_KDF_HKDF = `HKDF`;
export const KDF_HASH_ALGORITHM = 0;
export const KDF_SECRET_PREPEND = 1;
export const KDF_SECRET_APPEND = 2;
export const KDF_HMAC_KEY = 3;
export const KDF_TLS_PRF_LABEL = 4;
export const KDF_TLS_PRF_SEED = 5;
export const KDF_SECRET_HANDLE = 6;
export const KDF_TLS_PRF_PROTOCOL = 7;
export const KDF_ALGORITHMID = 8;
export const KDF_PARTYUINFO = 9;
export const KDF_PARTYVINFO = 10;
export const KDF_SUPPPUBINFO = 11;
export const KDF_SUPPPRIVINFO = 12;
export const KDF_LABEL = 13;
export const KDF_CONTEXT = 14;
export const KDF_SALT = 15;
export const KDF_ITERATION_COUNT = 16;
export const KDF_GENERIC_PARAMETER = 17;
export const KDF_KEYBITLENGTH = 18;
export const KDF_HKDF_SALT = 19;
export const KDF_HKDF_INFO = 20;
export const KDF_USE_SECRET_AS_HMAC_KEY_FLAG = 1;
export const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION = 1;
export const BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 1;
export const BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG = 2;
export const BCRYPT_OPAQUE_KEY_BLOB = `OpaqueKeyBlob`;
export const BCRYPT_KEY_DATA_BLOB = `KeyDataBlob`;
export const BCRYPT_AES_WRAP_KEY_BLOB = `Rfc3565KeyWrapBlob`;
export const BCRYPT_OBJECT_LENGTH = `ObjectLength`;
export const BCRYPT_ALGORITHM_NAME = `AlgorithmName`;
export const BCRYPT_PROVIDER_HANDLE = `ProviderHandle`;
export const BCRYPT_CHAINING_MODE = `ChainingMode`;
export const BCRYPT_BLOCK_LENGTH = `BlockLength`;
export const BCRYPT_KEY_LENGTH = `KeyLength`;
export const BCRYPT_KEY_OBJECT_LENGTH = `KeyObjectLength`;
export const BCRYPT_KEY_STRENGTH = `KeyStrength`;
export const BCRYPT_KEY_LENGTHS = `KeyLengths`;
export const BCRYPT_BLOCK_SIZE_LIST = `BlockSizeList`;
export const BCRYPT_EFFECTIVE_KEY_LENGTH = `EffectiveKeyLength`;
export const BCRYPT_HASH_LENGTH = `HashDigestLength`;
export const BCRYPT_HASH_OID_LIST = `HashOIDList`;
export const BCRYPT_PADDING_SCHEMES = `PaddingSchemes`;
export const BCRYPT_SIGNATURE_LENGTH = `SignatureLength`;
export const BCRYPT_HASH_BLOCK_LENGTH = `HashBlockLength`;
export const BCRYPT_AUTH_TAG_LENGTH = `AuthTagLength`;
export const BCRYPT_PRIMITIVE_TYPE = `PrimitiveType`;
export const BCRYPT_IS_KEYED_HASH = `IsKeyedHash`;
export const BCRYPT_IS_REUSABLE_HASH = `IsReusableHash`;
export const BCRYPT_MESSAGE_BLOCK_LENGTH = `MessageBlockLength`;
export const BCRYPT_PUBLIC_KEY_LENGTH = `PublicKeyLength`;
export const BCRYPT_PCP_PLATFORM_TYPE_PROPERTY = `PCP_PLATFORM_TYPE`;
export const BCRYPT_PCP_PROVIDER_VERSION_PROPERTY = `PCP_PROVIDER_VERSION`;
export const BCRYPT_MULTI_OBJECT_LENGTH = `MultiObjectLength`;
export const BCRYPT_IS_IFX_TPM_WEAK_KEY = `IsIfxTpmWeakKey`;
export const BCRYPT_HKDF_HASH_ALGORITHM = `HkdfHashAlgorithm`;
export const BCRYPT_HKDF_SALT_AND_FINALIZE = `HkdfSaltAndFinalize`;
export const BCRYPT_HKDF_PRK_AND_FINALIZE = `HkdfPrkAndFinalize`;
export const BCRYPT_INITIALIZATION_VECTOR = `IV`;
export const BCRYPT_CHAIN_MODE_NA = `ChainingModeN/A`;
export const BCRYPT_CHAIN_MODE_CBC = `ChainingModeCBC`;
export const BCRYPT_CHAIN_MODE_ECB = `ChainingModeECB`;
export const BCRYPT_CHAIN_MODE_CFB = `ChainingModeCFB`;
export const BCRYPT_CHAIN_MODE_CCM = `ChainingModeCCM`;
export const BCRYPT_CHAIN_MODE_GCM = `ChainingModeGCM`;
export const BCRYPT_SUPPORTED_PAD_ROUTER = 1;
export const BCRYPT_SUPPORTED_PAD_PKCS1_ENC = 2;
export const BCRYPT_SUPPORTED_PAD_PKCS1_SIG = 4;
export const BCRYPT_SUPPORTED_PAD_OAEP = 8;
export const BCRYPT_SUPPORTED_PAD_PSS = 16;
export const BCRYPT_BLOCK_PADDING = 1;
export const BCRYPT_GENERATE_IV = 32;
export const BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID = 16;
export const BCRYPTBUFFER_VERSION = 0;
export const BCRYPT_PUBLIC_KEY_BLOB = `PUBLICBLOB`;
export const BCRYPT_PRIVATE_KEY_BLOB = `PRIVATEBLOB`;
export const BCRYPT_RSAPUBLIC_BLOB = `RSAPUBLICBLOB`;
export const BCRYPT_RSAPRIVATE_BLOB = `RSAPRIVATEBLOB`;
export const LEGACY_RSAPUBLIC_BLOB = `CAPIPUBLICBLOB`;
export const LEGACY_RSAPRIVATE_BLOB = `CAPIPRIVATEBLOB`;
export const BCRYPT_RSAFULLPRIVATE_BLOB = `RSAFULLPRIVATEBLOB`;
export const BCRYPT_GLOBAL_PARAMETERS = `SecretAgreementParam`;
export const BCRYPT_PRIVATE_KEY = `PrivKeyVal`;
export const BCRYPT_ECCPUBLIC_BLOB = `ECCPUBLICBLOB`;
export const BCRYPT_ECCPRIVATE_BLOB = `ECCPRIVATEBLOB`;
export const BCRYPT_ECCFULLPUBLIC_BLOB = `ECCFULLPUBLICBLOB`;
export const BCRYPT_ECCFULLPRIVATE_BLOB = `ECCFULLPRIVATEBLOB`;
export const SSL_ECCPUBLIC_BLOB = `SSLECCPUBLICBLOB`;
export const BCRYPT_ECDH_PUBLIC_P256_MAGIC = 827016005;
export const BCRYPT_ECDH_PRIVATE_P256_MAGIC = 843793221;
export const BCRYPT_ECDH_PUBLIC_P384_MAGIC = 860570437;
export const BCRYPT_ECDH_PRIVATE_P384_MAGIC = 877347653;
export const BCRYPT_ECDH_PUBLIC_P521_MAGIC = 894124869;
export const BCRYPT_ECDH_PRIVATE_P521_MAGIC = 910902085;
export const BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC = 1347109701;
export const BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC = 1447772997;
export const BCRYPT_ECDSA_PUBLIC_P256_MAGIC = 827540293;
export const BCRYPT_ECDSA_PRIVATE_P256_MAGIC = 844317509;
export const BCRYPT_ECDSA_PUBLIC_P384_MAGIC = 861094725;
export const BCRYPT_ECDSA_PRIVATE_P384_MAGIC = 877871941;
export const BCRYPT_ECDSA_PUBLIC_P521_MAGIC = 894649157;
export const BCRYPT_ECDSA_PRIVATE_P521_MAGIC = 911426373;
export const BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC = 1346650949;
export const BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC = 1447314245;
export const BCRYPT_ECC_FULLKEY_BLOB_V1 = 1;
export const BCRYPT_DH_PUBLIC_BLOB = `DHPUBLICBLOB`;
export const BCRYPT_DH_PRIVATE_BLOB = `DHPRIVATEBLOB`;
export const LEGACY_DH_PUBLIC_BLOB = `CAPIDHPUBLICBLOB`;
export const LEGACY_DH_PRIVATE_BLOB = `CAPIDHPRIVATEBLOB`;
export const BCRYPT_DH_PARAMETERS = `DHParameters`;
export const BCRYPT_DH_PARAMETERS_MAGIC = 1297107012;
export const BCRYPT_DSA_PUBLIC_BLOB = `DSAPUBLICBLOB`;
export const BCRYPT_DSA_PRIVATE_BLOB = `DSAPRIVATEBLOB`;
export const LEGACY_DSA_PUBLIC_BLOB = `CAPIDSAPUBLICBLOB`;
export const LEGACY_DSA_PRIVATE_BLOB = `CAPIDSAPRIVATEBLOB`;
export const LEGACY_DSA_V2_PUBLIC_BLOB = `V2CAPIDSAPUBLICBLOB`;
export const LEGACY_DSA_V2_PRIVATE_BLOB = `V2CAPIDSAPRIVATEBLOB`;
export const BCRYPT_DSA_PUBLIC_MAGIC_V2 = 843206724;
export const BCRYPT_DSA_PRIVATE_MAGIC_V2 = 844517444;
export const BCRYPT_KEY_DATA_BLOB_MAGIC = 1296188491;
export const BCRYPT_KEY_DATA_BLOB_VERSION1 = 1;
export const BCRYPT_DSA_PARAMETERS = `DSAParameters`;
export const BCRYPT_DSA_PARAMETERS_MAGIC = 1297109828;
export const BCRYPT_DSA_PARAMETERS_MAGIC_V2 = 843927620;
export const BCRYPT_ECC_PARAMETERS = `ECCParameters`;
export const BCRYPT_ECC_CURVE_NAME = `ECCCurveName`;
export const BCRYPT_ECC_CURVE_NAME_LIST = `ECCCurveNameList`;
export const BCRYPT_ECC_PARAMETERS_MAGIC = 1346585413;
export const BCRYPT_ECC_CURVE_BRAINPOOLP160R1 = `brainpoolP160r1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP160T1 = `brainpoolP160t1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP192R1 = `brainpoolP192r1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP192T1 = `brainpoolP192t1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP224R1 = `brainpoolP224r1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP224T1 = `brainpoolP224t1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP256R1 = `brainpoolP256r1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP256T1 = `brainpoolP256t1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP320R1 = `brainpoolP320r1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP320T1 = `brainpoolP320t1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP384R1 = `brainpoolP384r1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP384T1 = `brainpoolP384t1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP512R1 = `brainpoolP512r1`;
export const BCRYPT_ECC_CURVE_BRAINPOOLP512T1 = `brainpoolP512t1`;
export const BCRYPT_ECC_CURVE_25519 = `curve25519`;
export const BCRYPT_ECC_CURVE_EC192WAPI = `ec192wapi`;
export const BCRYPT_ECC_CURVE_NISTP192 = `nistP192`;
export const BCRYPT_ECC_CURVE_NISTP224 = `nistP224`;
export const BCRYPT_ECC_CURVE_NISTP256 = `nistP256`;
export const BCRYPT_ECC_CURVE_NISTP384 = `nistP384`;
export const BCRYPT_ECC_CURVE_NISTP521 = `nistP521`;
export const BCRYPT_ECC_CURVE_NUMSP256T1 = `numsP256t1`;
export const BCRYPT_ECC_CURVE_NUMSP384T1 = `numsP384t1`;
export const BCRYPT_ECC_CURVE_NUMSP512T1 = `numsP512t1`;
export const BCRYPT_ECC_CURVE_SECP160K1 = `secP160k1`;
export const BCRYPT_ECC_CURVE_SECP160R1 = `secP160r1`;
export const BCRYPT_ECC_CURVE_SECP160R2 = `secP160r2`;
export const BCRYPT_ECC_CURVE_SECP192K1 = `secP192k1`;
export const BCRYPT_ECC_CURVE_SECP192R1 = `secP192r1`;
export const BCRYPT_ECC_CURVE_SECP224K1 = `secP224k1`;
export const BCRYPT_ECC_CURVE_SECP224R1 = `secP224r1`;
export const BCRYPT_ECC_CURVE_SECP256K1 = `secP256k1`;
export const BCRYPT_ECC_CURVE_SECP256R1 = `secP256r1`;
export const BCRYPT_ECC_CURVE_SECP384R1 = `secP384r1`;
export const BCRYPT_ECC_CURVE_SECP521R1 = `secP521r1`;
export const BCRYPT_ECC_CURVE_WTLS7 = `wtls7`;
export const BCRYPT_ECC_CURVE_WTLS9 = `wtls9`;
export const BCRYPT_ECC_CURVE_WTLS12 = `wtls12`;
export const BCRYPT_ECC_CURVE_X962P192V1 = `x962P192v1`;
export const BCRYPT_ECC_CURVE_X962P192V2 = `x962P192v2`;
export const BCRYPT_ECC_CURVE_X962P192V3 = `x962P192v3`;
export const BCRYPT_ECC_CURVE_X962P239V1 = `x962P239v1`;
export const BCRYPT_ECC_CURVE_X962P239V2 = `x962P239v2`;
export const BCRYPT_ECC_CURVE_X962P239V3 = `x962P239v3`;
export const BCRYPT_ECC_CURVE_X962P256V1 = `x962P256v1`;
export const MS_PRIMITIVE_PROVIDER = `Microsoft Primitive Provider`;
export const MS_PLATFORM_CRYPTO_PROVIDER = `Microsoft Platform Crypto Provider`;
export const BCRYPT_RSA_ALGORITHM = `RSA`;
export const BCRYPT_RSA_SIGN_ALGORITHM = `RSA_SIGN`;
export const BCRYPT_DH_ALGORITHM = `DH`;
export const BCRYPT_DSA_ALGORITHM = `DSA`;
export const BCRYPT_RC2_ALGORITHM = `RC2`;
export const BCRYPT_RC4_ALGORITHM = `RC4`;
export const BCRYPT_AES_ALGORITHM = `AES`;
export const BCRYPT_DES_ALGORITHM = `DES`;
export const BCRYPT_DESX_ALGORITHM = `DESX`;
export const BCRYPT_3DES_ALGORITHM = `3DES`;
export const BCRYPT_3DES_112_ALGORITHM = `3DES_112`;
export const BCRYPT_MD2_ALGORITHM = `MD2`;
export const BCRYPT_MD4_ALGORITHM = `MD4`;
export const BCRYPT_MD5_ALGORITHM = `MD5`;
export const BCRYPT_SHA1_ALGORITHM = `SHA1`;
export const BCRYPT_SHA256_ALGORITHM = `SHA256`;
export const BCRYPT_SHA384_ALGORITHM = `SHA384`;
export const BCRYPT_SHA512_ALGORITHM = `SHA512`;
export const BCRYPT_AES_GMAC_ALGORITHM = `AES-GMAC`;
export const BCRYPT_AES_CMAC_ALGORITHM = `AES-CMAC`;
export const BCRYPT_ECDSA_P256_ALGORITHM = `ECDSA_P256`;
export const BCRYPT_ECDSA_P384_ALGORITHM = `ECDSA_P384`;
export const BCRYPT_ECDSA_P521_ALGORITHM = `ECDSA_P521`;
export const BCRYPT_ECDH_P256_ALGORITHM = `ECDH_P256`;
export const BCRYPT_ECDH_P384_ALGORITHM = `ECDH_P384`;
export const BCRYPT_ECDH_P521_ALGORITHM = `ECDH_P521`;
export const BCRYPT_RNG_ALGORITHM = `RNG`;
export const BCRYPT_RNG_FIPS186_DSA_ALGORITHM = `FIPS186DSARNG`;
export const BCRYPT_RNG_DUAL_EC_ALGORITHM = `DUALECRNG`;
export const BCRYPT_SP800108_CTR_HMAC_ALGORITHM = `SP800_108_CTR_HMAC`;
export const BCRYPT_SP80056A_CONCAT_ALGORITHM = `SP800_56A_CONCAT`;
export const BCRYPT_PBKDF2_ALGORITHM = `PBKDF2`;
export const BCRYPT_CAPI_KDF_ALGORITHM = `CAPI_KDF`;
export const BCRYPT_TLS1_1_KDF_ALGORITHM = `TLS1_1_KDF`;
export const BCRYPT_TLS1_2_KDF_ALGORITHM = `TLS1_2_KDF`;
export const BCRYPT_ECDSA_ALGORITHM = `ECDSA`;
export const BCRYPT_ECDH_ALGORITHM = `ECDH`;
export const BCRYPT_XTS_AES_ALGORITHM = `XTS-AES`;
export const BCRYPT_HKDF_ALGORITHM = `HKDF`;
export const BCRYPT_CHACHA20_POLY1305_ALGORITHM = `CHACHA20_POLY1305`;
export const BCRYPT_KEY_DERIVATION_INTERFACE = 7;
export const BCRYPT_MD2_ALG_HANDLE = 2216203124737;
export const BCRYPT_MD4_ALG_HANDLE = 19808389169169;
export const BCRYPT_MD5_ALG_HANDLE = 37400575213601;
export const BCRYPT_SHA1_ALG_HANDLE = 57191784513585;
export const BCRYPT_SHA256_ALG_HANDLE = 72584947302465;
export const BCRYPT_SHA384_ALG_HANDLE = 102271761252433;
export const BCRYPT_SHA512_ALG_HANDLE = 107769319391329;
export const BCRYPT_RC4_ALG_HANDLE = 125361505435761;
export const BCRYPT_RNG_ALG_HANDLE = 142953691480193;
export const BCRYPT_HMAC_MD5_ALG_HANDLE = 160545877524625;
export const BCRYPT_HMAC_SHA1_ALG_HANDLE = 178138063569057;
export const BCRYPT_HMAC_SHA256_ALG_HANDLE = 195730249613489;
export const BCRYPT_HMAC_SHA384_ALG_HANDLE = 213322435657921;
export const BCRYPT_HMAC_SHA512_ALG_HANDLE = 230914621702353;
export const BCRYPT_RSA_ALG_HANDLE = 248506807746785;
export const BCRYPT_ECDSA_ALG_HANDLE = 266098993791217;
export const BCRYPT_AES_CMAC_ALG_HANDLE = 283691179835649;
export const BCRYPT_AES_GMAC_ALG_HANDLE = 301283365880081;
export const BCRYPT_HMAC_MD2_ALG_HANDLE = 318875551924513;
export const BCRYPT_HMAC_MD4_ALG_HANDLE = 336467737968945;
export const BCRYPT_3DES_CBC_ALG_HANDLE = 354059924013377;
export const BCRYPT_3DES_ECB_ALG_HANDLE = 371652110057809;
export const BCRYPT_3DES_CFB_ALG_HANDLE = 389244296102241;
export const BCRYPT_3DES_112_CBC_ALG_HANDLE = 406836482146673;
export const BCRYPT_3DES_112_ECB_ALG_HANDLE = 424428668191105;
export const BCRYPT_3DES_112_CFB_ALG_HANDLE = 443120365863313;
export const BCRYPT_AES_CBC_ALG_HANDLE = 459613040279969;
export const BCRYPT_AES_ECB_ALG_HANDLE = 477205226324401;
export const BCRYPT_AES_CFB_ALG_HANDLE = 494797412368833;
export const BCRYPT_AES_CCM_ALG_HANDLE = 915910365807057;
export const BCRYPT_AES_GCM_ALG_HANDLE = 529981784457697;
export const BCRYPT_DES_CBC_ALG_HANDLE = 547573970502129;
export const BCRYPT_DES_ECB_ALG_HANDLE = 565166156546561;
export const BCRYPT_DES_CFB_ALG_HANDLE = 582758342590993;
export const BCRYPT_DESX_CBC_ALG_HANDLE = 600350528635425;
export const BCRYPT_DESX_ECB_ALG_HANDLE = 619042226307633;
export const BCRYPT_DESX_CFB_ALG_HANDLE = 635534900724289;
export const BCRYPT_RC2_CBC_ALG_HANDLE = 653127086768721;
export const BCRYPT_RC2_ECB_ALG_HANDLE = 670719272813153;
export const BCRYPT_RC2_CFB_ALG_HANDLE = 688311458857585;
export const BCRYPT_DH_ALG_HANDLE = 705903644902017;
export const BCRYPT_ECDH_ALG_HANDLE = 731192412340881;
export const BCRYPT_ECDH_P256_ALG_HANDLE = 742187528618657;
export const BCRYPT_ECDH_P384_ALG_HANDLE = 758680203035313;
export const BCRYPT_ECDH_P521_ALG_HANDLE = 776272389079745;
export const BCRYPT_DSA_ALG_HANDLE = 793864575124177;
export const BCRYPT_ECDSA_P256_ALG_HANDLE = 811456761168609;
export const BCRYPT_ECDSA_P384_ALG_HANDLE = 829048947213041;
export const BCRYPT_ECDSA_P521_ALG_HANDLE = 846641133257473;
export const BCRYPT_RSA_SIGN_ALG_HANDLE = 864233319301905;
export const BCRYPT_CAPI_KDF_ALG_HANDLE = 881825505346337;
export const BCRYPT_PBKDF2_ALG_HANDLE = 899417691390769;
export const BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE = 951094737896257;
export const BCRYPT_SP80056A_CONCAT_ALG_HANDLE = 1829604528489297;
export const BCRYPT_TLS1_1_KDF_ALG_HANDLE = 968686923940705;
export const BCRYPT_TLS1_2_KDF_ALG_HANDLE = 986279109985137;
export const BCRYPT_XTS_AES_ALG_HANDLE = 8358795549666706305n;
export const BCRYPT_HKDF_ALG_HANDLE = 1004970807657361;
export const BCRYPT_CHACHA20_POLY1305_ALG_HANDLE = 1022562993701793;
export const BCRYPT_CAPI_AES_FLAG = 16;
export const BCRYPT_MULTI_FLAG = 64;
export const BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG = 4;
export const BCRYPT_BUFFERS_LOCKED_FLAG = 64;
export const BCRYPT_EXTENDED_KEYSIZE = 128;
export const BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS = 256;
export const BCRYPT_KEY_DERIVATION_OPERATION = 64;
export const BCRYPT_PUBLIC_KEY_FLAG = 1;
export const BCRYPT_PRIVATE_KEY_FLAG = 2;
export const BCRYPT_NO_KEY_VALIDATION = 8;
export const BCRYPT_KEY_VALIDATION_RANGE = 16;
export const BCRYPT_KEY_VALIDATION_RANGE_AND_ORDER = 24;
export const BCRYPT_KEY_VALIDATION_REGENERATE = 32;
export const BCRYPT_RNG_USE_ENTROPY_IN_BUFFER = 1;
export const BCRYPT_USE_SYSTEM_PREFERRED_RNG = 2;
export const BCRYPT_HASH_INTERFACE_MAJORVERSION_2 = 2;
export const CRYPT_OVERWRITE = 1;
export const CRYPT_PRIORITY_TOP = 0;
export const CRYPT_PRIORITY_BOTTOM = 4294967295;
export const CRYPT_DEFAULT_CONTEXT = `Default`;
export const wszXMLNS_DIGSIG = `http://www.w3.org/2000/09/xmldsig#`;
export const wszXMLNS_DIGSIG_SignatureProperties = `http://www.w3.org/2000/09/xmldsig#SignatureProperties`;
export const wszXMLNS_DIGSIG_Id = `Id`;
export const wszURI_XMLNS_DIGSIG_BASE64 = `http://www.w3.org/2000/09/xmldsig#base64`;
export const wszURI_XMLNS_DIGSIG_SHA1 = `http://www.w3.org/2000/09/xmldsig#sha1`;
export const wszURI_XMLNS_DIGSIG_SHA256 = `http://www.w3.org/2001/04/xmlenc#sha256`;
export const wszURI_XMLNS_DIGSIG_SHA384 = `http://www.w3.org/2001/04/xmldsig-more#sha384`;
export const wszURI_XMLNS_DIGSIG_SHA512 = `http://www.w3.org/2001/04/xmlenc#sha512`;
export const wszURI_XMLNS_DIGSIG_RSA_SHA1 = `http://www.w3.org/2000/09/xmldsig#rsa-sha1`;
export const wszURI_XMLNS_DIGSIG_DSA_SHA1 = `http://www.w3.org/2000/09/xmldsig#dsa-sha1`;
export const wszURI_XMLNS_DIGSIG_RSA_SHA256 = `http://www.w3.org/2001/04/xmldsig-more#rsa-sha256`;
export const wszURI_XMLNS_DIGSIG_RSA_SHA384 = `http://www.w3.org/2001/04/xmldsig-more#rsa-sha384`;
export const wszURI_XMLNS_DIGSIG_RSA_SHA512 = `http://www.w3.org/2001/04/xmldsig-more#rsa-sha512`;
export const wszURI_XMLNS_DIGSIG_ECDSA_SHA1 = `http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1`;
export const wszURI_XMLNS_DIGSIG_ECDSA_SHA256 = `http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256`;
export const wszURI_XMLNS_DIGSIG_ECDSA_SHA384 = `http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384`;
export const wszURI_XMLNS_DIGSIG_ECDSA_SHA512 = `http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512`;
export const wszURI_XMLNS_DIGSIG_HMAC_SHA1 = `http://www.w3.org/2000/09/xmldsig#hmac-sha1`;
export const wszURI_XMLNS_DIGSIG_HMAC_SHA256 = `http://www.w3.org/2001/04/xmldsig-more#hmac-sha256`;
export const wszURI_XMLNS_DIGSIG_HMAC_SHA384 = `http://www.w3.org/2001/04/xmldsig-more#hmac-sha384`;
export const wszURI_XMLNS_DIGSIG_HMAC_SHA512 = `http://www.w3.org/2001/04/xmldsig-more#hmac-sha512`;
export const wszURI_CANONICALIZATION_C14N = `http://www.w3.org/TR/2001/REC-xml-c14n-20010315`;
export const wszURI_CANONICALIZATION_C14NC = `http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments`;
export const wszURI_CANONICALIZATION_EXSLUSIVE_C14N = `http://www.w3.org/2001/10/xml-exc-c14n#`;
export const wszURI_CANONICALIZATION_EXSLUSIVE_C14NC = `http://www.w3.org/2001/10/xml-exc-c14n#WithComments`;
export const wszURI_TRANSFORM_XPATH = `http://www.w3.org/TR/1999/REC-xpath-19991116`;
export const wszURI_XMLNS_TRANSFORM_BASE64 = `http://www.w3.org/2000/09/xmldsig#base64`;
export const wszURI_XMLNS_TRANSFORM_ENVELOPED = `http://www.w3.org/2000/09/xmldsig#enveloped-signature`;
export const CRYPT_XML_BLOB_MAX = 2147483640;
export const CRYPT_XML_ID_MAX = 256;
export const CRYPT_XML_SIGNATURES_MAX = 16;
export const CRYPT_XML_TRANSFORM_MAX = 16;
export const CRYPT_XML_SIGNATURE_VALUE_MAX = 2048;
export const CRYPT_XML_DIGEST_VALUE_MAX = 128;
export const CRYPT_XML_OBJECTS_MAX = 256;
export const CRYPT_XML_REFERENCES_MAX = 32760;
export const CRYPT_XML_E_BASE = 657808139412381952n;
export const CRYPT_XML_E_LARGE = 657809238924009729n;
export const CRYPT_XML_E_TOO_MANY_TRANSFORMS = 657810338435637506n;
export const CRYPT_XML_E_ENCODING = 657811437947265283n;
export const CRYPT_XML_E_ALGORITHM = 657812537458893060n;
export const CRYPT_XML_E_TRANSFORM = 657813636970520837n;
export const CRYPT_XML_E_HANDLE = 657814736482148614n;
export const CRYPT_XML_E_OPERATION = 657815835993776391n;
export const CRYPT_XML_E_UNRESOLVED_REFERENCE = 657816935505404168n;
export const CRYPT_XML_E_INVALID_DIGEST = 657818035017031945n;
export const CRYPT_XML_E_INVALID_SIGNATURE = 657819134528659722n;
export const CRYPT_XML_E_HASH_FAILED = 657820234040287499n;
export const CRYPT_XML_E_SIGN_FAILED = 657821333551915276n;
export const CRYPT_XML_E_VERIFY_FAILED = 657822433063543053n;
export const CRYPT_XML_E_TOO_MANY_SIGNATURES = 657823532575170830n;
export const CRYPT_XML_E_INVALID_KEYVALUE = 657824632086798607n;
export const CRYPT_XML_E_UNEXPECTED_XML = 657825731598426384n;
export const CRYPT_XML_E_SIGNER = 657826831110054161n;
export const CRYPT_XML_E_NON_UNIQUE_ID = 7998470060790849810n;
export const CRYPT_XML_E_LAST = 7998470060790849810n;
export const CRYPT_XML_FLAG_ALWAYS_RETURN_ENCODED_OBJECT = 1073741824;
export const CRYPT_XML_FLAG_ENFORCE_ID_NCNAME_FORMAT = 536870912;
export const CRYPT_XML_FLAG_ENFORCE_ID_NAME_FORMAT = 134217728;
export const CRYPT_XML_FLAG_ECDSA_DSIG11 = 67108864;
export const CRYPT_XML_STATUS_NO_ERROR = 0;
export const CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY = 1;
export const CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT = 1;
export const CRYPT_XML_DIGEST_REFERENCE_DATA_TRANSFORMED = 1;
export const CRYPT_XML_ALGORITHM_INFO_FIND_BY_URI = 1;
export const CRYPT_XML_ALGORITHM_INFO_FIND_BY_NAME = 2;
export const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_ALGID = 3;
export const CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_SIGN_ALGID = 4;
export const szFORCE_KEY_PROTECTION = `ForceKeyProtection`;
export const dwFORCE_KEY_PROTECTION_DISABLED = 0;
export const dwFORCE_KEY_PROTECTION_USER_SELECT = 1;
export const dwFORCE_KEY_PROTECTION_HIGH = 2;
export const CRYPTPROTECT_PROMPT_ON_UNPROTECT = 1;
export const CRYPTPROTECT_PROMPT_ON_PROTECT = 2;
export const CRYPTPROTECT_PROMPT_RESERVED = 4;
export const CRYPTPROTECT_PROMPT_STRONG = 8;
export const CRYPTPROTECT_PROMPT_REQUIRE_STRONG = 16;
export const CRYPTPROTECT_UI_FORBIDDEN = 1;
export const CRYPTPROTECT_LOCAL_MACHINE = 4;
export const CRYPTPROTECT_CRED_SYNC = 8;
export const CRYPTPROTECT_AUDIT = 16;
export const CRYPTPROTECT_NO_RECOVERY = 32;
export const CRYPTPROTECT_VERIFY_PROTECTION = 64;
export const CRYPTPROTECT_CRED_REGENERATE = 128;
export const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL = 268435455;
export const CRYPTPROTECT_LAST_RESERVED_FLAGVAL = 4294967295;
export const CRYPTPROTECTMEMORY_BLOCK_SIZE = 16;
export const CRYPTPROTECTMEMORY_SAME_PROCESS = 0;
export const CRYPTPROTECTMEMORY_CROSS_PROCESS = 1;
export const CRYPTPROTECTMEMORY_SAME_LOGON = 2;
export const NCRYPT_MAX_KEY_NAME_LENGTH = 512;
export const NCRYPT_MAX_ALG_ID_LENGTH = 512;
export const MS_KEY_STORAGE_PROVIDER = `Microsoft Software Key Storage Provider`;
export const MS_SMART_CARD_KEY_STORAGE_PROVIDER = `Microsoft Smart Card Key Storage Provider`;
export const MS_PLATFORM_KEY_STORAGE_PROVIDER = `Microsoft Platform Crypto Provider`;
export const MS_NGC_KEY_STORAGE_PROVIDER = `Microsoft Passport Key Storage Provider`;
export const TPM_RSA_SRK_SEAL_KEY = `MICROSOFT_PCP_KSP_RSA_SEAL_KEY_3BD1C4BF-004E-4E2F-8A4D-0BF633DCB074`;
export const NCRYPT_RSA_ALGORITHM = `RSA`;
export const NCRYPT_RSA_SIGN_ALGORITHM = `RSA_SIGN`;
export const NCRYPT_DH_ALGORITHM = `DH`;
export const NCRYPT_DSA_ALGORITHM = `DSA`;
export const NCRYPT_MD2_ALGORITHM = `MD2`;
export const NCRYPT_MD4_ALGORITHM = `MD4`;
export const NCRYPT_MD5_ALGORITHM = `MD5`;
export const NCRYPT_SHA1_ALGORITHM = `SHA1`;
export const NCRYPT_SHA256_ALGORITHM = `SHA256`;
export const NCRYPT_SHA384_ALGORITHM = `SHA384`;
export const NCRYPT_SHA512_ALGORITHM = `SHA512`;
export const NCRYPT_ECDSA_P256_ALGORITHM = `ECDSA_P256`;
export const NCRYPT_ECDSA_P384_ALGORITHM = `ECDSA_P384`;
export const NCRYPT_ECDSA_P521_ALGORITHM = `ECDSA_P521`;
export const NCRYPT_ECDH_P256_ALGORITHM = `ECDH_P256`;
export const NCRYPT_ECDH_P384_ALGORITHM = `ECDH_P384`;
export const NCRYPT_ECDH_P521_ALGORITHM = `ECDH_P521`;
export const NCRYPT_AES_ALGORITHM = `AES`;
export const NCRYPT_RC2_ALGORITHM = `RC2`;
export const NCRYPT_3DES_ALGORITHM = `3DES`;
export const NCRYPT_DES_ALGORITHM = `DES`;
export const NCRYPT_DESX_ALGORITHM = `DESX`;
export const NCRYPT_3DES_112_ALGORITHM = `3DES_112`;
export const NCRYPT_SP800108_CTR_HMAC_ALGORITHM = `SP800_108_CTR_HMAC`;
export const NCRYPT_SP80056A_CONCAT_ALGORITHM = `SP800_56A_CONCAT`;
export const NCRYPT_PBKDF2_ALGORITHM = `PBKDF2`;
export const NCRYPT_CAPI_KDF_ALGORITHM = `CAPI_KDF`;
export const NCRYPT_ECDSA_ALGORITHM = `ECDSA`;
export const NCRYPT_ECDH_ALGORITHM = `ECDH`;
export const NCRYPT_KEY_STORAGE_ALGORITHM = `KEY_STORAGE`;
export const NCRYPT_HMAC_SHA256_ALGORITHM = `HMAC-SHA256`;
export const NCRYPT_KEY_DERIVATION_INTERFACE = 7;
export const NCRYPT_KEY_PROTECTION_INTERFACE = 65540;
export const NCRYPT_RSA_ALGORITHM_GROUP = `RSA`;
export const NCRYPT_DH_ALGORITHM_GROUP = `DH`;
export const NCRYPT_DSA_ALGORITHM_GROUP = `DSA`;
export const NCRYPT_ECDSA_ALGORITHM_GROUP = `ECDSA`;
export const NCRYPT_ECDH_ALGORITHM_GROUP = `ECDH`;
export const NCRYPT_AES_ALGORITHM_GROUP = `AES`;
export const NCRYPT_RC2_ALGORITHM_GROUP = `RC2`;
export const NCRYPT_DES_ALGORITHM_GROUP = `DES`;
export const NCRYPT_KEY_DERIVATION_GROUP = `KEY_DERIVATION`;
export const NCRYPTBUFFER_VERSION = 0;
export const NCRYPTBUFFER_EMPTY = 0;
export const NCRYPTBUFFER_DATA = 1;
export const NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING = 3;
export const NCRYPTBUFFER_PROTECTION_FLAGS = 4;
export const NCRYPTBUFFER_SSL_CLIENT_RANDOM = 20;
export const NCRYPTBUFFER_SSL_SERVER_RANDOM = 21;
export const NCRYPTBUFFER_SSL_HIGHEST_VERSION = 22;
export const NCRYPTBUFFER_SSL_CLEAR_KEY = 23;
export const NCRYPTBUFFER_SSL_KEY_ARG_DATA = 24;
export const NCRYPTBUFFER_SSL_SESSION_HASH = 25;
export const NCRYPTBUFFER_PKCS_OID = 40;
export const NCRYPTBUFFER_PKCS_ALG_OID = 41;
export const NCRYPTBUFFER_PKCS_ALG_PARAM = 42;
export const NCRYPTBUFFER_PKCS_ALG_ID = 43;
export const NCRYPTBUFFER_PKCS_ATTRS = 44;
export const NCRYPTBUFFER_PKCS_KEY_NAME = 45;
export const NCRYPTBUFFER_PKCS_SECRET = 46;
export const NCRYPTBUFFER_CERT_BLOB = 47;
export const NCRYPTBUFFER_CLAIM_IDBINDING_NONCE = 48;
export const NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE = 49;
export const NCRYPTBUFFER_KEY_PROPERTY_FLAGS = 50;
export const NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB = 51;
export const NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE = 52;
export const NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED = 53;
export const NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = 54;
export const NCRYPTBUFFER_ECC_CURVE_NAME = 60;
export const NCRYPTBUFFER_ECC_PARAMETERS = 61;
export const NCRYPTBUFFER_TPM_SEAL_PASSWORD = 70;
export const NCRYPTBUFFER_TPM_SEAL_POLICYINFO = 71;
export const NCRYPTBUFFER_TPM_SEAL_TICKET = 72;
export const NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION = 73;
export const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK = 80;
export const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE = 81;
export const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE = 82;
export const NCRYPT_CIPHER_NO_PADDING_FLAG = 0;
export const NCRYPT_CIPHER_BLOCK_PADDING_FLAG = 1;
export const NCRYPT_CIPHER_OTHER_PADDING_FLAG = 2;
export const NCRYPT_PLATFORM_ATTEST_MAGIC = 1146110288;
export const NCRYPT_KEY_ATTEST_MAGIC = 1146110283;
export const NCRYPT_CLAIM_AUTHORITY_ONLY = 1;
export const NCRYPT_CLAIM_SUBJECT_ONLY = 2;
export const NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY = 258;
export const NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = 3;
export const NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT = 4;
export const NCRYPT_CLAIM_UNKNOWN = 4096;
export const NCRYPT_CLAIM_PLATFORM = 65536;
export const NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION = 1;
export const NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY = 2;
export const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 = 0;
export const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION = 0;
export const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0 = 0;
export const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION = 0;
export const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0 = 0;
export const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_CURRENT_VERSION = 0;
export const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 = 0;
export const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION = 0;
export const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 = 0;
export const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION = 0;
export const NCRYPT_PAD_CIPHER_FLAG = 16;
export const NCRYPT_ATTESTATION_FLAG = 32;
export const NCRYPT_SEALING_FLAG = 256;
export const NCRYPT_DO_NOT_FINALIZE_FLAG = 1024;
export const NCRYPT_EXPORT_LEGACY_FLAG = 2048;
export const NCRYPT_IGNORE_DEVICE_STATE_FLAG = 4096;
export const NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG = 8192;
export const NCRYPT_NO_CACHED_PASSWORD = 16384;
export const NCRYPT_PROTECT_TO_LOCAL_SYSTEM = 32768;
export const NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG = 65536;
export const NCRYPT_USE_VIRTUAL_ISOLATION_FLAG = 131072;
export const NCRYPT_USE_PER_BOOT_KEY_FLAG = 262144;
export const NCRYPT_KEY_DERIVATION_OPERATION = 64;
export const NCRYPT_AUTHORITY_KEY_FLAG = 256;
export const NCRYPT_NAME_PROPERTY = `Name`;
export const NCRYPT_UNIQUE_NAME_PROPERTY = `Unique Name`;
export const NCRYPT_ALGORITHM_PROPERTY = `Algorithm Name`;
export const NCRYPT_LENGTH_PROPERTY = `Length`;
export const NCRYPT_LENGTHS_PROPERTY = `Lengths`;
export const NCRYPT_BLOCK_LENGTH_PROPERTY = `Block Length`;
export const NCRYPT_PUBLIC_LENGTH_PROPERTY = `PublicKeyLength`;
export const NCRYPT_SIGNATURE_LENGTH_PROPERTY = `SignatureLength`;
export const NCRYPT_CHAINING_MODE_PROPERTY = `Chaining Mode`;
export const NCRYPT_AUTH_TAG_LENGTH = `AuthTagLength`;
export const NCRYPT_UI_POLICY_PROPERTY = `UI Policy`;
export const NCRYPT_EXPORT_POLICY_PROPERTY = `Export Policy`;
export const NCRYPT_WINDOW_HANDLE_PROPERTY = `HWND Handle`;
export const NCRYPT_USE_CONTEXT_PROPERTY = `Use Context`;
export const NCRYPT_IMPL_TYPE_PROPERTY = `Impl Type`;
export const NCRYPT_KEY_USAGE_PROPERTY = `Key Usage`;
export const NCRYPT_KEY_TYPE_PROPERTY = `Key Type`;
export const NCRYPT_VERSION_PROPERTY = `Version`;
export const NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY = `Security Descr Support`;
export const NCRYPT_SECURITY_DESCR_PROPERTY = `Security Descr`;
export const NCRYPT_USE_COUNT_ENABLED_PROPERTY = `Enabled Use Count`;
export const NCRYPT_USE_COUNT_PROPERTY = `Use Count`;
export const NCRYPT_LAST_MODIFIED_PROPERTY = `Modified`;
export const NCRYPT_MAX_NAME_LENGTH_PROPERTY = `Max Name Length`;
export const NCRYPT_ALGORITHM_GROUP_PROPERTY = `Algorithm Group`;
export const NCRYPT_DH_PARAMETERS_PROPERTY = `DHParameters`;
export const NCRYPT_ECC_PARAMETERS_PROPERTY = `ECCParameters`;
export const NCRYPT_ECC_CURVE_NAME_PROPERTY = `ECCCurveName`;
export const NCRYPT_ECC_CURVE_NAME_LIST_PROPERTY = `ECCCurveNameList`;
export const NCRYPT_USE_VIRTUAL_ISOLATION_PROPERTY = `Virtual Iso`;
export const NCRYPT_USE_PER_BOOT_KEY_PROPERTY = `Per Boot Key`;
export const NCRYPT_PROVIDER_HANDLE_PROPERTY = `Provider Handle`;
export const NCRYPT_PIN_PROPERTY = `SmartCardPin`;
export const NCRYPT_READER_PROPERTY = `SmartCardReader`;
export const NCRYPT_SMARTCARD_GUID_PROPERTY = `SmartCardGuid`;
export const NCRYPT_CERTIFICATE_PROPERTY = `SmartCardKeyCertificate`;
export const NCRYPT_PIN_PROMPT_PROPERTY = `SmartCardPinPrompt`;
export const NCRYPT_USER_CERTSTORE_PROPERTY = `SmartCardUserCertStore`;
export const NCRYPT_ROOT_CERTSTORE_PROPERTY = `SmartcardRootCertStore`;
export const NCRYPT_SECURE_PIN_PROPERTY = `SmartCardSecurePin`;
export const NCRYPT_ASSOCIATED_ECDH_KEY = `SmartCardAssociatedECDHKey`;
export const NCRYPT_SCARD_PIN_ID = `SmartCardPinId`;
export const NCRYPT_SCARD_PIN_INFO = `SmartCardPinInfo`;
export const NCRYPT_READER_ICON_PROPERTY = `SmartCardReaderIcon`;
export const NCRYPT_KDF_SECRET_VALUE = `KDFKeySecret`;
export const NCRYPT_DISMISS_UI_TIMEOUT_SEC_PROPERTY = `SmartCardDismissUITimeoutSeconds`;
export const NCRYPT_PCP_PLATFORM_TYPE_PROPERTY = `PCP_PLATFORM_TYPE`;
export const NCRYPT_PCP_PROVIDER_VERSION_PROPERTY = `PCP_PROVIDER_VERSION`;
export const NCRYPT_PCP_EKPUB_PROPERTY = `PCP_EKPUB`;
export const NCRYPT_PCP_EKCERT_PROPERTY = `PCP_EKCERT`;
export const NCRYPT_PCP_EKNVCERT_PROPERTY = `PCP_EKNVCERT`;
export const NCRYPT_PCP_RSA_EKPUB_PROPERTY = `PCP_RSA_EKPUB`;
export const NCRYPT_PCP_RSA_EKCERT_PROPERTY = `PCP_RSA_EKCERT`;
export const NCRYPT_PCP_RSA_EKNVCERT_PROPERTY = `PCP_RSA_EKNVCERT`;
export const NCRYPT_PCP_ECC_EKPUB_PROPERTY = `PCP_ECC_EKPUB`;
export const NCRYPT_PCP_ECC_EKCERT_PROPERTY = `PCP_ECC_EKCERT`;
export const NCRYPT_PCP_ECC_EKNVCERT_PROPERTY = `PCP_ECC_EKNVCERT`;
export const NCRYPT_PCP_SRKPUB_PROPERTY = `PCP_SRKPUB`;
export const NCRYPT_PCP_PCRTABLE_PROPERTY = `PCP_PCRTABLE`;
export const NCRYPT_PCP_CHANGEPASSWORD_PROPERTY = `PCP_CHANGEPASSWORD`;
export const NCRYPT_PCP_PASSWORD_REQUIRED_PROPERTY = `PCP_PASSWORD_REQUIRED`;
export const NCRYPT_PCP_USAGEAUTH_PROPERTY = `PCP_USAGEAUTH`;
export const NCRYPT_PCP_MIGRATIONPASSWORD_PROPERTY = `PCP_MIGRATIONPASSWORD`;
export const NCRYPT_PCP_EXPORT_ALLOWED_PROPERTY = `PCP_EXPORT_ALLOWED`;
export const NCRYPT_PCP_STORAGEPARENT_PROPERTY = `PCP_STORAGEPARENT`;
export const NCRYPT_PCP_PROVIDERHANDLE_PROPERTY = `PCP_PROVIDERMHANDLE`;
export const NCRYPT_PCP_PLATFORMHANDLE_PROPERTY = `PCP_PLATFORMHANDLE`;
export const NCRYPT_PCP_PLATFORM_BINDING_PCRMASK_PROPERTY = `PCP_PLATFORM_BINDING_PCRMASK`;
export const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGESTLIST_PROPERTY = `PCP_PLATFORM_BINDING_PCRDIGESTLIST`;
export const NCRYPT_PCP_PLATFORM_BINDING_PCRDIGEST_PROPERTY = `PCP_PLATFORM_BINDING_PCRDIGEST`;
export const NCRYPT_PCP_KEY_USAGE_POLICY_PROPERTY = `PCP_KEY_USAGE_POLICY`;
export const NCRYPT_PCP_RSA_SCHEME_PROPERTY = `PCP_RSA_SCHEME`;
export const NCRYPT_PCP_TPM12_IDBINDING_PROPERTY = `PCP_TPM12_IDBINDING`;
export const NCRYPT_PCP_TPM12_IDBINDING_DYNAMIC_PROPERTY = `PCP_TPM12_IDBINDING_DYNAMIC`;
export const NCRYPT_PCP_TPM12_IDACTIVATION_PROPERTY = `PCP_TPM12_IDACTIVATION`;
export const NCRYPT_PCP_KEYATTESTATION_PROPERTY = `PCP_TPM12_KEYATTESTATION`;
export const NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY = `PCP_ALTERNATE_KEY_STORAGE_LOCATION`;
export const NCRYPT_PCP_PLATFORM_BINDING_PCRALGID_PROPERTY = `PCP_PLATFORM_BINDING_PCRALGID`;
export const NCRYPT_PCP_HMAC_AUTH_POLICYREF = `PCP_HMAC_AUTH_POLICYREF`;
export const NCRYPT_PCP_HMAC_AUTH_POLICYINFO = `PCP_HMAC_AUTH_POLICYINFO`;
export const NCRYPT_PCP_HMAC_AUTH_NONCE = `PCP_HMAC_AUTH_NONCE`;
export const NCRYPT_PCP_HMAC_AUTH_SIGNATURE = `PCP_HMAC_AUTH_SIGNATURE`;
export const NCRYPT_PCP_HMAC_AUTH_TICKET = `PCP_HMAC_AUTH_TICKET`;
export const NCRYPT_PCP_NO_DA_PROTECTION_PROPERTY = `PCP_NO_DA_PROTECTION`;
export const NCRYPT_PCP_TPM_MANUFACTURER_ID_PROPERTY = `PCP_TPM_MANUFACTURER_ID`;
export const NCRYPT_PCP_TPM_FW_VERSION_PROPERTY = `PCP_TPM_FW_VERSION`;
export const NCRYPT_PCP_TPM2BNAME_PROPERTY = `PCP_TPM2BNAME`;
export const NCRYPT_PCP_TPM_VERSION_PROPERTY = `PCP_TPM_VERSION`;
export const NCRYPT_PCP_RAW_POLICYDIGEST_PROPERTY = `PCP_RAW_POLICYDIGEST`;
export const NCRYPT_PCP_KEY_CREATIONHASH_PROPERTY = `PCP_KEY_CREATIONHASH`;
export const NCRYPT_PCP_KEY_CREATIONTICKET_PROPERTY = `PCP_KEY_CREATIONTICKET`;
export const NCRYPT_PCP_RSA_SCHEME_HASH_ALG_PROPERTY = `PCP_RSA_SCHEME_HASH_ALG`;
export const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED_PROPERTY = `PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED`;
export const NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY_PROPERTY = `PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY`;
export const IFX_RSA_KEYGEN_VUL_NOT_AFFECTED = 0;
export const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 = 1;
export const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 = 2;
export const NCRYPT_PCP_SESSIONID_PROPERTY = `PCP_SESSIONID`;
export const NCRYPT_PCP_PSS_SALT_SIZE_PROPERTY = `PSS Salt Size`;
export const NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN = 0;
export const NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM = 1;
export const NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE = 2;
export const NCRYPT_PCP_INTERMEDIATE_CA_EKCERT_PROPERTY = `PCP_INTERMEDIATE_CA_EKCERT`;
export const NCRYPT_PCP_PCRTABLE_ALGORITHM_PROPERTY = `PCP_PCRTABLE_ALGORITHM`;
export const NCRYPT_PCP_SYMMETRIC_KEYBITS_PROPERTY = `PCP_SYMMETRIC_KEYBITS`;
export const NCRYPT_TPM_PAD_PSS_IGNORE_SALT = 32;
export const NCRYPT_TPM12_PROVIDER = 65536;
export const NCRYPT_PCP_SIGNATURE_KEY = 1;
export const NCRYPT_PCP_ENCRYPTION_KEY = 2;
export const NCRYPT_PCP_STORAGE_KEY = 4;
export const NCRYPT_PCP_IDENTITY_KEY = 8;
export const NCRYPT_PCP_HMACVERIFICATION_KEY = 16;
export const NCRYPT_SCARD_NGC_KEY_NAME = `SmartCardNgcKeyName`;
export const NCRYPT_INITIALIZATION_VECTOR = `IV`;
export const NCRYPT_CHANGEPASSWORD_PROPERTY = `PCP_CHANGEPASSWORD`;
export const NCRYPT_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY = `PCP_ALTERNATE_KEY_STORAGE_LOCATION`;
export const NCRYPT_KEY_ACCESS_POLICY_PROPERTY = `Key Access Policy`;
export const NCRYPT_MAX_PROPERTY_NAME = 64;
export const NCRYPT_MAX_PROPERTY_DATA = 1048576;
export const NCRYPT_ALLOW_EXPORT_FLAG = 1;
export const NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = 2;
export const NCRYPT_ALLOW_ARCHIVING_FLAG = 4;
export const NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = 8;
export const NCRYPT_IMPL_HARDWARE_FLAG = 1;
export const NCRYPT_IMPL_SOFTWARE_FLAG = 2;
export const NCRYPT_IMPL_REMOVABLE_FLAG = 8;
export const NCRYPT_IMPL_HARDWARE_RNG_FLAG = 16;
export const NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG = 32;
export const NCRYPT_ALLOW_DECRYPT_FLAG = 1;
export const NCRYPT_ALLOW_SIGNING_FLAG = 2;
export const NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = 4;
export const NCRYPT_ALLOW_KEY_IMPORT_FLAG = 8;
export const NCRYPT_ALLOW_ALL_USAGES = 16777215;
export const NCRYPT_UI_PROTECT_KEY_FLAG = 1;
export const NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = 2;
export const NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = 4;
export const NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = 8;
export const NCRYPT_PIN_CACHE_FREE_APPLICATION_TICKET_PROPERTY = `PinCacheFreeApplicationTicket`;
export const NCRYPT_PIN_CACHE_FLAGS_PROPERTY = `PinCacheFlags`;
export const NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG = 1;
export const NCRYPT_PIN_CACHE_APPLICATION_TICKET_PROPERTY = `PinCacheApplicationTicket`;
export const NCRYPT_PIN_CACHE_APPLICATION_IMAGE_PROPERTY = `PinCacheApplicationImage`;
export const NCRYPT_PIN_CACHE_APPLICATION_STATUS_PROPERTY = `PinCacheApplicationStatus`;
export const NCRYPT_PIN_CACHE_PIN_PROPERTY = `PinCachePin`;
export const NCRYPT_PIN_CACHE_IS_GESTURE_REQUIRED_PROPERTY = `PinCacheIsGestureRequired`;
export const NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG = 1;
export const NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH = 90;
export const NCRYPT_PIN_CACHE_CLEAR_PROPERTY = `PinCacheClear`;
export const NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION = 1;
export const NCRYPT_KEY_ACCESS_POLICY_VERSION = 1;
export const NCRYPT_ALLOW_SILENT_KEY_ACCESS = 1;
export const NCRYPT_CIPHER_KEY_BLOB_MAGIC = 1380470851;
export const NCRYPT_KDF_KEY_BLOB_MAGIC = 826688587;
export const NCRYPT_PROTECTED_KEY_BLOB_MAGIC = 1263817296;
export const NCRYPT_CIPHER_KEY_BLOB = `CipherKeyBlob`;
export const NCRYPT_KDF_KEY_BLOB = `KDFKeyBlob`;
export const NCRYPT_PROTECTED_KEY_BLOB = `ProtectedKeyBlob`;
export const NCRYPT_TPM_LOADABLE_KEY_BLOB = `PcpTpmProtectedKeyBlob`;
export const NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC = 1297371211;
export const NCRYPT_PKCS7_ENVELOPE_BLOB = `PKCS7_ENVELOPE`;
export const NCRYPT_PKCS8_PRIVATE_KEY_BLOB = `PKCS8_PRIVATEKEY`;
export const NCRYPT_OPAQUETRANSPORT_BLOB = `OpaqueTransport`;
export const NCRYPT_ISOLATED_KEY_ENVELOPE_BLOB = `ISOLATED_KEY_ENVELOPE`;
export const NCRYPT_DESCR_DELIMITER_OR = `OR`;
export const NCRYPT_DESCR_DELIMITER_AND = `AND`;
export const NCRYPT_DESCR_EQUAL = `=`;
export const MS_KEY_PROTECTION_PROVIDER = `Microsoft Key Protection Provider`;
export const NCRYPT_KEY_PROTECTION_ALGORITHM_SID = `SID`;
export const NCRYPT_KEY_PROTECTION_ALGORITHM_LOCAL = `LOCAL`;
export const NCRYPT_KEY_PROTECTION_LOCAL_LOGON = `logon`;
export const NCRYPT_KEY_PROTECTION_LOCAL_USER = `user`;
export const NCRYPT_KEY_PROTECTION_LOCAL_MACHINE = `machine`;
export const NCRYPT_KEY_PROTECTION_ALGORITHM_SDDL = `SDDL`;
export const NCRYPT_KEY_PROTECTION_ALGORITHM_WEBCREDENTIALS = `WEBCREDENTIALS`;
export const NCRYPT_KEY_PROTECTION_ALGORITHM_LOCKEDCREDENTIALS = `LOCKEDCREDENTIALS`;
export const NCRYPT_KEY_PROTECTION_ALGORITHM_CERTIFICATE = `CERTIFICATE`;
export const NCRYPT_KEY_PROTECTION_CERT_HASHID = `HashId`;
export const NCRYPT_KEY_PROTECTION_CERT_CERTBLOB = `CertBlob`;
export const NCRYPT_NAMED_DESCRIPTOR_FLAG = 1;
export const NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING = 1;
export const ALG_CLASS_ANY = 0;
export const ALG_CLASS_SIGNATURE = 8192;
export const ALG_CLASS_MSG_ENCRYPT = 16384;
export const ALG_CLASS_DATA_ENCRYPT = 24576;
export const ALG_CLASS_HASH = 32768;
export const ALG_CLASS_KEY_EXCHANGE = 40960;
export const ALG_CLASS_ALL = 57344;
export const ALG_TYPE_ANY = 0;
export const ALG_TYPE_DSS = 512;
export const ALG_TYPE_RSA = 1024;
export const ALG_TYPE_BLOCK = 1536;
export const ALG_TYPE_STREAM = 2048;
export const ALG_TYPE_DH = 2560;
export const ALG_TYPE_SECURECHANNEL = 3072;
export const ALG_TYPE_ECDH = 3584;
export const ALG_TYPE_THIRDPARTY = 4096;
export const ALG_SID_ANY = 0;
export const ALG_SID_THIRDPARTY_ANY = 0;
export const ALG_SID_RSA_ANY = 0;
export const ALG_SID_RSA_PKCS = 1;
export const ALG_SID_RSA_MSATWORK = 2;
export const ALG_SID_RSA_ENTRUST = 3;
export const ALG_SID_RSA_PGP = 4;
export const ALG_SID_DSS_ANY = 0;
export const ALG_SID_DSS_PKCS = 1;
export const ALG_SID_DSS_DMS = 2;
export const ALG_SID_ECDSA = 3;
export const ALG_SID_DES = 1;
export const ALG_SID_3DES = 3;
export const ALG_SID_DESX = 4;
export const ALG_SID_IDEA = 5;
export const ALG_SID_CAST = 6;
export const ALG_SID_SAFERSK64 = 7;
export const ALG_SID_SAFERSK128 = 8;
export const ALG_SID_3DES_112 = 9;
export const ALG_SID_CYLINK_MEK = 12;
export const ALG_SID_RC5 = 13;
export const ALG_SID_AES_128 = 14;
export const ALG_SID_AES_192 = 15;
export const ALG_SID_AES_256 = 16;
export const ALG_SID_AES = 17;
export const ALG_SID_SKIPJACK = 10;
export const ALG_SID_TEK = 11;
export const CRYPT_MODE_CBCI = 6;
export const CRYPT_MODE_CFBP = 7;
export const CRYPT_MODE_OFBP = 8;
export const CRYPT_MODE_CBCOFM = 9;
export const CRYPT_MODE_CBCOFMI = 10;
export const ALG_SID_RC2 = 2;
export const ALG_SID_RC4 = 1;
export const ALG_SID_SEAL = 2;
export const ALG_SID_DH_SANDF = 1;
export const ALG_SID_DH_EPHEM = 2;
export const ALG_SID_AGREED_KEY_ANY = 3;
export const ALG_SID_KEA = 4;
export const ALG_SID_ECDH = 5;
export const ALG_SID_ECDH_EPHEM = 6;
export const ALG_SID_MD2 = 1;
export const ALG_SID_MD4 = 2;
export const ALG_SID_MD5 = 3;
export const ALG_SID_SHA = 4;
export const ALG_SID_SHA1 = 4;
export const ALG_SID_MAC = 5;
export const ALG_SID_RIPEMD = 6;
export const ALG_SID_RIPEMD160 = 7;
export const ALG_SID_SSL3SHAMD5 = 8;
export const ALG_SID_HMAC = 9;
export const ALG_SID_TLS1PRF = 10;
export const ALG_SID_HASH_REPLACE_OWF = 11;
export const ALG_SID_SHA_256 = 12;
export const ALG_SID_SHA_384 = 13;
export const ALG_SID_SHA_512 = 14;
export const ALG_SID_SSL3_MASTER = 1;
export const ALG_SID_SCHANNEL_MASTER_HASH = 2;
export const ALG_SID_SCHANNEL_MAC_KEY = 3;
export const ALG_SID_PCT1_MASTER = 4;
export const ALG_SID_SSL2_MASTER = 5;
export const ALG_SID_TLS1_MASTER = 6;
export const ALG_SID_SCHANNEL_ENC_KEY = 7;
export const ALG_SID_ECMQV = 1;
export const ALG_SID_EXAMPLE = 80;
export const SIGNATURE_RESOURCE_NUMBER = 666;
export const CRYPT_VERIFYCONTEXT = 4026531840;
export const CRYPT_NEWKEYSET = 8;
export const CRYPT_DELETEKEYSET = 16;
export const CRYPT_SILENT = 64;
export const CRYPT_DEFAULT_CONTAINER_OPTIONAL = 128;
export const CRYPT_UPDATE_KEY = 8;
export const CRYPT_USER_PROTECTED_STRONG = 1048576;
export const RSA1024BIT_KEY = 67108864;
export const CRYPT_SERVER = 1024;
export const KEY_LENGTH_MASK = 4294901760;
export const CRYPT_DECRYPT_RSA_NO_PADDING_CHECK = 32;
export const CRYPT_SECRETDIGEST = 1;
export const CRYPT_OWF_REPL_LM_HASH = 1;
export const CRYPT_LITTLE_ENDIAN = 1;
export const CRYPT_NOHASHOID = 1;
export const CRYPT_TYPE2_FORMAT = 2;
export const CRYPT_X931_FORMAT = 4;
export const CRYPT_MACHINE_DEFAULT = 1;
export const CRYPT_USER_DEFAULT = 2;
export const CRYPT_DELETE_DEFAULT = 4;
export const SIMPLEBLOB = 1;
export const PUBLICKEYBLOB = 6;
export const PRIVATEKEYBLOB = 7;
export const PLAINTEXTKEYBLOB = 8;
export const OPAQUEKEYBLOB = 9;
export const PUBLICKEYBLOBEX = 10;
export const SYMMETRICWRAPKEYBLOB = 11;
export const KEYSTATEBLOB = 12;
export const CRYPT_USERDATA = 1;
export const KP_IV = 1;
export const KP_PADDING = 3;
export const KP_MODE = 4;
export const KP_MODE_BITS = 5;
export const KP_P = 11;
export const KP_G = 12;
export const KP_Q = 13;
export const KP_X = 14;
export const KP_Y = 15;
export const KP_RA = 16;
export const KP_RB = 17;
export const KP_INFO = 18;
export const KP_EFFECTIVE_KEYLEN = 19;
export const KP_SCHANNEL_ALG = 20;
export const KP_CLIENT_RANDOM = 21;
export const KP_SERVER_RANDOM = 22;
export const KP_RP = 23;
export const KP_PRECOMP_MD5 = 24;
export const KP_PRECOMP_SHA = 25;
export const KP_CLEAR_KEY = 27;
export const KP_PUB_EX_LEN = 28;
export const KP_PUB_EX_VAL = 29;
export const KP_KEYVAL = 30;
export const KP_ADMIN_PIN = 31;
export const KP_KEYEXCHANGE_PIN = 32;
export const KP_SIGNATURE_PIN = 33;
export const KP_PREHASH = 34;
export const KP_ROUNDS = 35;
export const KP_OAEP_PARAMS = 36;
export const KP_CMS_KEY_INFO = 37;
export const KP_CMS_DH_KEY_INFO = 38;
export const KP_PUB_PARAMS = 39;
export const KP_VERIFY_PARAMS = 40;
export const KP_HIGHEST_VERSION = 41;
export const KP_PIN_ID = 43;
export const KP_PIN_INFO = 44;
export const PKCS5_PADDING = 1;
export const RANDOM_PADDING = 2;
export const ZERO_PADDING = 3;
export const CRYPT_MODE_CBC = 1;
export const CRYPT_MODE_ECB = 2;
export const CRYPT_MODE_OFB = 3;
export const CRYPT_MODE_CFB = 4;
export const CRYPT_MODE_CTS = 5;
export const CRYPT_ENCRYPT = 1;
export const CRYPT_DECRYPT = 2;
export const CRYPT_EXPORT = 4;
export const CRYPT_READ = 8;
export const CRYPT_WRITE = 16;
export const CRYPT_MAC = 32;
export const CRYPT_EXPORT_KEY = 64;
export const CRYPT_IMPORT_KEY = 128;
export const CRYPT_ARCHIVE = 256;
export const HP_ALGID = 1;
export const HP_HASHSIZE = 4;
export const HP_TLS1PRF_LABEL = 6;
export const HP_TLS1PRF_SEED = 7;
export const CRYPT_FAILED = 0;
export const CRYPT_SUCCEED = 1;
export const PP_ENUMALGS = 1;
export const PP_ENUMCONTAINERS = 2;
export const PP_IMPTYPE = 3;
export const PP_NAME = 4;
export const PP_VERSION = 5;
export const PP_CONTAINER = 6;
export const PP_CHANGE_PASSWORD = 7;
export const PP_CERTCHAIN = 9;
export const PP_KEY_TYPE_SUBTYPE = 10;
export const PP_PROVTYPE = 16;
export const PP_KEYSTORAGE = 17;
export const PP_APPLI_CERT = 18;
export const PP_SYM_KEYSIZE = 19;
export const PP_SESSION_KEYSIZE = 20;
export const PP_ENUMALGS_EX = 22;
export const PP_ENUMMANDROOTS = 25;
export const PP_ENUMELECTROOTS = 26;
export const PP_KEYSET_TYPE = 27;
export const PP_ADMIN_PIN = 31;
export const PP_SIG_KEYSIZE_INC = 34;
export const PP_KEYX_KEYSIZE_INC = 35;
export const PP_UNIQUE_CONTAINER = 36;
export const PP_SGC_INFO = 37;
export const PP_KEYSPEC = 39;
export const PP_ENUMEX_SIGNING_PROT = 40;
export const PP_CRYPT_COUNT_KEY_USE = 41;
export const PP_SMARTCARD_GUID = 45;
export const PP_SMARTCARD_READER_ICON = 47;
export const CRYPT_FIRST = 1;
export const CRYPT_NEXT = 2;
export const CRYPT_SGC_ENUM = 4;
export const CRYPT_IMPL_HARDWARE = 1;
export const CRYPT_IMPL_SOFTWARE = 2;
export const CRYPT_IMPL_MIXED = 3;
export const CRYPT_IMPL_UNKNOWN = 4;
export const CRYPT_IMPL_REMOVABLE = 8;
export const CRYPT_SEC_DESCR = 1;
export const CRYPT_PSTORE = 2;
export const CRYPT_UI_PROMPT = 4;
export const CRYPT_FLAG_PCT1 = 1;
export const CRYPT_FLAG_SSL2 = 2;
export const CRYPT_FLAG_SSL3 = 4;
export const CRYPT_FLAG_TLS1 = 8;
export const CRYPT_FLAG_IPSEC = 16;
export const CRYPT_FLAG_SIGNING = 32;
export const CRYPT_SGC = 1;
export const CRYPT_FASTSGC = 2;
export const PP_CONTEXT_INFO = 11;
export const PP_DISMISS_PIN_UI_SEC = 49;
export const PROV_RSA_FULL = 1;
export const PROV_RSA_SIG = 2;
export const PROV_DSS = 3;
export const PROV_FORTEZZA = 4;
export const PROV_MS_EXCHANGE = 5;
export const PROV_SSL = 6;
export const PROV_RSA_SCHANNEL = 12;
export const PROV_DSS_DH = 13;
export const PROV_EC_ECDSA_SIG = 14;
export const PROV_EC_ECNRA_SIG = 15;
export const PROV_EC_ECDSA_FULL = 16;
export const PROV_EC_ECNRA_FULL = 17;
export const PROV_DH_SCHANNEL = 18;
export const PROV_SPYRUS_LYNKS = 20;
export const PROV_RNG = 21;
export const PROV_INTEL_SEC = 22;
export const PROV_REPLACE_OWF = 23;
export const PROV_RSA_AES = 24;
export const PROV_STT_MER = 7;
export const PROV_STT_ACQ = 8;
export const PROV_STT_BRND = 9;
export const PROV_STT_ROOT = 10;
export const PROV_STT_ISS = 11;
export const MS_DEF_PROV_A = `Microsoft Base Cryptographic Provider v1.0`;
export const MS_DEF_PROV_W = `Microsoft Base Cryptographic Provider v1.0`;
export const MS_DEF_PROV = `Microsoft Base Cryptographic Provider v1.0`;
export const MS_ENHANCED_PROV_A = `Microsoft Enhanced Cryptographic Provider v1.0`;
export const MS_ENHANCED_PROV_W = `Microsoft Enhanced Cryptographic Provider v1.0`;
export const MS_ENHANCED_PROV = `Microsoft Enhanced Cryptographic Provider v1.0`;
export const MS_STRONG_PROV_A = `Microsoft Strong Cryptographic Provider`;
export const MS_STRONG_PROV_W = `Microsoft Strong Cryptographic Provider`;
export const MS_STRONG_PROV = `Microsoft Strong Cryptographic Provider`;
export const MS_DEF_RSA_SIG_PROV_A = `Microsoft RSA Signature Cryptographic Provider`;
export const MS_DEF_RSA_SIG_PROV_W = `Microsoft RSA Signature Cryptographic Provider`;
export const MS_DEF_RSA_SIG_PROV = `Microsoft RSA Signature Cryptographic Provider`;
export const MS_DEF_RSA_SCHANNEL_PROV_A = `Microsoft RSA SChannel Cryptographic Provider`;
export const MS_DEF_RSA_SCHANNEL_PROV_W = `Microsoft RSA SChannel Cryptographic Provider`;
export const MS_DEF_RSA_SCHANNEL_PROV = `Microsoft RSA SChannel Cryptographic Provider`;
export const MS_DEF_DSS_PROV_A = `Microsoft Base DSS Cryptographic Provider`;
export const MS_DEF_DSS_PROV_W = `Microsoft Base DSS Cryptographic Provider`;
export const MS_DEF_DSS_PROV = `Microsoft Base DSS Cryptographic Provider`;
export const MS_DEF_DSS_DH_PROV_A = `Microsoft Base DSS and Diffie-Hellman Cryptographic Provider`;
export const MS_DEF_DSS_DH_PROV_W = `Microsoft Base DSS and Diffie-Hellman Cryptographic Provider`;
export const MS_DEF_DSS_DH_PROV = `Microsoft Base DSS and Diffie-Hellman Cryptographic Provider`;
export const MS_ENH_DSS_DH_PROV_A = `Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider`;
export const MS_ENH_DSS_DH_PROV_W = `Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider`;
export const MS_ENH_DSS_DH_PROV = `Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider`;
export const MS_DEF_DH_SCHANNEL_PROV_A = `Microsoft DH SChannel Cryptographic Provider`;
export const MS_DEF_DH_SCHANNEL_PROV_W = `Microsoft DH SChannel Cryptographic Provider`;
export const MS_DEF_DH_SCHANNEL_PROV = `Microsoft DH SChannel Cryptographic Provider`;
export const MS_SCARD_PROV_A = `Microsoft Base Smart Card Crypto Provider`;
export const MS_SCARD_PROV_W = `Microsoft Base Smart Card Crypto Provider`;
export const MS_SCARD_PROV = `Microsoft Base Smart Card Crypto Provider`;
export const MS_ENH_RSA_AES_PROV_A = `Microsoft Enhanced RSA and AES Cryptographic Provider`;
export const MS_ENH_RSA_AES_PROV_W = `Microsoft Enhanced RSA and AES Cryptographic Provider`;
export const MS_ENH_RSA_AES_PROV_XP_A = `Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)`;
export const MS_ENH_RSA_AES_PROV_XP_W = `Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)`;
export const MS_ENH_RSA_AES_PROV_XP = `Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)`;
export const MS_ENH_RSA_AES_PROV = `Microsoft Enhanced RSA and AES Cryptographic Provider`;
export const MAXUIDLEN = 64;
export const EXPO_OFFLOAD_REG_VALUE = `ExpoOffload`;
export const EXPO_OFFLOAD_FUNC_NAME = `OffloadModExpo`;
export const szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS = `Software\\Policies\\Microsoft\\Cryptography`;
export const szKEY_CACHE_ENABLED = `CachePrivateKeys`;
export const szKEY_CACHE_SECONDS = `PrivateKeyLifetimeSeconds`;
export const szPRIV_KEY_CACHE_MAX_ITEMS = `PrivKeyCacheMaxItems`;
export const cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT = 20;
export const szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS = `PrivKeyCachePurgeIntervalSeconds`;
export const cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT = 86400;
export const CUR_BLOB_VERSION = 2;
export const SCHANNEL_MAC_KEY = 0;
export const SCHANNEL_ENC_KEY = 1;
export const INTERNATIONAL_USAGE = 1;
export const szOID_RSA = `1.2.840.113549`;
export const szOID_PKCS = `1.2.840.113549.1`;
export const szOID_RSA_HASH = `1.2.840.113549.2`;
export const szOID_RSA_ENCRYPT = `1.2.840.113549.3`;
export const szOID_PKCS_1 = `1.2.840.113549.1.1`;
export const szOID_PKCS_2 = `1.2.840.113549.1.2`;
export const szOID_PKCS_3 = `1.2.840.113549.1.3`;
export const szOID_PKCS_4 = `1.2.840.113549.1.4`;
export const szOID_PKCS_5 = `1.2.840.113549.1.5`;
export const szOID_PKCS_6 = `1.2.840.113549.1.6`;
export const szOID_PKCS_7 = `1.2.840.113549.1.7`;
export const szOID_PKCS_8 = `1.2.840.113549.1.8`;
export const szOID_PKCS_9 = `1.2.840.113549.1.9`;
export const szOID_PKCS_10 = `1.2.840.113549.1.10`;
export const szOID_PKCS_12 = `1.2.840.113549.1.12`;
export const szOID_RSA_RSA = `1.2.840.113549.1.1.1`;
export const szOID_RSA_MD2RSA = `1.2.840.113549.1.1.2`;
export const szOID_RSA_MD4RSA = `1.2.840.113549.1.1.3`;
export const szOID_RSA_MD5RSA = `1.2.840.113549.1.1.4`;
export const szOID_RSA_SHA1RSA = `1.2.840.113549.1.1.5`;
export const szOID_RSA_SETOAEP_RSA = `1.2.840.113549.1.1.6`;
export const szOID_RSAES_OAEP = `1.2.840.113549.1.1.7`;
export const szOID_RSA_MGF1 = `1.2.840.113549.1.1.8`;
export const szOID_RSA_PSPECIFIED = `1.2.840.113549.1.1.9`;
export const szOID_RSA_SSA_PSS = `1.2.840.113549.1.1.10`;
export const szOID_RSA_SHA256RSA = `1.2.840.113549.1.1.11`;
export const szOID_RSA_SHA384RSA = `1.2.840.113549.1.1.12`;
export const szOID_RSA_SHA512RSA = `1.2.840.113549.1.1.13`;
export const szOID_RSA_DH = `1.2.840.113549.1.3.1`;
export const szOID_RSA_data = `1.2.840.113549.1.7.1`;
export const szOID_RSA_signedData = `1.2.840.113549.1.7.2`;
export const szOID_RSA_envelopedData = `1.2.840.113549.1.7.3`;
export const szOID_RSA_signEnvData = `1.2.840.113549.1.7.4`;
export const szOID_RSA_digestedData = `1.2.840.113549.1.7.5`;
export const szOID_RSA_hashedData = `1.2.840.113549.1.7.5`;
export const szOID_RSA_encryptedData = `1.2.840.113549.1.7.6`;
export const szOID_RSA_emailAddr = `1.2.840.113549.1.9.1`;
export const szOID_RSA_unstructName = `1.2.840.113549.1.9.2`;
export const szOID_RSA_contentType = `1.2.840.113549.1.9.3`;
export const szOID_RSA_messageDigest = `1.2.840.113549.1.9.4`;
export const szOID_RSA_signingTime = `1.2.840.113549.1.9.5`;
export const szOID_RSA_counterSign = `1.2.840.113549.1.9.6`;
export const szOID_RSA_challengePwd = `1.2.840.113549.1.9.7`;
export const szOID_RSA_unstructAddr = `1.2.840.113549.1.9.8`;
export const szOID_RSA_extCertAttrs = `1.2.840.113549.1.9.9`;
export const szOID_RSA_certExtensions = `1.2.840.113549.1.9.14`;
export const szOID_RSA_SMIMECapabilities = `1.2.840.113549.1.9.15`;
export const szOID_RSA_preferSignedData = `1.2.840.113549.1.9.15.1`;
export const szOID_TIMESTAMP_TOKEN = `1.2.840.113549.1.9.16.1.4`;
export const szOID_RFC3161_counterSign = `1.3.6.1.4.1.311.3.3.1`;
export const szOID_RSA_SMIMEalg = `1.2.840.113549.1.9.16.3`;
export const szOID_RSA_SMIMEalgESDH = `1.2.840.113549.1.9.16.3.5`;
export const szOID_RSA_SMIMEalgCMS3DESwrap = `1.2.840.113549.1.9.16.3.6`;
export const szOID_RSA_SMIMEalgCMSRC2wrap = `1.2.840.113549.1.9.16.3.7`;
export const szOID_RSA_MD2 = `1.2.840.113549.2.2`;
export const szOID_RSA_MD4 = `1.2.840.113549.2.4`;
export const szOID_RSA_MD5 = `1.2.840.113549.2.5`;
export const szOID_RSA_RC2CBC = `1.2.840.113549.3.2`;
export const szOID_RSA_RC4 = `1.2.840.113549.3.4`;
export const szOID_RSA_DES_EDE3_CBC = `1.2.840.113549.3.7`;
export const szOID_RSA_RC5_CBCPad = `1.2.840.113549.3.9`;
export const szOID_ANSI_X942 = `1.2.840.10046`;
export const szOID_ANSI_X942_DH = `1.2.840.10046.2.1`;
export const szOID_X957 = `1.2.840.10040`;
export const szOID_X957_DSA = `1.2.840.10040.4.1`;
export const szOID_X957_SHA1DSA = `1.2.840.10040.4.3`;
export const szOID_ECC_PUBLIC_KEY = `1.2.840.10045.2.1`;
export const szOID_ECC_CURVE_P256 = `1.2.840.10045.3.1.7`;
export const szOID_ECC_CURVE_P384 = `1.3.132.0.34`;
export const szOID_ECC_CURVE_P521 = `1.3.132.0.35`;
export const szOID_ECC_CURVE_BRAINPOOLP160R1 = `1.3.36.3.3.2.8.1.1.1`;
export const szOID_ECC_CURVE_BRAINPOOLP160T1 = `1.3.36.3.3.2.8.1.1.2`;
export const szOID_ECC_CURVE_BRAINPOOLP192R1 = `1.3.36.3.3.2.8.1.1.3`;
export const szOID_ECC_CURVE_BRAINPOOLP192T1 = `1.3.36.3.3.2.8.1.1.4`;
export const szOID_ECC_CURVE_BRAINPOOLP224R1 = `1.3.36.3.3.2.8.1.1.5`;
export const szOID_ECC_CURVE_BRAINPOOLP224T1 = `1.3.36.3.3.2.8.1.1.6`;
export const szOID_ECC_CURVE_BRAINPOOLP256R1 = `1.3.36.3.3.2.8.1.1.7`;
export const szOID_ECC_CURVE_BRAINPOOLP256T1 = `1.3.36.3.3.2.8.1.1.8`;
export const szOID_ECC_CURVE_BRAINPOOLP320R1 = `1.3.36.3.3.2.8.1.1.9`;
export const szOID_ECC_CURVE_BRAINPOOLP320T1 = `1.3.36.3.3.2.8.1.1.10`;
export const szOID_ECC_CURVE_BRAINPOOLP384R1 = `1.3.36.3.3.2.8.1.1.11`;
export const szOID_ECC_CURVE_BRAINPOOLP384T1 = `1.3.36.3.3.2.8.1.1.12`;
export const szOID_ECC_CURVE_BRAINPOOLP512R1 = `1.3.36.3.3.2.8.1.1.13`;
export const szOID_ECC_CURVE_BRAINPOOLP512T1 = `1.3.36.3.3.2.8.1.1.14`;
export const szOID_ECC_CURVE_EC192WAPI = `1.2.156.11235.1.1.2.1`;
export const szOID_CN_ECDSA_SHA256 = `1.2.156.11235.1.1.1`;
export const szOID_ECC_CURVE_NISTP192 = `1.2.840.10045.3.1.1`;
export const szOID_ECC_CURVE_NISTP224 = `1.3.132.0.33`;
export const szOID_ECC_CURVE_NISTP256 = `1.2.840.10045.3.1.7`;
export const szOID_ECC_CURVE_NISTP384 = `1.3.132.0.34`;
export const szOID_ECC_CURVE_NISTP521 = `1.3.132.0.35`;
export const szOID_ECC_CURVE_SECP160K1 = `1.3.132.0.9`;
export const szOID_ECC_CURVE_SECP160R1 = `1.3.132.0.8`;
export const szOID_ECC_CURVE_SECP160R2 = `1.3.132.0.30`;
export const szOID_ECC_CURVE_SECP192K1 = `1.3.132.0.31`;
export const szOID_ECC_CURVE_SECP192R1 = `1.2.840.10045.3.1.1`;
export const szOID_ECC_CURVE_SECP224K1 = `1.3.132.0.32`;
export const szOID_ECC_CURVE_SECP224R1 = `1.3.132.0.33`;
export const szOID_ECC_CURVE_SECP256K1 = `1.3.132.0.10`;
export const szOID_ECC_CURVE_SECP256R1 = `1.2.840.10045.3.1.7`;
export const szOID_ECC_CURVE_SECP384R1 = `1.3.132.0.34`;
export const szOID_ECC_CURVE_SECP521R1 = `1.3.132.0.35`;
export const szOID_ECC_CURVE_WTLS7 = `1.3.132.0.30`;
export const szOID_ECC_CURVE_WTLS9 = `2.23.43.1.4.9`;
export const szOID_ECC_CURVE_WTLS12 = `1.3.132.0.33`;
export const szOID_ECC_CURVE_X962P192V1 = `1.2.840.10045.3.1.1`;
export const szOID_ECC_CURVE_X962P192V2 = `1.2.840.10045.3.1.2`;
export const szOID_ECC_CURVE_X962P192V3 = `1.2.840.10045.3.1.3`;
export const szOID_ECC_CURVE_X962P239V1 = `1.2.840.10045.3.1.4`;
export const szOID_ECC_CURVE_X962P239V2 = `1.2.840.10045.3.1.5`;
export const szOID_ECC_CURVE_X962P239V3 = `1.2.840.10045.3.1.6`;
export const szOID_ECC_CURVE_X962P256V1 = `1.2.840.10045.3.1.7`;
export const szOID_ECDSA_SHA1 = `1.2.840.10045.4.1`;
export const szOID_ECDSA_SPECIFIED = `1.2.840.10045.4.3`;
export const szOID_ECDSA_SHA256 = `1.2.840.10045.4.3.2`;
export const szOID_ECDSA_SHA384 = `1.2.840.10045.4.3.3`;
export const szOID_ECDSA_SHA512 = `1.2.840.10045.4.3.4`;
export const szOID_NIST_AES128_CBC = `2.16.840.1.101.3.4.1.2`;
export const szOID_NIST_AES192_CBC = `2.16.840.1.101.3.4.1.22`;
export const szOID_NIST_AES256_CBC = `2.16.840.1.101.3.4.1.42`;
export const szOID_NIST_AES128_WRAP = `2.16.840.1.101.3.4.1.5`;
export const szOID_NIST_AES192_WRAP = `2.16.840.1.101.3.4.1.25`;
export const szOID_NIST_AES256_WRAP = `2.16.840.1.101.3.4.1.45`;
export const szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF = `1.3.133.16.840.63.0.2`;
export const szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF = `1.3.132.1.11.1`;
export const szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF = `1.3.132.1.11.2`;
export const szOID_DS = `2.5`;
export const szOID_DSALG = `2.5.8`;
export const szOID_DSALG_CRPT = `2.5.8.1`;
export const szOID_DSALG_HASH = `2.5.8.2`;
export const szOID_DSALG_SIGN = `2.5.8.3`;
export const szOID_DSALG_RSA = `2.5.8.1.1`;
export const szOID_OIW = `1.3.14`;
export const szOID_OIWSEC = `1.3.14.3.2`;
export const szOID_OIWSEC_md4RSA = `1.3.14.3.2.2`;
export const szOID_OIWSEC_md5RSA = `1.3.14.3.2.3`;
export const szOID_OIWSEC_md4RSA2 = `1.3.14.3.2.4`;
export const szOID_OIWSEC_desECB = `1.3.14.3.2.6`;
export const szOID_OIWSEC_desCBC = `1.3.14.3.2.7`;
export const szOID_OIWSEC_desOFB = `1.3.14.3.2.8`;
export const szOID_OIWSEC_desCFB = `1.3.14.3.2.9`;
export const szOID_OIWSEC_desMAC = `1.3.14.3.2.10`;
export const szOID_OIWSEC_rsaSign = `1.3.14.3.2.11`;
export const szOID_OIWSEC_dsa = `1.3.14.3.2.12`;
export const szOID_OIWSEC_shaDSA = `1.3.14.3.2.13`;
export const szOID_OIWSEC_mdc2RSA = `1.3.14.3.2.14`;
export const szOID_OIWSEC_shaRSA = `1.3.14.3.2.15`;
export const szOID_OIWSEC_dhCommMod = `1.3.14.3.2.16`;
export const szOID_OIWSEC_desEDE = `1.3.14.3.2.17`;
export const szOID_OIWSEC_sha = `1.3.14.3.2.18`;
export const szOID_OIWSEC_mdc2 = `1.3.14.3.2.19`;
export const szOID_OIWSEC_dsaComm = `1.3.14.3.2.20`;
export const szOID_OIWSEC_dsaCommSHA = `1.3.14.3.2.21`;
export const szOID_OIWSEC_rsaXchg = `1.3.14.3.2.22`;
export const szOID_OIWSEC_keyHashSeal = `1.3.14.3.2.23`;
export const szOID_OIWSEC_md2RSASign = `1.3.14.3.2.24`;
export const szOID_OIWSEC_md5RSASign = `1.3.14.3.2.25`;
export const szOID_OIWSEC_sha1 = `1.3.14.3.2.26`;
export const szOID_OIWSEC_dsaSHA1 = `1.3.14.3.2.27`;
export const szOID_OIWSEC_dsaCommSHA1 = `1.3.14.3.2.28`;
export const szOID_OIWSEC_sha1RSASign = `1.3.14.3.2.29`;
export const szOID_OIWDIR = `1.3.14.7.2`;
export const szOID_OIWDIR_CRPT = `1.3.14.7.2.1`;
export const szOID_OIWDIR_HASH = `1.3.14.7.2.2`;
export const szOID_OIWDIR_SIGN = `1.3.14.7.2.3`;
export const szOID_OIWDIR_md2 = `1.3.14.7.2.2.1`;
export const szOID_OIWDIR_md2RSA = `1.3.14.7.2.3.1`;
export const szOID_INFOSEC = `2.16.840.1.101.2.1`;
export const szOID_INFOSEC_sdnsSignature = `2.16.840.1.101.2.1.1.1`;
export const szOID_INFOSEC_mosaicSignature = `2.16.840.1.101.2.1.1.2`;
export const szOID_INFOSEC_sdnsConfidentiality = `2.16.840.1.101.2.1.1.3`;
export const szOID_INFOSEC_mosaicConfidentiality = `2.16.840.1.101.2.1.1.4`;
export const szOID_INFOSEC_sdnsIntegrity = `2.16.840.1.101.2.1.1.5`;
export const szOID_INFOSEC_mosaicIntegrity = `2.16.840.1.101.2.1.1.6`;
export const szOID_INFOSEC_sdnsTokenProtection = `2.16.840.1.101.2.1.1.7`;
export const szOID_INFOSEC_mosaicTokenProtection = `2.16.840.1.101.2.1.1.8`;
export const szOID_INFOSEC_sdnsKeyManagement = `2.16.840.1.101.2.1.1.9`;
export const szOID_INFOSEC_mosaicKeyManagement = `2.16.840.1.101.2.1.1.10`;
export const szOID_INFOSEC_sdnsKMandSig = `2.16.840.1.101.2.1.1.11`;
export const szOID_INFOSEC_mosaicKMandSig = `2.16.840.1.101.2.1.1.12`;
export const szOID_INFOSEC_SuiteASignature = `2.16.840.1.101.2.1.1.13`;
export const szOID_INFOSEC_SuiteAConfidentiality = `2.16.840.1.101.2.1.1.14`;
export const szOID_INFOSEC_SuiteAIntegrity = `2.16.840.1.101.2.1.1.15`;
export const szOID_INFOSEC_SuiteATokenProtection = `2.16.840.1.101.2.1.1.16`;
export const szOID_INFOSEC_SuiteAKeyManagement = `2.16.840.1.101.2.1.1.17`;
export const szOID_INFOSEC_SuiteAKMandSig = `2.16.840.1.101.2.1.1.18`;
export const szOID_INFOSEC_mosaicUpdatedSig = `2.16.840.1.101.2.1.1.19`;
export const szOID_INFOSEC_mosaicKMandUpdSig = `2.16.840.1.101.2.1.1.20`;
export const szOID_INFOSEC_mosaicUpdatedInteg = `2.16.840.1.101.2.1.1.21`;
export const szOID_NIST_sha256 = `2.16.840.1.101.3.4.2.1`;
export const szOID_NIST_sha384 = `2.16.840.1.101.3.4.2.2`;
export const szOID_NIST_sha512 = `2.16.840.1.101.3.4.2.3`;
export const szOID_COMMON_NAME = `2.5.4.3`;
export const szOID_SUR_NAME = `2.5.4.4`;
export const szOID_DEVICE_SERIAL_NUMBER = `2.5.4.5`;
export const szOID_COUNTRY_NAME = `2.5.4.6`;
export const szOID_LOCALITY_NAME = `2.5.4.7`;
export const szOID_STATE_OR_PROVINCE_NAME = `2.5.4.8`;
export const szOID_STREET_ADDRESS = `2.5.4.9`;
export const szOID_ORGANIZATION_NAME = `2.5.4.10`;
export const szOID_ORGANIZATIONAL_UNIT_NAME = `2.5.4.11`;
export const szOID_TITLE = `2.5.4.12`;
export const szOID_DESCRIPTION = `2.5.4.13`;
export const szOID_SEARCH_GUIDE = `2.5.4.14`;
export const szOID_BUSINESS_CATEGORY = `2.5.4.15`;
export const szOID_POSTAL_ADDRESS = `2.5.4.16`;
export const szOID_POSTAL_CODE = `2.5.4.17`;
export const szOID_POST_OFFICE_BOX = `2.5.4.18`;
export const szOID_PHYSICAL_DELIVERY_OFFICE_NAME = `2.5.4.19`;
export const szOID_TELEPHONE_NUMBER = `2.5.4.20`;
export const szOID_TELEX_NUMBER = `2.5.4.21`;
export const szOID_TELETEXT_TERMINAL_IDENTIFIER = `2.5.4.22`;
export const szOID_FACSIMILE_TELEPHONE_NUMBER = `2.5.4.23`;
export const szOID_X21_ADDRESS = `2.5.4.24`;
export const szOID_INTERNATIONAL_ISDN_NUMBER = `2.5.4.25`;
export const szOID_REGISTERED_ADDRESS = `2.5.4.26`;
export const szOID_DESTINATION_INDICATOR = `2.5.4.27`;
export const szOID_PREFERRED_DELIVERY_METHOD = `2.5.4.28`;
export const szOID_PRESENTATION_ADDRESS = `2.5.4.29`;
export const szOID_SUPPORTED_APPLICATION_CONTEXT = `2.5.4.30`;
export const szOID_MEMBER = `2.5.4.31`;
export const szOID_OWNER = `2.5.4.32`;
export const szOID_ROLE_OCCUPANT = `2.5.4.33`;
export const szOID_SEE_ALSO = `2.5.4.34`;
export const szOID_USER_PASSWORD = `2.5.4.35`;
export const szOID_USER_CERTIFICATE = `2.5.4.36`;
export const szOID_CA_CERTIFICATE = `2.5.4.37`;
export const szOID_AUTHORITY_REVOCATION_LIST = `2.5.4.38`;
export const szOID_CERTIFICATE_REVOCATION_LIST = `2.5.4.39`;
export const szOID_CROSS_CERTIFICATE_PAIR = `2.5.4.40`;
export const szOID_GIVEN_NAME = `2.5.4.42`;
export const szOID_INITIALS = `2.5.4.43`;
export const szOID_DN_QUALIFIER = `2.5.4.46`;
export const szOID_DOMAIN_COMPONENT = `0.9.2342.19200300.100.1.25`;
export const szOID_PKCS_12_FRIENDLY_NAME_ATTR = `1.2.840.113549.1.9.20`;
export const szOID_PKCS_12_LOCAL_KEY_ID = `1.2.840.113549.1.9.21`;
export const szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR = `1.3.6.1.4.1.311.17.1`;
export const szOID_LOCAL_MACHINE_KEYSET = `1.3.6.1.4.1.311.17.2`;
export const szOID_PKCS_12_EXTENDED_ATTRIBUTES = `1.3.6.1.4.1.311.17.3`;
export const szOID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID = `1.3.6.1.4.1.311.17.4`;
export const szOID_KEYID_RDN = `1.3.6.1.4.1.311.10.7.1`;
export const szOID_EV_RDN_LOCALE = `1.3.6.1.4.1.311.60.2.1.1`;
export const szOID_EV_RDN_STATE_OR_PROVINCE = `1.3.6.1.4.1.311.60.2.1.2`;
export const szOID_EV_RDN_COUNTRY = `1.3.6.1.4.1.311.60.2.1.3`;
export const CERT_RDN_TYPE_MASK = 255;
export const CERT_RDN_FLAGS_MASK = 4278190080;
export const CERT_RDN_ENABLE_T61_UNICODE_FLAG = 2147483648;
export const CERT_RDN_ENABLE_UTF8_UNICODE_FLAG = 536870912;
export const CERT_RDN_FORCE_UTF8_UNICODE_FLAG = 268435456;
export const CERT_RDN_DISABLE_CHECK_TYPE_FLAG = 1073741824;
export const CERT_RDN_DISABLE_IE4_UTF8_FLAG = 16777216;
export const CERT_RDN_ENABLE_PUNYCODE_FLAG = 33554432;
export const CERT_RSA_PUBLIC_KEY_OBJID = `1.2.840.113549.1.1.1`;
export const CERT_DEFAULT_OID_PUBLIC_KEY_SIGN = `1.2.840.113549.1.1.1`;
export const CERT_DEFAULT_OID_PUBLIC_KEY_XCHG = `1.2.840.113549.1.1.1`;
export const CRYPT_ECC_PRIVATE_KEY_INFO_v1 = 1;
export const CERT_V1 = 0;
export const CERT_V2 = 1;
export const CERT_V3 = 2;
export const CERT_INFO_VERSION_FLAG = 1;
export const CERT_INFO_SERIAL_NUMBER_FLAG = 2;
export const CERT_INFO_SIGNATURE_ALGORITHM_FLAG = 3;
export const CERT_INFO_ISSUER_FLAG = 4;
export const CERT_INFO_NOT_BEFORE_FLAG = 5;
export const CERT_INFO_NOT_AFTER_FLAG = 6;
export const CERT_INFO_SUBJECT_FLAG = 7;
export const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG = 8;
export const CERT_INFO_ISSUER_UNIQUE_ID_FLAG = 9;
export const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG = 10;
export const CERT_INFO_EXTENSION_FLAG = 11;
export const CRL_V1 = 0;
export const CRL_V2 = 1;
export const CERT_BUNDLE_CERTIFICATE = 0;
export const CERT_BUNDLE_CRL = 1;
export const CERT_REQUEST_V1 = 0;
export const CERT_KEYGEN_REQUEST_V1 = 0;
export const CTL_V1 = 0;
export const CERT_ENCODING_TYPE_MASK = 65535;
export const CMSG_ENCODING_TYPE_MASK = 4294901760;
export const CRYPT_ASN_ENCODING = 1;
export const CRYPT_NDR_ENCODING = 2;
export const X509_NDR_ENCODING = 2;
export const PKCS_7_NDR_ENCODING = 131072;
export const CRYPT_FORMAT_STR_MULTI_LINE = 1;
export const CRYPT_FORMAT_STR_NO_HEX = 16;
export const CRYPT_FORMAT_SIMPLE = 1;
export const CRYPT_FORMAT_X509 = 2;
export const CRYPT_FORMAT_OID = 4;
export const CRYPT_FORMAT_RDN_SEMICOLON = 256;
export const CRYPT_FORMAT_RDN_CRLF = 512;
export const CRYPT_FORMAT_RDN_UNQUOTE = 1024;
export const CRYPT_FORMAT_RDN_REVERSE = 2048;
export const CRYPT_FORMAT_COMMA = 4096;
export const CRYPT_FORMAT_SEMICOLON = 256;
export const CRYPT_FORMAT_CRLF = 512;
export const CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = 8;
export const CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG = 268435456;
export const CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = 65536;
export const CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG = 262144;
export const CRYPT_DECODE_NOCOPY_FLAG = 1;
export const CRYPT_DECODE_TO_BE_SIGNED_FLAG = 2;
export const CRYPT_DECODE_SHARE_OID_STRING_FLAG = 4;
export const CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = 8;
export const CRYPT_DECODE_ALLOC_FLAG = 32768;
export const CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG = 16777216;
export const CRYPT_DECODE_ENABLE_PUNYCODE_FLAG = 33554432;
export const CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG = 67108864;
export const CRYPT_ENCODE_DECODE_NONE = 0;
export const X509_CERT = 2216203124737;
export const X509_CERT_TO_BE_SIGNED = 4415226380290;
export const X509_CERT_CRL_TO_BE_SIGNED = 5514738008067;
export const X509_CERT_REQUEST_TO_BE_SIGNED = 1518001159355236356n;
export const X509_EXTENSIONS = 6614249635845;
export const X509_NAME_VALUE = 7713761263622;
export const X509_NAME = 290488781625098247n;
export const X509_PUBLIC_KEY_INFO = 16509854285832;
export const X509_AUTHORITY_KEY_ID = 13211319402505;
export const X509_KEY_ATTRIBUTES = 12111807774730;
export const X509_KEY_USAGE_RESTRICTION = 1147907319267339;
export const X509_ALTERNATE_NAME = 14310831030284;
export const X509_BASIC_CONSTRAINTS = 15410342658061;
export const X509_KEY_USAGE = 11012296146958;
export const X509_BASIC_CONSTRAINTS2 = 1806231535506948111n;
export const X509_CERT_POLICIES = 70385924046864;
export const PKCS_UTC_TIME = 19808389169169;
export const PKCS_TIME_REQUEST = 20907900796946;
export const RSA_CSP_PUBLICKEYBLOB = 28604482191379;
export const X509_UNICODE_NAME = 23106924052500;
export const X509_KEYGEN_REQUEST_TO_BE_SIGNED = 24206435680277;
export const PKCS_ATTRIBUTE = 25305947308054;
export const PKCS_CONTENT_INFO_SEQUENCE_OF_ANY = 26405458935831;
export const X509_UNICODE_NAME_VALUE = 33002528702488;
export const X509_ANY_STRING = 6;
export const X509_UNICODE_ANY_STRING = 24;
export const X509_OCTET_STRING = 4785091783950361;
export const X509_BITS = 29703993819162;
export const X509_INTEGER = 30803505446939;
export const X509_MULTI_BYTE_INTEGER = 31903017074716;
export const X509_ENUMERATED = 39599598469149;
export const X509_CHOICE_OF_TIME = 34102040330270;
export const X509_AUTHORITY_KEY_ID2 = 54992761258015;
export const X509_AUTHORITY_INFO_ACCESS = 36301063585824;
export const X509_SUBJECT_INFO_ACCESS = 32;
export const X509_CRL_REASON_CODE = 29;
export const PKCS_CONTENT_INFO = 37400575213601;
export const X509_SEQUENCE_OF_ANY = 38500086841378;
export const X509_CRL_DIST_POINTS = 17609365913635;
export const X509_ENHANCED_KEY_USAGE = 40699110096932;
export const PKCS_CTL = 41798621724709;
export const X509_MULTI_BYTE_UINT = 42898133352486;
export const X509_DSS_PUBLICKEY = 38;
export const X509_DSS_PARAMETERS = 43997644980263;
export const X509_DSS_SIGNATURE = 45097156608040;
export const PKCS_RC2_CBC_PARAMETERS = 46196668235817;
export const PKCS_SMIME_CAPABILITIES = 47296179863594;
export const X509_QC_STATEMENTS_EXT = 47296179863594;
export const PKCS_RSA_PRIVATE_KEY = 48395691491371;
export const PKCS_PRIVATE_KEY_INFO = 49495203119148;
export const PKCS_ENCRYPTED_PRIVATE_KEY_INFO = 1099528807645229;
export const X509_PKIX_POLICY_QUALIFIER_USERNOTICE = 51694226374702;
export const X509_DH_PUBLICKEY = 38;
export const X509_DH_PARAMETERS = 53893249630255;
export const PKCS_ATTRIBUTES = 2305843026393563184n;
export const PKCS_SORTED_CTL = 57191784513585;
export const X509_ECC_SIGNATURE = 53893249630255;
export const X942_DH_PARAMETERS = 56092272885810;
export const X509_BITS_WITHOUT_TRAILING_ZEROES = 109968342646835;
export const X942_OTHER_INFO = 58291296141364;
export const X509_CERT_PAIR = 59390807769141;
export const X509_ISSUING_DIST_POINT = 60490319396918;
export const X509_NAME_CONSTRAINTS = 61589831024695;
export const X509_POLICY_MAPPINGS = 62689342652472;
export const X509_POLICY_CONSTRAINTS = 63788854280249;
export const X509_CROSS_CERT_DIST_POINTS = 64888365908026;
export const CMC_DATA = 65987877535803;
export const CMC_RESPONSE = 648519531752325180n;
export const CMC_STATUS = 68186900791357;
export const CMC_ADD_EXTENSIONS = 90177133346878;
export const CMC_ADD_ATTRIBUTES = 18410715293870456895n;
export const X509_CERTIFICATE_TEMPLATE = 140754668224576;
export const OCSP_SIGNED_REQUEST = 72584947302465;
export const OCSP_REQUEST = 73684458930242;
export const OCSP_RESPONSE = 74783970558019;
export const OCSP_BASIC_SIGNED_RESPONSE = 75883482185796;
export const OCSP_BASIC_RESPONSE = 76982993813573;
export const X509_LOGOTYPE_EXT = 78082505441350;
export const X509_BIOMETRIC_EXT = 3315714752583;
export const CNG_RSA_PUBLIC_KEY_BLOB = 83580063580232;
export const X509_OBJECT_IDENTIFIER = 81381040324681;
export const X509_ALGORITHM_IDENTIFIER = 82480551952458;
export const PKCS_RSA_SSA_PSS_PARAMETERS = 84679575208011;
export const PKCS_RSAES_OAEP_PARAMETERS = 92376156602444;
export const ECC_CMS_SHARED_INFO = 85779086835789;
export const TIMESTAMP_REQUEST = 86878598463566;
export const TIMESTAMP_RESPONSE = 98973226369103;
export const TIMESTAMP_INFO = 52793738002512;
export const X509_CERT_BUNDLE = 102271761252433;
export const X509_ECC_PRIVATE_KEY = 91276644974674;
export const CNG_RSA_PRIVATE_KEY_BLOB = 93475668230227;
export const X509_SUBJECT_DIR_ATTRS = 175939040313428;
export const X509_ECC_PARAMETERS = 95674691485781;
export const PKCS7_SIGNER_INFO = 551972017013236;
export const CMS_SIGNER_INFO = 553071528641013;
export const szOID_AUTHORITY_KEY_IDENTIFIER = `2.5.29.1`;
export const szOID_KEY_ATTRIBUTES = `2.5.29.2`;
export const szOID_CERT_POLICIES_95 = `2.5.29.3`;
export const szOID_KEY_USAGE_RESTRICTION = `2.5.29.4`;
export const szOID_SUBJECT_ALT_NAME = `2.5.29.7`;
export const szOID_ISSUER_ALT_NAME = `2.5.29.8`;
export const szOID_BASIC_CONSTRAINTS = `2.5.29.10`;
export const szOID_KEY_USAGE = `2.5.29.15`;
export const szOID_PRIVATEKEY_USAGE_PERIOD = `2.5.29.16`;
export const szOID_BASIC_CONSTRAINTS2 = `2.5.29.19`;
export const szOID_CERT_POLICIES = `2.5.29.32`;
export const szOID_ANY_CERT_POLICY = `2.5.29.32.0`;
export const szOID_INHIBIT_ANY_POLICY = `2.5.29.54`;
export const szOID_AUTHORITY_KEY_IDENTIFIER2 = `2.5.29.35`;
export const szOID_SUBJECT_KEY_IDENTIFIER = `2.5.29.14`;
export const szOID_SUBJECT_ALT_NAME2 = `2.5.29.17`;
export const szOID_ISSUER_ALT_NAME2 = `2.5.29.18`;
export const szOID_CRL_REASON_CODE = `2.5.29.21`;
export const szOID_REASON_CODE_HOLD = `2.5.29.23`;
export const szOID_CRL_DIST_POINTS = `2.5.29.31`;
export const szOID_ENHANCED_KEY_USAGE = `2.5.29.37`;
export const szOID_ANY_ENHANCED_KEY_USAGE = `2.5.29.37.0`;
export const szOID_CRL_NUMBER = `2.5.29.20`;
export const szOID_DELTA_CRL_INDICATOR = `2.5.29.27`;
export const szOID_ISSUING_DIST_POINT = `2.5.29.28`;
export const szOID_FRESHEST_CRL = `2.5.29.46`;
export const szOID_NAME_CONSTRAINTS = `2.5.29.30`;
export const szOID_POLICY_MAPPINGS = `2.5.29.33`;
export const szOID_LEGACY_POLICY_MAPPINGS = `2.5.29.5`;
export const szOID_POLICY_CONSTRAINTS = `2.5.29.36`;
export const szOID_RENEWAL_CERTIFICATE = `1.3.6.1.4.1.311.13.1`;
export const szOID_ENROLLMENT_NAME_VALUE_PAIR = `1.3.6.1.4.1.311.13.2.1`;
export const szOID_ENROLLMENT_CSP_PROVIDER = `1.3.6.1.4.1.311.13.2.2`;
export const szOID_OS_VERSION = `1.3.6.1.4.1.311.13.2.3`;
export const szOID_ENROLLMENT_AGENT = `1.3.6.1.4.1.311.20.2.1`;
export const szOID_PKIX = `1.3.6.1.5.5.7`;
export const szOID_PKIX_PE = `1.3.6.1.5.5.7.1`;
export const szOID_AUTHORITY_INFO_ACCESS = `1.3.6.1.5.5.7.1.1`;
export const szOID_SUBJECT_INFO_ACCESS = `1.3.6.1.5.5.7.1.11`;
export const szOID_BIOMETRIC_EXT = `1.3.6.1.5.5.7.1.2`;
export const szOID_QC_STATEMENTS_EXT = `1.3.6.1.5.5.7.1.3`;
export const szOID_LOGOTYPE_EXT = `1.3.6.1.5.5.7.1.12`;
export const szOID_TLS_FEATURES_EXT = `1.3.6.1.5.5.7.1.24`;
export const szOID_CERT_EXTENSIONS = `1.3.6.1.4.1.311.2.1.14`;
export const szOID_NEXT_UPDATE_LOCATION = `1.3.6.1.4.1.311.10.2`;
export const szOID_REMOVE_CERTIFICATE = `1.3.6.1.4.1.311.10.8.1`;
export const szOID_CROSS_CERT_DIST_POINTS = `1.3.6.1.4.1.311.10.9.1`;
export const szOID_CTL = `1.3.6.1.4.1.311.10.1`;
export const szOID_SORTED_CTL = `1.3.6.1.4.1.311.10.1.1`;
export const szOID_SERIALIZED = `1.3.6.1.4.1.311.10.3.3.1`;
export const szOID_NT_PRINCIPAL_NAME = `1.3.6.1.4.1.311.20.2.3`;
export const szOID_INTERNATIONALIZED_EMAIL_ADDRESS = `1.3.6.1.4.1.311.20.2.4`;
export const szOID_PRODUCT_UPDATE = `1.3.6.1.4.1.311.31.1`;
export const szOID_ANY_APPLICATION_POLICY = `1.3.6.1.4.1.311.10.12.1`;
export const szOID_AUTO_ENROLL_CTL_USAGE = `1.3.6.1.4.1.311.20.1`;
export const szOID_ENROLL_CERTTYPE_EXTENSION = `1.3.6.1.4.1.311.20.2`;
export const szOID_CERT_MANIFOLD = `1.3.6.1.4.1.311.20.3`;
export const szOID_CERTSRV_CA_VERSION = `1.3.6.1.4.1.311.21.1`;
export const szOID_CERTSRV_PREVIOUS_CERT_HASH = `1.3.6.1.4.1.311.21.2`;
export const szOID_CRL_VIRTUAL_BASE = `1.3.6.1.4.1.311.21.3`;
export const szOID_CRL_NEXT_PUBLISH = `1.3.6.1.4.1.311.21.4`;
export const szOID_KP_CA_EXCHANGE = `1.3.6.1.4.1.311.21.5`;
export const szOID_KP_PRIVACY_CA = `1.3.6.1.4.1.311.21.36`;
export const szOID_KP_KEY_RECOVERY_AGENT = `1.3.6.1.4.1.311.21.6`;
export const szOID_CERTIFICATE_TEMPLATE = `1.3.6.1.4.1.311.21.7`;
export const szOID_ENTERPRISE_OID_ROOT = `1.3.6.1.4.1.311.21.8`;
export const szOID_RDN_DUMMY_SIGNER = `1.3.6.1.4.1.311.21.9`;
export const szOID_APPLICATION_CERT_POLICIES = `1.3.6.1.4.1.311.21.10`;
export const szOID_APPLICATION_POLICY_MAPPINGS = `1.3.6.1.4.1.311.21.11`;
export const szOID_APPLICATION_POLICY_CONSTRAINTS = `1.3.6.1.4.1.311.21.12`;
export const szOID_ARCHIVED_KEY_ATTR = `1.3.6.1.4.1.311.21.13`;
export const szOID_CRL_SELF_CDP = `1.3.6.1.4.1.311.21.14`;
export const szOID_REQUIRE_CERT_CHAIN_POLICY = `1.3.6.1.4.1.311.21.15`;
export const szOID_ARCHIVED_KEY_CERT_HASH = `1.3.6.1.4.1.311.21.16`;
export const szOID_ISSUED_CERT_HASH = `1.3.6.1.4.1.311.21.17`;
export const szOID_DS_EMAIL_REPLICATION = `1.3.6.1.4.1.311.21.19`;
export const szOID_REQUEST_CLIENT_INFO = `1.3.6.1.4.1.311.21.20`;
export const szOID_ENCRYPTED_KEY_HASH = `1.3.6.1.4.1.311.21.21`;
export const szOID_CERTSRV_CROSSCA_VERSION = `1.3.6.1.4.1.311.21.22`;
export const szOID_NTDS_REPLICATION = `1.3.6.1.4.1.311.25.1`;
export const szOID_SUBJECT_DIR_ATTRS = `2.5.29.9`;
export const szOID_PKIX_KP = `1.3.6.1.5.5.7.3`;
export const szOID_PKIX_KP_SERVER_AUTH = `1.3.6.1.5.5.7.3.1`;
export const szOID_PKIX_KP_CLIENT_AUTH = `1.3.6.1.5.5.7.3.2`;
export const szOID_PKIX_KP_CODE_SIGNING = `1.3.6.1.5.5.7.3.3`;
export const szOID_PKIX_KP_EMAIL_PROTECTION = `1.3.6.1.5.5.7.3.4`;
export const szOID_PKIX_KP_IPSEC_END_SYSTEM = `1.3.6.1.5.5.7.3.5`;
export const szOID_PKIX_KP_IPSEC_TUNNEL = `1.3.6.1.5.5.7.3.6`;
export const szOID_PKIX_KP_IPSEC_USER = `1.3.6.1.5.5.7.3.7`;
export const szOID_PKIX_KP_TIMESTAMP_SIGNING = `1.3.6.1.5.5.7.3.8`;
export const szOID_PKIX_KP_OCSP_SIGNING = `1.3.6.1.5.5.7.3.9`;
export const szOID_PKIX_OCSP_NOCHECK = `1.3.6.1.5.5.7.48.1.5`;
export const szOID_PKIX_OCSP_NONCE = `1.3.6.1.5.5.7.48.1.2`;
export const szOID_IPSEC_KP_IKE_INTERMEDIATE = `1.3.6.1.5.5.8.2.2`;
export const szOID_PKINIT_KP_KDC = `1.3.6.1.5.2.3.5`;
export const szOID_KP_CTL_USAGE_SIGNING = `1.3.6.1.4.1.311.10.3.1`;
export const szOID_KP_TIME_STAMP_SIGNING = `1.3.6.1.4.1.311.10.3.2`;
export const szOID_SERVER_GATED_CRYPTO = `1.3.6.1.4.1.311.10.3.3`;
export const szOID_SGC_NETSCAPE = `2.16.840.1.113730.4.1`;
export const szOID_KP_EFS = `1.3.6.1.4.1.311.10.3.4`;
export const szOID_EFS_RECOVERY = `1.3.6.1.4.1.311.10.3.4.1`;
export const szOID_WHQL_CRYPTO = `1.3.6.1.4.1.311.10.3.5`;
export const szOID_ATTEST_WHQL_CRYPTO = `1.3.6.1.4.1.311.10.3.5.1`;
export const szOID_NT5_CRYPTO = `1.3.6.1.4.1.311.10.3.6`;
export const szOID_OEM_WHQL_CRYPTO = `1.3.6.1.4.1.311.10.3.7`;
export const szOID_EMBEDDED_NT_CRYPTO = `1.3.6.1.4.1.311.10.3.8`;
export const szOID_ROOT_LIST_SIGNER = `1.3.6.1.4.1.311.10.3.9`;
export const szOID_KP_QUALIFIED_SUBORDINATION = `1.3.6.1.4.1.311.10.3.10`;
export const szOID_KP_KEY_RECOVERY = `1.3.6.1.4.1.311.10.3.11`;
export const szOID_KP_DOCUMENT_SIGNING = `1.3.6.1.4.1.311.10.3.12`;
export const szOID_KP_LIFETIME_SIGNING = `1.3.6.1.4.1.311.10.3.13`;
export const szOID_KP_MOBILE_DEVICE_SOFTWARE = `1.3.6.1.4.1.311.10.3.14`;
export const szOID_KP_SMART_DISPLAY = `1.3.6.1.4.1.311.10.3.15`;
export const szOID_KP_CSP_SIGNATURE = `1.3.6.1.4.1.311.10.3.16`;
export const szOID_KP_FLIGHT_SIGNING = `1.3.6.1.4.1.311.10.3.27`;
export const szOID_PLATFORM_MANIFEST_BINARY_ID = `1.3.6.1.4.1.311.10.3.28`;
export const szOID_DRM = `1.3.6.1.4.1.311.10.5.1`;
export const szOID_DRM_INDIVIDUALIZATION = `1.3.6.1.4.1.311.10.5.2`;
export const szOID_LICENSES = `1.3.6.1.4.1.311.10.6.1`;
export const szOID_LICENSE_SERVER = `1.3.6.1.4.1.311.10.6.2`;
export const szOID_KP_SMARTCARD_LOGON = `1.3.6.1.4.1.311.20.2.2`;
export const szOID_KP_KERNEL_MODE_CODE_SIGNING = `1.3.6.1.4.1.311.61.1.1`;
export const szOID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING = `1.3.6.1.4.1.311.61.4.1`;
export const szOID_REVOKED_LIST_SIGNER = `1.3.6.1.4.1.311.10.3.19`;
export const szOID_WINDOWS_KITS_SIGNER = `1.3.6.1.4.1.311.10.3.20`;
export const szOID_WINDOWS_RT_SIGNER = `1.3.6.1.4.1.311.10.3.21`;
export const szOID_PROTECTED_PROCESS_LIGHT_SIGNER = `1.3.6.1.4.1.311.10.3.22`;
export const szOID_WINDOWS_TCB_SIGNER = `1.3.6.1.4.1.311.10.3.23`;
export const szOID_PROTECTED_PROCESS_SIGNER = `1.3.6.1.4.1.311.10.3.24`;
export const szOID_WINDOWS_THIRD_PARTY_COMPONENT_SIGNER = `1.3.6.1.4.1.311.10.3.25`;
export const szOID_WINDOWS_SOFTWARE_EXTENSION_SIGNER = `1.3.6.1.4.1.311.10.3.26`;
export const szOID_DISALLOWED_LIST = `1.3.6.1.4.1.311.10.3.30`;
export const szOID_PIN_RULES_SIGNER = `1.3.6.1.4.1.311.10.3.31`;
export const szOID_PIN_RULES_CTL = `1.3.6.1.4.1.311.10.3.32`;
export const szOID_PIN_RULES_EXT = `1.3.6.1.4.1.311.10.3.33`;
export const szOID_PIN_RULES_DOMAIN_NAME = `1.3.6.1.4.1.311.10.3.34`;
export const szOID_PIN_RULES_LOG_END_DATE_EXT = `1.3.6.1.4.1.311.10.3.35`;
export const szOID_IUM_SIGNING = `1.3.6.1.4.1.311.10.3.37`;
export const szOID_EV_WHQL_CRYPTO = `1.3.6.1.4.1.311.10.3.39`;
export const szOID_BIOMETRIC_SIGNING = `1.3.6.1.4.1.311.10.3.41`;
export const szOID_ENCLAVE_SIGNING = `1.3.6.1.4.1.311.10.3.42`;
export const szOID_SYNC_ROOT_CTL_EXT = `1.3.6.1.4.1.311.10.3.50`;
export const szOID_HPKP_DOMAIN_NAME_CTL = `1.3.6.1.4.1.311.10.3.60`;
export const szOID_HPKP_HEADER_VALUE_CTL = `1.3.6.1.4.1.311.10.3.61`;
export const szOID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING = `1.3.6.1.4.1.311.61.5.1`;
export const szOID_WINDOWS_STORE_SIGNER = `1.3.6.1.4.1.311.76.3.1`;
export const szOID_DYNAMIC_CODE_GEN_SIGNER = `1.3.6.1.4.1.311.76.5.1`;
export const szOID_MICROSOFT_PUBLISHER_SIGNER = `1.3.6.1.4.1.311.76.8.1`;
export const szOID_YESNO_TRUST_ATTR = `1.3.6.1.4.1.311.10.4.1`;
export const szOID_SITE_PIN_RULES_INDEX_ATTR = `1.3.6.1.4.1.311.10.4.2`;
export const szOID_SITE_PIN_RULES_FLAGS_ATTR = `1.3.6.1.4.1.311.10.4.3`;
export const SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG = 1;
export const szOID_PKIX_POLICY_QUALIFIER_CPS = `1.3.6.1.5.5.7.2.1`;
export const szOID_PKIX_POLICY_QUALIFIER_USERNOTICE = `1.3.6.1.5.5.7.2.2`;
export const szOID_ROOT_PROGRAM_FLAGS = `1.3.6.1.4.1.311.60.1.1`;
export const CERT_ROOT_PROGRAM_FLAG_OU = 16;
export const CERT_ROOT_PROGRAM_FLAG_ADDRESS = 8;
export const szOID_CERT_POLICIES_95_QUALIFIER1 = `2.16.840.1.113733.1.7.1.1`;
export const szOID_RDN_TPM_MANUFACTURER = `2.23.133.2.1`;
export const szOID_RDN_TPM_MODEL = `2.23.133.2.2`;
export const szOID_RDN_TPM_VERSION = `2.23.133.2.3`;
export const szOID_RDN_TCG_PLATFORM_MANUFACTURER = `2.23.133.2.4`;
export const szOID_RDN_TCG_PLATFORM_MODEL = `2.23.133.2.5`;
export const szOID_RDN_TCG_PLATFORM_VERSION = `2.23.133.2.6`;
export const szOID_CT_CERT_SCTLIST = `1.3.6.1.4.1.11129.2.4.2`;
export const szOID_ENROLL_EK_INFO = `1.3.6.1.4.1.311.21.23`;
export const szOID_ENROLL_AIK_INFO = `1.3.6.1.4.1.311.21.39`;
export const szOID_ENROLL_ATTESTATION_STATEMENT = `1.3.6.1.4.1.311.21.24`;
export const szOID_ENROLL_KSP_NAME = `1.3.6.1.4.1.311.21.25`;
export const szOID_ENROLL_EKPUB_CHALLENGE = `1.3.6.1.4.1.311.21.26`;
export const szOID_ENROLL_CAXCHGCERT_HASH = `1.3.6.1.4.1.311.21.27`;
export const szOID_ENROLL_ATTESTATION_CHALLENGE = `1.3.6.1.4.1.311.21.28`;
export const szOID_ENROLL_ENCRYPTION_ALGORITHM = `1.3.6.1.4.1.311.21.29`;
export const szOID_KP_TPM_EK_CERTIFICATE = `2.23.133.8.1`;
export const szOID_KP_TPM_PLATFORM_CERTIFICATE = `2.23.133.8.2`;
export const szOID_KP_TPM_AIK_CERTIFICATE = `2.23.133.8.3`;
export const szOID_ENROLL_EKVERIFYKEY = `1.3.6.1.4.1.311.21.30`;
export const szOID_ENROLL_EKVERIFYCERT = `1.3.6.1.4.1.311.21.31`;
export const szOID_ENROLL_EKVERIFYCREDS = `1.3.6.1.4.1.311.21.32`;
export const szOID_ENROLL_SCEP_ERROR = `1.3.6.1.4.1.311.21.33`;
export const szOID_ENROLL_SCEP_SERVER_STATE = `1.3.6.1.4.1.311.21.34`;
export const szOID_ENROLL_SCEP_CHALLENGE_ANSWER = `1.3.6.1.4.1.311.21.35`;
export const szOID_ENROLL_SCEP_CLIENT_REQUEST = `1.3.6.1.4.1.311.21.37`;
export const szOID_ENROLL_SCEP_SERVER_MESSAGE = `1.3.6.1.4.1.311.21.38`;
export const szOID_ENROLL_SCEP_SERVER_SECRET = `1.3.6.1.4.1.311.21.40`;
export const szOID_ENROLL_KEY_AFFINITY = `1.3.6.1.4.1.311.21.41`;
export const szOID_ENROLL_SCEP_SIGNER_HASH = `1.3.6.1.4.1.311.21.42`;
export const szOID_ENROLL_EK_CA_KEYID = `1.3.6.1.4.1.311.21.43`;
export const szOID_ATTR_SUPPORTED_ALGORITHMS = `2.5.4.52`;
export const szOID_ATTR_TPM_SPECIFICATION = `2.23.133.2.16`;
export const szOID_ATTR_PLATFORM_SPECIFICATION = `2.23.133.2.17`;
export const szOID_ATTR_TPM_SECURITY_ASSERTIONS = `2.23.133.2.18`;
export const CERT_UNICODE_RDN_ERR_INDEX_MASK = 1023;
export const CERT_UNICODE_RDN_ERR_INDEX_SHIFT = 22;
export const CERT_UNICODE_ATTR_ERR_INDEX_MASK = 63;
export const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT = 16;
export const CERT_UNICODE_VALUE_ERR_INDEX_MASK = 65535;
export const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT = 0;
export const CERT_DIGITAL_SIGNATURE_KEY_USAGE = 128;
export const CERT_NON_REPUDIATION_KEY_USAGE = 64;
export const CERT_KEY_ENCIPHERMENT_KEY_USAGE = 32;
export const CERT_DATA_ENCIPHERMENT_KEY_USAGE = 16;
export const CERT_KEY_AGREEMENT_KEY_USAGE = 8;
export const CERT_KEY_CERT_SIGN_KEY_USAGE = 4;
export const CERT_OFFLINE_CRL_SIGN_KEY_USAGE = 2;
export const CERT_CRL_SIGN_KEY_USAGE = 2;
export const CERT_ENCIPHER_ONLY_KEY_USAGE = 1;
export const CERT_DECIPHER_ONLY_KEY_USAGE = 128;
export const CERT_ALT_NAME_X400_ADDRESS = 4;
export const CERT_ALT_NAME_EDI_PARTY_NAME = 6;
export const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK = 255;
export const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT = 16;
export const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK = 65535;
export const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT = 0;
export const CERT_CA_SUBJECT_FLAG = 128;
export const CERT_END_ENTITY_SUBJECT_FLAG = 64;
export const szOID_PKIX_ACC_DESCR = `1.3.6.1.5.5.7.48`;
export const szOID_PKIX_OCSP = `1.3.6.1.5.5.7.48.1`;
export const szOID_PKIX_CA_ISSUERS = `1.3.6.1.5.5.7.48.2`;
export const szOID_PKIX_TIME_STAMPING = `1.3.6.1.5.5.7.48.3`;
export const szOID_PKIX_CA_REPOSITORY = `1.3.6.1.5.5.7.48.5`;
export const CRL_REASON_PRIVILEGE_WITHDRAWN = 9;
export const CRL_REASON_AA_COMPROMISE = 10;
export const CRL_DIST_POINT_NO_NAME = 0;
export const CRL_DIST_POINT_FULL_NAME = 1;
export const CRL_DIST_POINT_ISSUER_RDN_NAME = 2;
export const CRL_REASON_UNUSED_FLAG = 128;
export const CRL_REASON_KEY_COMPROMISE_FLAG = 64;
export const CRL_REASON_CA_COMPROMISE_FLAG = 32;
export const CRL_REASON_AFFILIATION_CHANGED_FLAG = 16;
export const CRL_REASON_SUPERSEDED_FLAG = 8;
export const CRL_REASON_CESSATION_OF_OPERATION_FLAG = 4;
export const CRL_REASON_CERTIFICATE_HOLD_FLAG = 2;
export const CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG = 1;
export const CRL_REASON_AA_COMPROMISE_FLAG = 128;
export const CRL_DIST_POINT_ERR_INDEX_MASK = 127;
export const CRL_DIST_POINT_ERR_INDEX_SHIFT = 24;
export const CRL_DIST_POINT_ERR_CRL_ISSUER_BIT = `-2147483648`;
export const CROSS_CERT_DIST_POINT_ERR_INDEX_MASK = 255;
export const CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT = 24;
export const CERT_EXCLUDED_SUBTREE_BIT = `-2147483648`;
export const SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG = 1;
export const CERT_DSS_R_LEN = 20;
export const CERT_DSS_S_LEN = 20;
export const CRYPT_X942_COUNTER_BYTE_LENGTH = 4;
export const CRYPT_X942_KEY_LENGTH_BYTE_LENGTH = 4;
export const CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH = 4;
export const CRYPT_RC2_40BIT_VERSION = 160;
export const CRYPT_RC2_56BIT_VERSION = 52;
export const CRYPT_RC2_64BIT_VERSION = 120;
export const CRYPT_RC2_128BIT_VERSION = 58;
export const szOID_QC_EU_COMPLIANCE = `0.4.0.1862.1.1`;
export const szOID_QC_SSCD = `0.4.0.1862.1.4`;
export const PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC = 1;
export const szOID_VERISIGN_PRIVATE_6_9 = `2.16.840.1.113733.1.6.9`;
export const szOID_VERISIGN_ONSITE_JURISDICTION_HASH = `2.16.840.1.113733.1.6.11`;
export const szOID_VERISIGN_BITSTRING_6_13 = `2.16.840.1.113733.1.6.13`;
export const szOID_VERISIGN_ISS_STRONG_CRYPTO = `2.16.840.1.113733.1.8.1`;
export const szOIDVerisign_MessageType = `2.16.840.1.113733.1.9.2`;
export const szOIDVerisign_PkiStatus = `2.16.840.1.113733.1.9.3`;
export const szOIDVerisign_FailInfo = `2.16.840.1.113733.1.9.4`;
export const szOIDVerisign_SenderNonce = `2.16.840.1.113733.1.9.5`;
export const szOIDVerisign_RecipientNonce = `2.16.840.1.113733.1.9.6`;
export const szOIDVerisign_TransactionID = `2.16.840.1.113733.1.9.7`;
export const szOID_NETSCAPE = `2.16.840.1.113730`;
export const szOID_NETSCAPE_CERT_EXTENSION = `2.16.840.1.113730.1`;
export const szOID_NETSCAPE_CERT_TYPE = `2.16.840.1.113730.1.1`;
export const szOID_NETSCAPE_BASE_URL = `2.16.840.1.113730.1.2`;
export const szOID_NETSCAPE_REVOCATION_URL = `2.16.840.1.113730.1.3`;
export const szOID_NETSCAPE_CA_REVOCATION_URL = `2.16.840.1.113730.1.4`;
export const szOID_NETSCAPE_CERT_RENEWAL_URL = `2.16.840.1.113730.1.7`;
export const szOID_NETSCAPE_CA_POLICY_URL = `2.16.840.1.113730.1.8`;
export const szOID_NETSCAPE_SSL_SERVER_NAME = `2.16.840.1.113730.1.12`;
export const szOID_NETSCAPE_COMMENT = `2.16.840.1.113730.1.13`;
export const szOID_NETSCAPE_DATA_TYPE = `2.16.840.1.113730.2`;
export const szOID_NETSCAPE_CERT_SEQUENCE = `2.16.840.1.113730.2.5`;
export const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE = 128;
export const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE = 64;
export const NETSCAPE_SMIME_CERT_TYPE = 32;
export const NETSCAPE_SIGN_CERT_TYPE = 16;
export const NETSCAPE_SSL_CA_CERT_TYPE = 4;
export const NETSCAPE_SMIME_CA_CERT_TYPE = 2;
export const NETSCAPE_SIGN_CA_CERT_TYPE = 1;
export const szOID_CT_PKI_DATA = `1.3.6.1.5.5.7.12.2`;
export const szOID_CT_PKI_RESPONSE = `1.3.6.1.5.5.7.12.3`;
export const szOID_PKIX_NO_SIGNATURE = `1.3.6.1.5.5.7.6.2`;
export const szOID_CMC = `1.3.6.1.5.5.7.7`;
export const szOID_CMC_STATUS_INFO = `1.3.6.1.5.5.7.7.1`;
export const szOID_CMC_IDENTIFICATION = `1.3.6.1.5.5.7.7.2`;
export const szOID_CMC_IDENTITY_PROOF = `1.3.6.1.5.5.7.7.3`;
export const szOID_CMC_DATA_RETURN = `1.3.6.1.5.5.7.7.4`;
export const szOID_CMC_TRANSACTION_ID = `1.3.6.1.5.5.7.7.5`;
export const szOID_CMC_SENDER_NONCE = `1.3.6.1.5.5.7.7.6`;
export const szOID_CMC_RECIPIENT_NONCE = `1.3.6.1.5.5.7.7.7`;
export const szOID_CMC_ADD_EXTENSIONS = `1.3.6.1.5.5.7.7.8`;
export const szOID_CMC_ENCRYPTED_POP = `1.3.6.1.5.5.7.7.9`;
export const szOID_CMC_DECRYPTED_POP = `1.3.6.1.5.5.7.7.10`;
export const szOID_CMC_LRA_POP_WITNESS = `1.3.6.1.5.5.7.7.11`;
export const szOID_CMC_GET_CERT = `1.3.6.1.5.5.7.7.15`;
export const szOID_CMC_GET_CRL = `1.3.6.1.5.5.7.7.16`;
export const szOID_CMC_REVOKE_REQUEST = `1.3.6.1.5.5.7.7.17`;
export const szOID_CMC_REG_INFO = `1.3.6.1.5.5.7.7.18`;
export const szOID_CMC_RESPONSE_INFO = `1.3.6.1.5.5.7.7.19`;
export const szOID_CMC_QUERY_PENDING = `1.3.6.1.5.5.7.7.21`;
export const szOID_CMC_ID_POP_LINK_RANDOM = `1.3.6.1.5.5.7.7.22`;
export const szOID_CMC_ID_POP_LINK_WITNESS = `1.3.6.1.5.5.7.7.23`;
export const szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE = `1.3.6.1.5.5.7.7.24`;
export const szOID_CMC_ADD_ATTRIBUTES = `1.3.6.1.4.1.311.10.10.1`;
export const CMC_TAGGED_CERT_REQUEST_CHOICE = 1;
export const CMC_OTHER_INFO_NO_CHOICE = 0;
export const CMC_OTHER_INFO_FAIL_CHOICE = 1;
export const CMC_OTHER_INFO_PEND_CHOICE = 2;
export const CMC_STATUS_SUCCESS = 0;
export const CMC_STATUS_FAILED = 2;
export const CMC_STATUS_PENDING = 3;
export const CMC_STATUS_NO_SUPPORT = 4;
export const CMC_STATUS_CONFIRM_REQUIRED = 5;
export const CMC_FAIL_BAD_ALG = 0;
export const CMC_FAIL_BAD_MESSAGE_CHECK = 1;
export const CMC_FAIL_BAD_REQUEST = 2;
export const CMC_FAIL_BAD_TIME = 3;
export const CMC_FAIL_BAD_CERT_ID = 4;
export const CMC_FAIL_UNSUPORTED_EXT = 5;
export const CMC_FAIL_MUST_ARCHIVE_KEYS = 6;
export const CMC_FAIL_BAD_IDENTITY = 7;
export const CMC_FAIL_POP_REQUIRED = 8;
export const CMC_FAIL_POP_FAILED = 9;
export const CMC_FAIL_NO_KEY_REUSE = 10;
export const CMC_FAIL_INTERNAL_CA_ERROR = 11;
export const CMC_FAIL_TRY_LATER = 12;
export const szOID_LOYALTY_OTHER_LOGOTYPE = `1.3.6.1.5.5.7.20.1`;
export const szOID_BACKGROUND_OTHER_LOGOTYPE = `1.3.6.1.5.5.7.20.2`;
export const CERT_BIOMETRIC_PICTURE_TYPE = 0;
export const CERT_BIOMETRIC_SIGNATURE_TYPE = 1;
export const OCSP_REQUEST_V1 = 0;
export const OCSP_SUCCESSFUL_RESPONSE = 0;
export const OCSP_MALFORMED_REQUEST_RESPONSE = 1;
export const OCSP_INTERNAL_ERROR_RESPONSE = 2;
export const OCSP_TRY_LATER_RESPONSE = 3;
export const OCSP_SIG_REQUIRED_RESPONSE = 5;
export const OCSP_UNAUTHORIZED_RESPONSE = 6;
export const szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE = `1.3.6.1.5.5.7.48.1.1`;
export const OCSP_BASIC_GOOD_CERT_STATUS = 0;
export const OCSP_BASIC_REVOKED_CERT_STATUS = 1;
export const OCSP_BASIC_UNKNOWN_CERT_STATUS = 2;
export const OCSP_BASIC_RESPONSE_V1 = 0;
export const OCSP_BASIC_BY_NAME_RESPONDER_ID = 1;
export const OCSP_BASIC_BY_KEY_RESPONDER_ID = 2;
export const CRYPT_OID_ENCODE_OBJECT_FUNC = `CryptDllEncodeObject`;
export const CRYPT_OID_DECODE_OBJECT_FUNC = `CryptDllDecodeObject`;
export const CRYPT_OID_ENCODE_OBJECT_EX_FUNC = `CryptDllEncodeObjectEx`;
export const CRYPT_OID_DECODE_OBJECT_EX_FUNC = `CryptDllDecodeObjectEx`;
export const CRYPT_OID_CREATE_COM_OBJECT_FUNC = `CryptDllCreateCOMObject`;
export const CRYPT_OID_VERIFY_REVOCATION_FUNC = `CertDllVerifyRevocation`;
export const CRYPT_OID_VERIFY_CTL_USAGE_FUNC = `CertDllVerifyCTLUsage`;
export const CRYPT_OID_FORMAT_OBJECT_FUNC = `CryptDllFormatObject`;
export const CRYPT_OID_FIND_OID_INFO_FUNC = `CryptDllFindOIDInfo`;
export const CRYPT_OID_FIND_LOCALIZED_NAME_FUNC = `CryptDllFindLocalizedName`;
export const CRYPT_OID_REGPATH = `Software\\Microsoft\\Cryptography\\OID`;
export const CRYPT_OID_REG_ENCODING_TYPE_PREFIX = `EncodingType `;
export const CRYPT_OID_REG_DLL_VALUE_NAME = `Dll`;
export const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME = `FuncName`;
export const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A = `FuncName`;
export const CRYPT_OID_REG_FLAGS_VALUE_NAME = `CryptFlags`;
export const CRYPT_DEFAULT_OID = `DEFAULT`;
export const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG = 1;
export const CRYPT_GET_INSTALLED_OID_FUNC_FLAG = 1;
export const CRYPT_REGISTER_FIRST_INDEX = 0;
export const CRYPT_REGISTER_LAST_INDEX = 4294967295;
export const CRYPT_MATCH_ANY_ENCODING_TYPE = 4294967295;
export const CALG_OID_INFO_CNG_ONLY = 4294967295;
export const CALG_OID_INFO_PARAMETERS = 4294967294;
export const CRYPT_OID_INFO_HASH_PARAMETERS_ALGORITHM = `CryptOIDInfoHashParameters`;
export const CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM = `CryptOIDInfoECCParameters`;
export const CRYPT_OID_INFO_MGF1_PARAMETERS_ALGORITHM = `CryptOIDInfoMgf1Parameters`;
export const CRYPT_OID_INFO_NO_SIGN_ALGORITHM = `CryptOIDInfoNoSign`;
export const CRYPT_OID_INFO_OAEP_PARAMETERS_ALGORITHM = `CryptOIDInfoOAEPParameters`;
export const CRYPT_OID_INFO_ECC_WRAP_PARAMETERS_ALGORITHM = `CryptOIDInfoECCWrapParameters`;
export const CRYPT_OID_INFO_NO_PARAMETERS_ALGORITHM = `CryptOIDInfoNoParameters`;
export const CRYPT_HASH_ALG_OID_GROUP_ID = 1;
export const CRYPT_ENCRYPT_ALG_OID_GROUP_ID = 2;
export const CRYPT_PUBKEY_ALG_OID_GROUP_ID = 3;
export const CRYPT_SIGN_ALG_OID_GROUP_ID = 4;
export const CRYPT_RDN_ATTR_OID_GROUP_ID = 5;
export const CRYPT_EXT_OR_ATTR_OID_GROUP_ID = 6;
export const CRYPT_ENHKEY_USAGE_OID_GROUP_ID = 7;
export const CRYPT_POLICY_OID_GROUP_ID = 8;
export const CRYPT_TEMPLATE_OID_GROUP_ID = 9;
export const CRYPT_KDF_OID_GROUP_ID = 10;
export const CRYPT_LAST_OID_GROUP_ID = 10;
export const CRYPT_FIRST_ALG_OID_GROUP_ID = 1;
export const CRYPT_LAST_ALG_OID_GROUP_ID = 4;
export const CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG = 1;
export const CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG = 2;
export const CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG = 4;
export const CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG = 2147483648;
export const CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG = 1073741824;
export const CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = 536870912;
export const CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = 268435456;
export const CRYPT_OID_INFO_OID_KEY = 1;
export const CRYPT_OID_INFO_NAME_KEY = 2;
export const CRYPT_OID_INFO_ALGID_KEY = 3;
export const CRYPT_OID_INFO_SIGN_KEY = 4;
export const CRYPT_OID_INFO_CNG_ALGID_KEY = 5;
export const CRYPT_OID_INFO_CNG_SIGN_KEY = 6;
export const CRYPT_OID_INFO_OID_KEY_FLAGS_MASK = 4294901760;
export const CRYPT_OID_DISABLE_SEARCH_DS_FLAG = 2147483648;
export const CRYPT_OID_PREFER_CNG_ALGID_FLAG = 1073741824;
export const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = 268369920;
export const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = 16;
export const CRYPT_INSTALL_OID_INFO_BEFORE_FLAG = 1;
export const CRYPT_LOCALIZED_NAME_ENCODING_TYPE = 0;
export const CRYPT_LOCALIZED_NAME_OID = `LocalizedNames`;
export const CERT_STRONG_SIGN_ECDSA_ALGORITHM = `ECDSA`;
export const CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE = 1;
export const CERT_STRONG_SIGN_OID_INFO_CHOICE = 2;
export const szOID_CERT_STRONG_SIGN_OS_PREFIX = `1.3.6.1.4.1.311.72.1.`;
export const szOID_CERT_STRONG_SIGN_OS_1 = `1.3.6.1.4.1.311.72.1.1`;
export const szOID_CERT_STRONG_SIGN_OS_CURRENT = `1.3.6.1.4.1.311.72.1.1`;
export const szOID_CERT_STRONG_KEY_OS_PREFIX = `1.3.6.1.4.1.311.72.2.`;
export const szOID_CERT_STRONG_KEY_OS_1 = `1.3.6.1.4.1.311.72.2.1`;
export const szOID_CERT_STRONG_KEY_OS_CURRENT = `1.3.6.1.4.1.311.72.2.1`;
export const szOID_PKCS_7_DATA = `1.2.840.113549.1.7.1`;
export const szOID_PKCS_7_SIGNED = `1.2.840.113549.1.7.2`;
export const szOID_PKCS_7_ENVELOPED = `1.2.840.113549.1.7.3`;
export const szOID_PKCS_7_SIGNEDANDENVELOPED = `1.2.840.113549.1.7.4`;
export const szOID_PKCS_7_DIGESTED = `1.2.840.113549.1.7.5`;
export const szOID_PKCS_7_ENCRYPTED = `1.2.840.113549.1.7.6`;
export const szOID_PKCS_9_CONTENT_TYPE = `1.2.840.113549.1.9.3`;
export const szOID_PKCS_9_MESSAGE_DIGEST = `1.2.840.113549.1.9.4`;
export const CMSG_ENCRYPTED = 6;
export const CMSG_MAIL_LIST_HANDLE_KEY_CHOICE = 1;
export const CMSG_KEY_TRANS_RECIPIENT = 1;
export const CMSG_KEY_AGREE_RECIPIENT = 2;
export const CMSG_MAIL_LIST_RECIPIENT = 3;
export const CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG = 2147483648;
export const CMSG_RC4_NO_SALT_FLAG = 1073741824;
export const CMSG_INDEFINITE_LENGTH = 4294967295;
export const CMSG_BARE_CONTENT_FLAG = 1;
export const CMSG_LENGTH_ONLY_FLAG = 2;
export const CMSG_DETACHED_FLAG = 4;
export const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG = 8;
export const CMSG_CONTENTS_OCTETS_FLAG = 16;
export const CMSG_MAX_LENGTH_FLAG = 32;
export const CMSG_CMS_ENCAPSULATED_CONTENT_FLAG = 64;
export const CMSG_SIGNED_DATA_NO_SIGN_FLAG = 128;
export const CMSG_CRYPT_RELEASE_CONTEXT_FLAG = 32768;
export const CMSG_TYPE_PARAM = 1;
export const CMSG_CONTENT_PARAM = 2;
export const CMSG_BARE_CONTENT_PARAM = 3;
export const CMSG_INNER_CONTENT_TYPE_PARAM = 4;
export const CMSG_SIGNER_COUNT_PARAM = 5;
export const CMSG_SIGNER_INFO_PARAM = 6;
export const CMSG_SIGNER_CERT_INFO_PARAM = 7;
export const CMSG_SIGNER_HASH_ALGORITHM_PARAM = 8;
export const CMSG_SIGNER_AUTH_ATTR_PARAM = 9;
export const CMSG_SIGNER_UNAUTH_ATTR_PARAM = 10;
export const CMSG_CERT_COUNT_PARAM = 11;
export const CMSG_CERT_PARAM = 12;
export const CMSG_CRL_COUNT_PARAM = 13;
export const CMSG_CRL_PARAM = 14;
export const CMSG_ENVELOPE_ALGORITHM_PARAM = 15;
export const CMSG_RECIPIENT_COUNT_PARAM = 17;
export const CMSG_RECIPIENT_INDEX_PARAM = 18;
export const CMSG_RECIPIENT_INFO_PARAM = 19;
export const CMSG_HASH_ALGORITHM_PARAM = 20;
export const CMSG_HASH_DATA_PARAM = 21;
export const CMSG_COMPUTED_HASH_PARAM = 22;
export const CMSG_ENCRYPT_PARAM = 26;
export const CMSG_ENCRYPTED_DIGEST = 27;
export const CMSG_ENCODED_SIGNER = 28;
export const CMSG_ENCODED_MESSAGE = 29;
export const CMSG_VERSION_PARAM = 30;
export const CMSG_ATTR_CERT_COUNT_PARAM = 31;
export const CMSG_ATTR_CERT_PARAM = 32;
export const CMSG_CMS_RECIPIENT_COUNT_PARAM = 33;
export const CMSG_CMS_RECIPIENT_INDEX_PARAM = 34;
export const CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM = 35;
export const CMSG_CMS_RECIPIENT_INFO_PARAM = 36;
export const CMSG_UNPROTECTED_ATTR_PARAM = 37;
export const CMSG_SIGNER_CERT_ID_PARAM = 38;
export const CMSG_CMS_SIGNER_INFO_PARAM = 39;
export const CMSG_SIGNED_DATA_V1 = 1;
export const CMSG_SIGNED_DATA_V3 = 3;
export const CMSG_SIGNED_DATA_PKCS_1_5_VERSION = 1;
export const CMSG_SIGNED_DATA_CMS_VERSION = 3;
export const CMSG_SIGNER_INFO_V1 = 1;
export const CMSG_SIGNER_INFO_V3 = 3;
export const CMSG_SIGNER_INFO_PKCS_1_5_VERSION = 1;
export const CMSG_SIGNER_INFO_CMS_VERSION = 3;
export const CMSG_HASHED_DATA_V0 = 0;
export const CMSG_HASHED_DATA_V2 = 2;
export const CMSG_HASHED_DATA_PKCS_1_5_VERSION = 0;
export const CMSG_HASHED_DATA_CMS_VERSION = 2;
export const CMSG_ENVELOPED_DATA_V0 = 0;
export const CMSG_ENVELOPED_DATA_V2 = 2;
export const CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION = 0;
export const CMSG_ENVELOPED_DATA_CMS_VERSION = 2;
export const CMSG_ENVELOPED_RECIPIENT_V0 = 0;
export const CMSG_ENVELOPED_RECIPIENT_V2 = 2;
export const CMSG_ENVELOPED_RECIPIENT_V3 = 3;
export const CMSG_ENVELOPED_RECIPIENT_V4 = 4;
export const CMSG_KEY_TRANS_PKCS_1_5_VERSION = 0;
export const CMSG_KEY_TRANS_CMS_VERSION = 2;
export const CMSG_KEY_AGREE_VERSION = 3;
export const CMSG_MAIL_LIST_VERSION = 4;
export const CMSG_CTRL_VERIFY_SIGNATURE = 1;
export const CMSG_CTRL_DECRYPT = 2;
export const CMSG_CTRL_VERIFY_HASH = 5;
export const CMSG_CTRL_ADD_SIGNER = 6;
export const CMSG_CTRL_DEL_SIGNER = 7;
export const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR = 8;
export const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR = 9;
export const CMSG_CTRL_ADD_CERT = 10;
export const CMSG_CTRL_DEL_CERT = 11;
export const CMSG_CTRL_ADD_CRL = 12;
export const CMSG_CTRL_DEL_CRL = 13;
export const CMSG_CTRL_ADD_ATTR_CERT = 14;
export const CMSG_CTRL_DEL_ATTR_CERT = 15;
export const CMSG_CTRL_KEY_TRANS_DECRYPT = 16;
export const CMSG_CTRL_KEY_AGREE_DECRYPT = 17;
export const CMSG_CTRL_MAIL_LIST_DECRYPT = 18;
export const CMSG_CTRL_VERIFY_SIGNATURE_EX = 19;
export const CMSG_CTRL_ADD_CMS_SIGNER_INFO = 20;
export const CMSG_CTRL_ENABLE_STRONG_SIGNATURE = 21;
export const CMSG_VERIFY_SIGNER_PUBKEY = 1;
export const CMSG_VERIFY_SIGNER_CERT = 2;
export const CMSG_VERIFY_SIGNER_CHAIN = 3;
export const CMSG_VERIFY_SIGNER_NULL = 4;
export const CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG = 1;
export const CMSG_OID_GEN_ENCRYPT_KEY_FUNC = `CryptMsgDllGenEncryptKey`;
export const CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC = `CryptMsgDllExportEncryptKey`;
export const CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC = `CryptMsgDllImportEncryptKey`;
export const CMSG_DEFAULT_INSTALLABLE_FUNC_OID = 2216203124737;
export const CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG = 1;
export const CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG = 1;
export const CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG = 2;
export const CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG = 32768;
export const CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC = `CryptMsgDllGenContentEncryptKey`;
export const CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC = `CryptMsgDllGenContentEncryptKey`;
export const CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC = `CryptMsgDllCNGGenContentEncryptKey`;
export const CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG = 1;
export const CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG = 2;
export const CMSG_OID_EXPORT_KEY_TRANS_FUNC = `CryptMsgDllExportKeyTrans`;
export const CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC = `CryptMsgDllExportKeyTrans`;
export const CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC = `CryptMsgDllCNGExportKeyTrans`;
export const CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG = 1;
export const CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG = 2;
export const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG = 4;
export const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG = 8;
export const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG = 16;
export const CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG = 32;
export const CMSG_OID_EXPORT_KEY_AGREE_FUNC = `CryptMsgDllExportKeyAgree`;
export const CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC = `CryptMsgDllExportKeyAgree`;
export const CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC = `CryptMsgDllCNGExportKeyAgree`;
export const CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG = 1;
export const CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG = 2;
export const CMSG_OID_EXPORT_MAIL_LIST_FUNC = `CryptMsgDllExportMailList`;
export const CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC = `CryptMsgDllExportMailList`;
export const CMSG_OID_IMPORT_KEY_TRANS_FUNC = `CryptMsgDllImportKeyTrans`;
export const CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC = `CryptMsgDllImportKeyTrans`;
export const CMSG_OID_IMPORT_KEY_AGREE_FUNC = `CryptMsgDllImportKeyAgree`;
export const CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC = `CryptMsgDllImportKeyAgree`;
export const CMSG_OID_IMPORT_MAIL_LIST_FUNC = `CryptMsgDllImportMailList`;
export const CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC = `CryptMsgDllImportMailList`;
export const CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC = `CryptMsgDllCNGImportKeyTrans`;
export const CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC = `CryptMsgDllCNGImportKeyAgree`;
export const CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC = `CryptMsgDllCNGImportContentEncryptKey`;
export const CERT_KEY_PROV_HANDLE_PROP_ID = 1;
export const CERT_KEY_PROV_INFO_PROP_ID = 2;
export const CERT_SHA1_HASH_PROP_ID = 3;
export const CERT_MD5_HASH_PROP_ID = 4;
export const CERT_HASH_PROP_ID = 3;
export const CERT_KEY_CONTEXT_PROP_ID = 5;
export const CERT_KEY_SPEC_PROP_ID = 6;
export const CERT_IE30_RESERVED_PROP_ID = 7;
export const CERT_PUBKEY_HASH_RESERVED_PROP_ID = 8;
export const CERT_ENHKEY_USAGE_PROP_ID = 9;
export const CERT_CTL_USAGE_PROP_ID = 9;
export const CERT_NEXT_UPDATE_LOCATION_PROP_ID = 10;
export const CERT_FRIENDLY_NAME_PROP_ID = 11;
export const CERT_PVK_FILE_PROP_ID = 12;
export const CERT_DESCRIPTION_PROP_ID = 13;
export const CERT_ACCESS_STATE_PROP_ID = 14;
export const CERT_SIGNATURE_HASH_PROP_ID = 15;
export const CERT_SMART_CARD_DATA_PROP_ID = 16;
export const CERT_EFS_PROP_ID = 17;
export const CERT_FORTEZZA_DATA_PROP_ID = 18;
export const CERT_ARCHIVED_PROP_ID = 19;
export const CERT_KEY_IDENTIFIER_PROP_ID = 20;
export const CERT_AUTO_ENROLL_PROP_ID = 21;
export const CERT_PUBKEY_ALG_PARA_PROP_ID = 22;
export const CERT_CROSS_CERT_DIST_POINTS_PROP_ID = 23;
export const CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = 24;
export const CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = 25;
export const CERT_ENROLLMENT_PROP_ID = 26;
export const CERT_DATE_STAMP_PROP_ID = 27;
export const CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = 28;
export const CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = 29;
export const CERT_EXTENDED_ERROR_INFO_PROP_ID = 30;
export const CERT_RENEWAL_PROP_ID = 64;
export const CERT_ARCHIVED_KEY_HASH_PROP_ID = 65;
export const CERT_AUTO_ENROLL_RETRY_PROP_ID = 66;
export const CERT_AIA_URL_RETRIEVED_PROP_ID = 67;
export const CERT_AUTHORITY_INFO_ACCESS_PROP_ID = 68;
export const CERT_BACKED_UP_PROP_ID = 69;
export const CERT_OCSP_RESPONSE_PROP_ID = 70;
export const CERT_REQUEST_ORIGINATOR_PROP_ID = 71;
export const CERT_SOURCE_LOCATION_PROP_ID = 72;
export const CERT_SOURCE_URL_PROP_ID = 73;
export const CERT_NEW_KEY_PROP_ID = 74;
export const CERT_OCSP_CACHE_PREFIX_PROP_ID = 75;
export const CERT_SMART_CARD_ROOT_INFO_PROP_ID = 76;
export const CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = 77;
export const CERT_NCRYPT_KEY_HANDLE_PROP_ID = 78;
export const CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = 79;
export const CERT_SUBJECT_INFO_ACCESS_PROP_ID = 80;
export const CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 81;
export const CERT_CA_DISABLE_CRL_PROP_ID = 82;
export const CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = 83;
export const CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = 84;
export const CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 85;
export const CERT_SUBJECT_DISABLE_CRL_PROP_ID = 86;
export const CERT_CEP_PROP_ID = 87;
export const CERT_SIGN_HASH_CNG_ALG_PROP_ID = 89;
export const CERT_SCARD_PIN_ID_PROP_ID = 90;
export const CERT_SCARD_PIN_INFO_PROP_ID = 91;
export const CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = 92;
export const CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 93;
export const CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = 94;
export const CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = 95;
export const CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 96;
export const CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = 97;
export const CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = 98;
export const CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = 99;
export const CERT_HCRYPTPROV_TRANSFER_PROP_ID = 100;
export const CERT_SMART_CARD_READER_PROP_ID = 101;
export const CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = 102;
export const CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = 103;
export const CERT_DISALLOWED_FILETIME_PROP_ID = 104;
export const CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = 105;
export const CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = 106;
export const CERT_SHA256_HASH_PROP_ID = 107;
export const CERT_SCEP_SERVER_CERTS_PROP_ID = 108;
export const CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = 109;
export const CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = 110;
export const CERT_SCEP_CA_CERT_PROP_ID = 111;
export const CERT_SCEP_SIGNER_CERT_PROP_ID = 112;
export const CERT_SCEP_NONCE_PROP_ID = 113;
export const CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = 114;
export const CERT_SCEP_FLAGS_PROP_ID = 115;
export const CERT_SCEP_GUID_PROP_ID = 116;
export const CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = 117;
export const CERT_ISOLATED_KEY_PROP_ID = 118;
export const CERT_SERIAL_CHAIN_PROP_ID = 119;
export const CERT_KEY_CLASSIFICATION_PROP_ID = 120;
export const CERT_OCSP_MUST_STAPLE_PROP_ID = 121;
export const CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = 122;
export const CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = 123;
export const CERT_PIN_SHA256_HASH_PROP_ID = 124;
export const CERT_CLR_DELETE_KEY_PROP_ID = 125;
export const CERT_NOT_BEFORE_FILETIME_PROP_ID = 126;
export const CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = 127;
export const CERT_FIRST_RESERVED_PROP_ID = 128;
export const CERT_LAST_RESERVED_PROP_ID = 32767;
export const CERT_FIRST_USER_PROP_ID = 32768;
export const CERT_LAST_USER_PROP_ID = 65535;
export const szOID_CERT_PROP_ID_PREFIX = `1.3.6.1.4.1.311.10.11.`;
export const szOID_CERT_KEY_IDENTIFIER_PROP_ID = `1.3.6.1.4.1.311.10.11.20`;
export const szOID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = `1.3.6.1.4.1.311.10.11.28`;
export const szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = `1.3.6.1.4.1.311.10.11.29`;
export const szOID_CERT_MD5_HASH_PROP_ID = `1.3.6.1.4.1.311.10.11.4`;
export const szOID_CERT_SIGNATURE_HASH_PROP_ID = `1.3.6.1.4.1.311.10.11.15`;
export const szOID_DISALLOWED_HASH = `1.3.6.1.4.1.311.10.11.15`;
export const szOID_CERT_DISALLOWED_FILETIME_PROP_ID = `1.3.6.1.4.1.311.10.11.104`;
export const CERT_ACCESS_STATE_WRITE_PERSIST_FLAG = 1;
export const CERT_ACCESS_STATE_SYSTEM_STORE_FLAG = 2;
export const CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG = 4;
export const CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG = 8;
export const CERT_ACCESS_STATE_SHARED_USER_FLAG = 16;
export const szOID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION = `1.3.6.1.4.1.311.60.3.1`;
export const szOID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION = `1.3.6.1.4.1.311.60.3.2`;
export const szOID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL = `1.3.6.1.4.1.311.60.3.3`;
export const CERT_STORE_PROV_MSG = 2216203124737;
export const CERT_STORE_PROV_MEMORY = 4415226380290;
export const CERT_STORE_PROV_FILE = 5514738008067;
export const CERT_STORE_PROV_REG = 1518001159355236356n;
export const CERT_STORE_PROV_PKCS7 = 6614249635845;
export const CERT_STORE_PROV_SERIALIZED = 7713761263622;
export const CERT_STORE_PROV_FILENAME_A = 290488781625098247n;
export const CERT_STORE_PROV_FILENAME_W = 16509854285832;
export const CERT_STORE_PROV_FILENAME = 8;
export const CERT_STORE_PROV_SYSTEM_A = 13211319402505;
export const CERT_STORE_PROV_SYSTEM_W = 12111807774730;
export const CERT_STORE_PROV_SYSTEM = 10;
export const CERT_STORE_PROV_COLLECTION = 1147907319267339;
export const CERT_STORE_PROV_SYSTEM_REGISTRY_A = 14310831030284;
export const CERT_STORE_PROV_SYSTEM_REGISTRY_W = 15410342658061;
export const CERT_STORE_PROV_SYSTEM_REGISTRY = 13;
export const CERT_STORE_PROV_PHYSICAL_W = 11012296146958;
export const CERT_STORE_PROV_PHYSICAL = 14;
export const CERT_STORE_PROV_SMART_CARD_W = 1806231535506948111n;
export const CERT_STORE_PROV_SMART_CARD = 15;
export const CERT_STORE_PROV_LDAP_W = 70385924046864;
export const CERT_STORE_PROV_LDAP = 16;
export const CERT_STORE_PROV_PKCS12 = 19808389169169;
export const sz_CERT_STORE_PROV_MEMORY = `Memory`;
export const sz_CERT_STORE_PROV_FILENAME_W = `File`;
export const sz_CERT_STORE_PROV_FILENAME = `File`;
export const sz_CERT_STORE_PROV_SYSTEM_W = `System`;
export const sz_CERT_STORE_PROV_SYSTEM = `System`;
export const sz_CERT_STORE_PROV_PKCS7 = `PKCS7`;
export const sz_CERT_STORE_PROV_PKCS12 = `PKCS12`;
export const sz_CERT_STORE_PROV_SERIALIZED = `Serialized`;
export const sz_CERT_STORE_PROV_COLLECTION = `Collection`;
export const sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W = `SystemRegistry`;
export const sz_CERT_STORE_PROV_SYSTEM_REGISTRY = `SystemRegistry`;
export const sz_CERT_STORE_PROV_PHYSICAL_W = `Physical`;
export const sz_CERT_STORE_PROV_PHYSICAL = `Physical`;
export const sz_CERT_STORE_PROV_SMART_CARD_W = `SmartCard`;
export const sz_CERT_STORE_PROV_SMART_CARD = `SmartCard`;
export const sz_CERT_STORE_PROV_LDAP_W = `Ldap`;
export const sz_CERT_STORE_PROV_LDAP = `Ldap`;
export const CERT_STORE_SIGNATURE_FLAG = 1;
export const CERT_STORE_TIME_VALIDITY_FLAG = 2;
export const CERT_STORE_REVOCATION_FLAG = 4;
export const CERT_STORE_NO_CRL_FLAG = 65536;
export const CERT_STORE_NO_ISSUER_FLAG = 131072;
export const CERT_STORE_BASE_CRL_FLAG = 256;
export const CERT_STORE_DELTA_CRL_FLAG = 512;
export const CERT_STORE_UNSAFE_PHYSICAL_FLAG = 32;
export const CERT_STORE_SHARE_STORE_FLAG = 64;
export const CERT_STORE_MANIFOLD_FLAG = 256;
export const CERT_SYSTEM_STORE_MASK = 4294901760;
export const CERT_SYSTEM_STORE_UNPROTECTED_FLAG = 1073741824;
export const CERT_SYSTEM_STORE_DEFER_READ_FLAG = 536870912;
export const CERT_SYSTEM_STORE_LOCATION_SHIFT = 16;
export const CERT_SYSTEM_STORE_CURRENT_USER_ID = 1;
export const CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2;
export const CERT_SYSTEM_STORE_CURRENT_SERVICE_ID = 4;
export const CERT_SYSTEM_STORE_SERVICES_ID = 5;
export const CERT_SYSTEM_STORE_USERS_ID = 6;
export const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID = 7;
export const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID = 8;
export const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID = 9;
export const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID = 10;
export const CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH = `Software\\Policies\\Microsoft\\SystemCertificates`;
export const CERT_EFSBLOB_VALUE_NAME = `EFSBlob`;
export const CERT_PROT_ROOT_FLAGS_VALUE_NAME = `Flags`;
export const CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG = 1;
export const CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG = 2;
export const CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG = 4;
export const CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG = 8;
export const CERT_PROT_ROOT_ONLY_LM_GPT_FLAG = 8;
export const CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG = 16;
export const CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG = 32;
export const CERT_PROT_ROOT_DISABLE_PEER_TRUST = 65536;
export const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME = `PeerUsages`;
export const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A = `PeerUsages`;
export const CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH = `Software\\Microsoft\\SystemCertificates`;
export const CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME = `AuthenticodeFlags`;
export const CERT_TRUST_PUB_ALLOW_TRUST_MASK = 3;
export const CERT_TRUST_PUB_ALLOW_END_USER_TRUST = 0;
export const CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST = 1;
export const CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST = 2;
export const CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG = 256;
export const CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG = 512;
export const CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH = `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents`;
export const CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME = `RootAutoUpdate`;
export const CERT_DISABLE_ROOT_AUTO_UPDATE_VALUE_NAME = `DisableRootAutoUpdate`;
export const CERT_ENABLE_DISALLOWED_CERT_AUTO_UPDATE_VALUE_NAME = `EnableDisallowedCertAutoUpdate`;
export const CERT_DISABLE_PIN_RULES_AUTO_UPDATE_VALUE_NAME = `DisablePinRulesAutoUpdate`;
export const CERT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME = `RootDirUrl`;
export const CERT_AUTO_UPDATE_SYNC_FROM_DIR_URL_VALUE_NAME = `SyncFromDirUrl`;
export const CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME = `RootDirUrl`;
export const CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = `SyncDeltaTime`;
export const CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME = `Flags`;
export const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG = 1;
export const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG = 2;
export const CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG = 4;
export const CERT_AUTH_ROOT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = `LastSyncTime`;
export const CERT_AUTH_ROOT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = `EncodedCtl`;
export const CERT_AUTH_ROOT_CTL_FILENAME = `authroot.stl`;
export const CERT_AUTH_ROOT_CTL_FILENAME_A = `authroot.stl`;
export const CERT_AUTH_ROOT_CAB_FILENAME = `authrootstl.cab`;
export const CERT_AUTH_ROOT_SEQ_FILENAME = `authrootseq.txt`;
export const CERT_AUTH_ROOT_CERT_EXT = `.crt`;
export const CERT_DISALLOWED_CERT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = `DisallowedCertSyncDeltaTime`;
export const CERT_DISALLOWED_CERT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = `DisallowedCertLastSyncTime`;
export const CERT_DISALLOWED_CERT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = `DisallowedCertEncodedCtl`;
export const CERT_DISALLOWED_CERT_CTL_FILENAME = `disallowedcert.stl`;
export const CERT_DISALLOWED_CERT_CTL_FILENAME_A = `disallowedcert.stl`;
export const CERT_DISALLOWED_CERT_CAB_FILENAME = `disallowedcertstl.cab`;
export const CERT_DISALLOWED_CERT_AUTO_UPDATE_LIST_IDENTIFIER = `DisallowedCert_AutoUpdate_1`;
export const CERT_PIN_RULES_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME = `PinRulesSyncDeltaTime`;
export const CERT_PIN_RULES_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME = `PinRulesLastSyncTime`;
export const CERT_PIN_RULES_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME = `PinRulesEncodedCtl`;
export const CERT_PIN_RULES_CTL_FILENAME = `pinrules.stl`;
export const CERT_PIN_RULES_CTL_FILENAME_A = `pinrules.stl`;
export const CERT_PIN_RULES_CAB_FILENAME = `pinrulesstl.cab`;
export const CERT_PIN_RULES_AUTO_UPDATE_LIST_IDENTIFIER = `PinRules_AutoUpdate_1`;
export const CERT_REGISTRY_STORE_REMOTE_FLAG = 65536;
export const CERT_REGISTRY_STORE_SERIALIZED_FLAG = 131072;
export const CERT_REGISTRY_STORE_CLIENT_GPT_FLAG = 2147483648;
export const CERT_REGISTRY_STORE_LM_GPT_FLAG = 16777216;
export const CERT_REGISTRY_STORE_ROAMING_FLAG = 262144;
export const CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = 524288;
export const CERT_REGISTRY_STORE_EXTERNAL_FLAG = 1048576;
export const CERT_IE_DIRTY_FLAGS_REGPATH = `Software\\Microsoft\\Cryptography\\IEDirtyFlags`;
export const CERT_FILE_STORE_COMMIT_ENABLE_FLAG = 65536;
export const CERT_LDAP_STORE_SIGN_FLAG = 65536;
export const CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG = 131072;
export const CERT_LDAP_STORE_OPENED_FLAG = 262144;
export const CERT_LDAP_STORE_UNBIND_FLAG = 524288;
export const CRYPT_OID_OPEN_STORE_PROV_FUNC = `CertDllOpenStoreProv`;
export const CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG = 32;
export const CERT_STORE_PROV_SHARED_USER_FLAG = 64;
export const CERT_STORE_PROV_CLOSE_FUNC = 0;
export const CERT_STORE_PROV_READ_CERT_FUNC = 1;
export const CERT_STORE_PROV_WRITE_CERT_FUNC = 2;
export const CERT_STORE_PROV_DELETE_CERT_FUNC = 3;
export const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC = 4;
export const CERT_STORE_PROV_READ_CRL_FUNC = 5;
export const CERT_STORE_PROV_WRITE_CRL_FUNC = 6;
export const CERT_STORE_PROV_DELETE_CRL_FUNC = 7;
export const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC = 8;
export const CERT_STORE_PROV_READ_CTL_FUNC = 9;
export const CERT_STORE_PROV_WRITE_CTL_FUNC = 10;
export const CERT_STORE_PROV_DELETE_CTL_FUNC = 11;
export const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC = 12;
export const CERT_STORE_PROV_CONTROL_FUNC = 13;
export const CERT_STORE_PROV_FIND_CERT_FUNC = 14;
export const CERT_STORE_PROV_FREE_FIND_CERT_FUNC = 15;
export const CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC = 16;
export const CERT_STORE_PROV_FIND_CRL_FUNC = 17;
export const CERT_STORE_PROV_FREE_FIND_CRL_FUNC = 18;
export const CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC = 19;
export const CERT_STORE_PROV_FIND_CTL_FUNC = 20;
export const CERT_STORE_PROV_FREE_FIND_CTL_FUNC = 21;
export const CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC = 22;
export const CERT_STORE_PROV_WRITE_ADD_FLAG = 1;
export const CERT_STORE_SAVE_AS_PKCS12 = 3;
export const CERT_CLOSE_STORE_FORCE_FLAG = 1;
export const CERT_CLOSE_STORE_CHECK_FLAG = 2;
export const CERT_COMPARE_MASK = 65535;
export const CERT_COMPARE_ANY = 0;
export const CERT_COMPARE_SHA1_HASH = 1;
export const CERT_COMPARE_NAME = 2;
export const CERT_COMPARE_ATTR = 3;
export const CERT_COMPARE_MD5_HASH = 4;
export const CERT_COMPARE_PROPERTY = 5;
export const CERT_COMPARE_PUBLIC_KEY = 6;
export const CERT_COMPARE_HASH = 1;
export const CERT_COMPARE_NAME_STR_A = 7;
export const CERT_COMPARE_NAME_STR_W = 8;
export const CERT_COMPARE_KEY_SPEC = 9;
export const CERT_COMPARE_ENHKEY_USAGE = 10;
export const CERT_COMPARE_CTL_USAGE = 10;
export const CERT_COMPARE_SUBJECT_CERT = 11;
export const CERT_COMPARE_ISSUER_OF = 12;
export const CERT_COMPARE_EXISTING = 13;
export const CERT_COMPARE_SIGNATURE_HASH = 14;
export const CERT_COMPARE_KEY_IDENTIFIER = 15;
export const CERT_COMPARE_CERT_ID = 16;
export const CERT_COMPARE_CROSS_CERT_DIST_POINTS = 17;
export const CERT_COMPARE_PUBKEY_MD5_HASH = 18;
export const CERT_COMPARE_SUBJECT_INFO_ACCESS = 19;
export const CERT_COMPARE_HASH_STR = 20;
export const CERT_COMPARE_HAS_PRIVATE_KEY = 21;
export const CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG = 2147483648;
export const CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG = 1073741824;
export const CTL_ENTRY_FROM_PROP_CHAIN_FLAG = 1;
export const CRL_FIND_ANY = 0;
export const CRL_FIND_ISSUED_BY = 1;
export const CRL_FIND_EXISTING = 2;
export const CRL_FIND_ISSUED_FOR = 3;
export const CRL_FIND_ISSUED_BY_AKI_FLAG = 1;
export const CRL_FIND_ISSUED_BY_SIGNATURE_FLAG = 2;
export const CRL_FIND_ISSUED_BY_DELTA_FLAG = 4;
export const CRL_FIND_ISSUED_BY_BASE_FLAG = 8;
export const CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG = 16;
export const CERT_STORE_ADD_NEW = 1;
export const CERT_STORE_ADD_USE_EXISTING = 2;
export const CERT_STORE_ADD_REPLACE_EXISTING = 3;
export const CERT_STORE_ADD_ALWAYS = 4;
export const CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = 5;
export const CERT_STORE_ADD_NEWER = 6;
export const CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES = 7;
export const CERT_STORE_CERTIFICATE_CONTEXT = 1;
export const CERT_STORE_CRL_CONTEXT = 2;
export const CERT_STORE_CTL_CONTEXT = 3;
export const CTL_ANY_SUBJECT_TYPE = 1;
export const CTL_CERT_SUBJECT_TYPE = 2;
export const CTL_FIND_NO_LIST_ID_CBDATA = 4294967295;
export const CERT_STORE_CTRL_RESYNC = 1;
export const CERT_STORE_CTRL_NOTIFY_CHANGE = 2;
export const CERT_STORE_CTRL_COMMIT = 3;
export const CERT_STORE_CTRL_AUTO_RESYNC = 4;
export const CERT_STORE_CTRL_CANCEL_NOTIFY = 5;
export const CERT_STORE_LOCALIZED_NAME_PROP_ID = 4096;
export const CERT_CREATE_CONTEXT_NOCOPY_FLAG = 1;
export const CERT_CREATE_CONTEXT_SORTED_FLAG = 2;
export const CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG = 4;
export const CERT_CREATE_CONTEXT_NO_ENTRY_FLAG = 8;
export const CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG = 1;
export const CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG = 2;
export const CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG = 4;
export const CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG = 8;
export const CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG = 1;
export const CERT_PHYSICAL_STORE_DEFAULT_NAME = `.Default`;
export const CERT_PHYSICAL_STORE_GROUP_POLICY_NAME = `.GroupPolicy`;
export const CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME = `.LocalMachine`;
export const CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME = `.UserCertificate`;
export const CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME = `.LocalMachineGroupPolicy`;
export const CERT_PHYSICAL_STORE_ENTERPRISE_NAME = `.Enterprise`;
export const CERT_PHYSICAL_STORE_AUTH_ROOT_NAME = `.AuthRoot`;
export const CERT_PHYSICAL_STORE_SMART_CARD_NAME = `.SmartCard`;
export const CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC = `CertDllOpenSystemStoreProv`;
export const CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC = `CertDllRegisterSystemStore`;
export const CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC = `CertDllUnregisterSystemStore`;
export const CRYPT_OID_ENUM_SYSTEM_STORE_FUNC = `CertDllEnumSystemStore`;
export const CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC = `CertDllRegisterPhysicalStore`;
export const CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC = `CertDllUnregisterPhysicalStore`;
export const CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC = `CertDllEnumPhysicalStore`;
export const CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME = `SystemStoreLocation`;
export const CMSG_TRUSTED_SIGNER_FLAG = 1;
export const CMSG_SIGNER_ONLY_FLAG = 2;
export const CMSG_USE_SIGNER_INDEX_FLAG = 4;
export const CMSG_CMS_ENCAPSULATED_CTL_FLAG = 32768;
export const CMSG_ENCODE_SORTED_CTL_FLAG = 1;
export const CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = 2;
export const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG = 1;
export const CERT_VERIFY_TRUSTED_SIGNERS_FLAG = 2;
export const CERT_VERIFY_NO_TIME_CHECK_FLAG = 4;
export const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG = 8;
export const CERT_VERIFY_UPDATED_CTL_FLAG = 1;
export const CERT_CONTEXT_REVOCATION_TYPE = 1;
export const CERT_VERIFY_REV_CHAIN_FLAG = 1;
export const CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION = 2;
export const CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG = 4;
export const CERT_VERIFY_REV_SERVER_OCSP_FLAG = 8;
export const CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG = 16;
export const CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG = 32;
export const CERT_UNICODE_IS_RDN_ATTRS_FLAG = 1;
export const CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG = 2;
export const CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB = 1;
export const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT = 2;
export const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL = 3;
export const CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE = 4;
export const CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY = 1;
export const CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT = 2;
export const CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN = 3;
export const CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL = 4;
export const CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG = 8;
export const CRYPT_OID_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = `CryptDllExtractEncodedSignatureParameters`;
export const CRYPT_OID_SIGN_AND_ENCODE_HASH_FUNC = `CryptDllSignAndEncodeHash`;
export const CRYPT_OID_VERIFY_ENCODED_SIGNATURE_FUNC = `CryptDllVerifyEncodedSignature`;
export const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC = `CryptDllExportPublicKeyInfoEx`;
export const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = `CryptDllExportPublicKeyInfoEx2`;
export const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = `CryptDllExportPublicKeyInfoFromBCryptKeyHandle`;
export const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC = `CryptDllImportPublicKeyInfoEx`;
export const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = `CryptDllImportPublicKeyInfoEx2`;
export const CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG = 128;
export const CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK = 458752;
export const CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG = 65536;
export const CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG = 131072;
export const CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG = 262144;
export const CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC = `CryptDllImportPrivateKeyInfoEx`;
export const CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC = `CryptDllExportPrivateKeyInfoEx`;
export const CRYPT_DELETE_KEYSET = 16;
export const CERT_XML_NAME_STR = 4;
export const CERT_NAME_STR_SEMICOLON_FLAG = 1073741824;
export const CERT_NAME_STR_NO_PLUS_FLAG = 536870912;
export const CERT_NAME_STR_NO_QUOTING_FLAG = 268435456;
export const CERT_NAME_STR_CRLF_FLAG = 134217728;
export const CERT_NAME_STR_COMMA_FLAG = 67108864;
export const CERT_NAME_STR_REVERSE_FLAG = 33554432;
export const CERT_NAME_STR_FORWARD_FLAG = 16777216;
export const CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = 65536;
export const CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = 131072;
export const CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = 262144;
export const CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = 524288;
export const CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = 1048576;
export const CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = 2097152;
export const CERT_NAME_EMAIL_TYPE = 1;
export const CERT_NAME_RDN_TYPE = 2;
export const CERT_NAME_ATTR_TYPE = 3;
export const CERT_NAME_SIMPLE_DISPLAY_TYPE = 4;
export const CERT_NAME_FRIENDLY_DISPLAY_TYPE = 5;
export const CERT_NAME_DNS_TYPE = 6;
export const CERT_NAME_URL_TYPE = 7;
export const CERT_NAME_UPN_TYPE = 8;
export const CERT_NAME_ISSUER_FLAG = 1;
export const CERT_NAME_DISABLE_IE4_UTF8_FLAG = 65536;
export const CERT_NAME_SEARCH_ALL_NAMES_FLAG = 2;
export const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG = 1;
export const CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG = 2;
export const CRYPT_MESSAGE_KEYID_SIGNER_FLAG = 4;
export const CRYPT_MESSAGE_SILENT_KEYSET_FLAG = 64;
export const CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG = 4;
export const CREDENTIAL_OID_PASSWORD_CREDENTIALS_A = 2216203124737;
export const CREDENTIAL_OID_PASSWORD_CREDENTIALS_W = 4415226380290;
export const CREDENTIAL_OID_PASSWORD_CREDENTIALS = 2;
export const SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC = `SchemeDllRetrieveEncodedObject`;
export const SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC = `SchemeDllRetrieveEncodedObjectW`;
export const CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC = `ContextDllCreateObjectContext`;
export const CONTEXT_OID_CERTIFICATE = 2216203124737;
export const CONTEXT_OID_CRL = 4415226380290;
export const CONTEXT_OID_CTL = 5514738008067;
export const CONTEXT_OID_PKCS7 = 1518001159355236356n;
export const CONTEXT_OID_CAPI2_ANY = 6614249635845;
export const CONTEXT_OID_OCSP_RESP = 7713761263622;
export const CRYPT_RETRIEVE_MULTIPLE_OBJECTS = 1;
export const CRYPT_CACHE_ONLY_RETRIEVAL = 2;
export const CRYPT_WIRE_ONLY_RETRIEVAL = 4;
export const CRYPT_DONT_CACHE_RESULT = 8;
export const CRYPT_ASYNC_RETRIEVAL = 16;
export const CRYPT_STICKY_CACHE_RETRIEVAL = 4096;
export const CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL = 8192;
export const CRYPT_OFFLINE_CHECK_RETRIEVAL = 16384;
export const CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE = 32768;
export const CRYPT_LDAP_SIGN_RETRIEVAL = 65536;
export const CRYPT_NO_AUTH_RETRIEVAL = 131072;
export const CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL = 262144;
export const CRYPT_AIA_RETRIEVAL = 524288;
export const CRYPT_HTTP_POST_RETRIEVAL = 1048576;
export const CRYPT_PROXY_CACHE_RETRIEVAL = 2097152;
export const CRYPT_NOT_MODIFIED_RETRIEVAL = 4194304;
export const CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL = 8388608;
export const CRYPT_RANDOM_QUERY_STRING_RETRIEVAL = 67108864;
export const CRYPT_ENABLE_FILE_RETRIEVAL = 134217728;
export const CRYPT_CREATE_NEW_FLUSH_ENTRY = 268435456;
export const CRYPT_VERIFY_CONTEXT_SIGNATURE = 32;
export const CRYPT_VERIFY_DATA_HASH = 64;
export const CRYPT_KEEP_TIME_VALID = 128;
export const CRYPT_DONT_VERIFY_SIGNATURE = 256;
export const CRYPT_DONT_CHECK_TIME_VALIDITY = 512;
export const CRYPT_CHECK_FRESHNESS_TIME_VALIDITY = 1024;
export const CRYPT_ACCUMULATIVE_TIMEOUT = 2048;
export const CRYPT_OCSP_ONLY_RETRIEVAL = 16777216;
export const CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL = 33554432;
export const CRYPTNET_URL_CACHE_PRE_FETCH_NONE = 0;
export const CRYPTNET_URL_CACHE_PRE_FETCH_BLOB = 1;
export const CRYPTNET_URL_CACHE_PRE_FETCH_CRL = 2;
export const CRYPTNET_URL_CACHE_PRE_FETCH_OCSP = 3;
export const CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB = 5;
export const CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB = 6;
export const CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB = 7;
export const CRYPTNET_URL_CACHE_DEFAULT_FLUSH = 0;
export const CRYPTNET_URL_CACHE_DISABLE_FLUSH = 4294967295;
export const CRYPTNET_URL_CACHE_RESPONSE_NONE = 0;
export const CRYPTNET_URL_CACHE_RESPONSE_HTTP = 1;
export const CRYPTNET_URL_CACHE_RESPONSE_VALIDATED = 32768;
export const CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH = 4096;
export const CRYPT_PARAM_ASYNC_RETRIEVAL_COMPLETION = 2216203124737;
export const CRYPT_PARAM_CANCEL_ASYNC_RETRIEVAL = 4415226380290;
export const URL_OID_GET_OBJECT_URL_FUNC = `UrlDllGetObjectUrl`;
export const URL_OID_CERTIFICATE_ISSUER = 2216203124737;
export const URL_OID_CERTIFICATE_CRL_DIST_POINT = 4415226380290;
export const URL_OID_CTL_ISSUER = 5514738008067;
export const URL_OID_CTL_NEXT_UPDATE = 1518001159355236356n;
export const URL_OID_CRL_ISSUER = 6614249635845;
export const URL_OID_CERTIFICATE_FRESHEST_CRL = 7713761263622;
export const URL_OID_CRL_FRESHEST_CRL = 290488781625098247n;
export const URL_OID_CROSS_CERT_DIST_POINT = 16509854285832;
export const URL_OID_CERTIFICATE_OCSP = 13211319402505;
export const URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT = 12111807774730;
export const URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP = 1147907319267339;
export const URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS = 14310831030284;
export const URL_OID_CERTIFICATE_ONLY_OCSP = 15410342658061;
export const TIME_VALID_OID_GET_OBJECT_FUNC = `TimeValidDllGetObject`;
export const TIME_VALID_OID_GET_CTL = 2216203124737;
export const TIME_VALID_OID_GET_CRL = 4415226380290;
export const TIME_VALID_OID_GET_CRL_FROM_CERT = 5514738008067;
export const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT = 1518001159355236356n;
export const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL = 6614249635845;
export const TIME_VALID_OID_FLUSH_OBJECT_FUNC = `TimeValidDllFlushObject`;
export const TIME_VALID_OID_FLUSH_CTL = 2216203124737;
export const TIME_VALID_OID_FLUSH_CRL = 4415226380290;
export const TIME_VALID_OID_FLUSH_CRL_FROM_CERT = 5514738008067;
export const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT = 1518001159355236356n;
export const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL = 6614249635845;
export const CRYPT_KEYID_MACHINE_FLAG = 32;
export const CRYPT_KEYID_ALLOC_FLAG = 32768;
export const CRYPT_KEYID_DELETE_FLAG = 16;
export const CRYPT_KEYID_SET_NEW_FLAG = 8192;
export const CERT_CHAIN_CONFIG_REGPATH = `Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\CertDllCreateCertificateChainEngine\\Config`;
export const CERT_CHAIN_MAX_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME = `MaxUrlRetrievalByteCount`;
export const CERT_CHAIN_CACHE_RESYNC_FILETIME_VALUE_NAME = `ChainCacheResyncFiletime`;
export const CERT_CHAIN_DISABLE_MANDATORY_BASIC_CONSTRAINTS_VALUE_NAME = `DisableMandatoryBasicConstraints`;
export const CERT_CHAIN_DISABLE_CA_NAME_CONSTRAINTS_VALUE_NAME = `DisableCANameConstraints`;
export const CERT_CHAIN_DISABLE_UNSUPPORTED_CRITICAL_EXTENSIONS_VALUE_NAME = `DisableUnsupportedCriticalExtensions`;
export const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME = `MaxAIAUrlCountInCert`;
export const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT = 5;
export const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME = `MaxAIAUrlRetrievalCountPerChain`;
export const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT = 3;
export const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME = `MaxAIAUrlRetrievalByteCount`;
export const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT = 100000;
export const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME = `MaxAIAUrlRetrievalCertCount`;
export const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT = 10;
export const CERT_CHAIN_OCSP_VALIDITY_SECONDS_VALUE_NAME = `OcspValiditySeconds`;
export const CERT_CHAIN_DISABLE_SERIAL_CHAIN_VALUE_NAME = `DisableSerialChain`;
export const CERT_CHAIN_SERIAL_CHAIN_LOG_FILE_NAME_VALUE_NAME = `SerialChainLogFileName`;
export const CERT_CHAIN_DISABLE_SYNC_WITH_SSL_TIME_VALUE_NAME = `DisableSyncWithSslTime`;
export const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_VALUE_NAME = `MaxSslTimeUpdatedEventCount`;
export const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT = 5;
export const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE = 4294967295;
export const CERT_CHAIN_SSL_HANDSHAKE_LOG_FILE_NAME_VALUE_NAME = `SslHandshakeLogFileName`;
export const CERT_CHAIN_ENABLE_WEAK_SIGNATURE_FLAGS_VALUE_NAME = `EnableWeakSignatureFlags`;
export const CERT_CHAIN_ENABLE_MD2_MD4_FLAG = 1;
export const CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG = 2;
export const CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG = 4;
export const CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG = 8;
export const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME = `MinRsaPubKeyBitLength`;
export const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT = 1023;
export const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE = 4294967295;
export const CERT_CHAIN_WEAK_RSA_PUB_KEY_TIME_VALUE_NAME = `WeakRsaPubKeyTime`;
export const CERT_CHAIN_WEAK_SIGNATURE_LOG_DIR_VALUE_NAME = `WeakSignatureLogDir`;
export const CERT_CHAIN_DEFAULT_CONFIG_SUBDIR = `Default`;
export const CERT_CHAIN_WEAK_PREFIX_NAME = `Weak`;
export const CERT_CHAIN_WEAK_THIRD_PARTY_CONFIG_NAME = `ThirdParty`;
export const CERT_CHAIN_WEAK_ALL_CONFIG_NAME = `All`;
export const CERT_CHAIN_WEAK_FLAGS_NAME = `Flags`;
export const CERT_CHAIN_WEAK_HYGIENE_NAME = `Hygiene`;
export const CERT_CHAIN_WEAK_AFTER_TIME_NAME = `AfterTime`;
export const CERT_CHAIN_WEAK_FILE_HASH_AFTER_TIME_NAME = `FileHashAfterTime`;
export const CERT_CHAIN_WEAK_TIMESTAMP_HASH_AFTER_TIME_NAME = `TimestampHashAfterTime`;
export const CERT_CHAIN_WEAK_MIN_BIT_LENGTH_NAME = `MinBitLength`;
export const CERT_CHAIN_WEAK_SHA256_ALLOW_NAME = `Sha256Allow`;
export const CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE = 4294967295;
export const CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG = 2147483648;
export const CERT_CHAIN_DISABLE_ECC_PARA_FLAG = 16;
export const CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG = 65536;
export const CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG = 131072;
export const CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG = 262144;
export const CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG = 1048576;
export const CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG = 2097152;
export const CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG = 4194304;
export const CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG = 8388608;
export const CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG = 16777216;
export const CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG = 33554432;
export const CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG = 67108864;
export const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG = 134217728;
export const CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG = 268435456;
export const CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG = 536870912;
export const CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG = 1073741824;
export const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG = 4096;
export const CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG = 8192;
export const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG = 16384;
export const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG = 32768;
export const CERT_CHAIN_OPT_IN_WEAK_FLAGS = 262144;
export const CERT_CHAIN_AUTO_CURRENT_USER = 1;
export const CERT_CHAIN_AUTO_LOCAL_MACHINE = 2;
export const CERT_CHAIN_AUTO_IMPERSONATED = 3;
export const CERT_CHAIN_AUTO_PROCESS_INFO = 4;
export const CERT_CHAIN_AUTO_PINRULE_INFO = 5;
export const CERT_CHAIN_AUTO_NETWORK_INFO = 6;
export const CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE = 7;
export const CERT_CHAIN_AUTO_HPKP_RULE_INFO = 8;
export const CERT_CHAIN_AUTO_FLAGS_VALUE_NAME = `AutoFlags`;
export const CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG = 1;
export const CERT_CHAIN_AUTO_LOG_CREATE_FLAG = 2;
export const CERT_CHAIN_AUTO_LOG_FREE_FLAG = 4;
export const CERT_CHAIN_AUTO_LOG_FLUSH_FLAG = 8;
export const CERT_CHAIN_AUTO_FLUSH_FIRST_DELTA_SECONDS_VALUE_NAME = `AutoFlushFirstDeltaSeconds`;
export const CERT_CHAIN_AUTO_FLUSH_NEXT_DELTA_SECONDS_VALUE_NAME = `AutoFlushNextDeltaSeconds`;
export const CERT_CHAIN_AUTO_LOG_FILE_NAME_VALUE_NAME = `AutoLogFileName`;
export const CERT_CHAIN_DISABLE_AUTO_FLUSH_PROCESS_NAME_LIST_VALUE_NAME = `DisableAutoFlushProcessNameList`;
export const CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME = `SrvOcspRespMinValiditySeconds`;
export const CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = `SrvOcspRespUrlRetrievalTimeoutMilliseconds`;
export const CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = `SrvOcspRespMaxBeforeNextUpdateSeconds`;
export const CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = `SrvOcspRespMinBeforeNextUpdateSeconds`;
export const CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME = `SrvOcspRespMinAfterNextUpdateSeconds`;
export const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_VALUE_NAME = `SrvOcspRespMinSyncCertFileSeconds`;
export const CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT = 5;
export const CERT_SRV_OCSP_RESP_MAX_SYNC_CERT_FILE_SECONDS_VALUE_NAME = `SrvOcspRespMaxSyncCertFileSeconds`;
export const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_VALUE_NAME = `CryptnetMaxCachedOcspPerCrlCount`;
export const CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT = 500;
export const CRYPTNET_OCSP_AFTER_CRL_DISABLE = 4294967295;
export const CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_VALUE_NAME = `CryptnetDefaultFlushExemptSeconds`;
export const CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_VALUE_NAME = `CryptnetPreFetchMinMaxAgeSeconds`;
export const CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_VALUE_NAME = `CryptnetPreFetchMaxMaxAgeSeconds`;
export const CRYPTNET_PRE_FETCH_MIN_OCSP_VALIDITY_PERIOD_SECONDS_VALUE_NAME = `CryptnetPreFetchMinOcspValidityPeriodSeconds`;
export const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_VALUE_NAME = `CryptnetPreFetchAfterPublishPreFetchDivisor`;
export const CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT = 10;
export const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME = `CryptnetPreFetchBeforeNextUpdatePreFetchDivisor`;
export const CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = 20;
export const CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = `CryptnetPreFetchMinBeforeNextUpdatePreFetchSeconds`;
export const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME = `CryptnetPreFetchValidityPeriodAfterNextUpdatePreFetchDivisor`;
export const CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT = 10;
export const CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = `CryptnetPreFetchMaxAfterNextUpdatePreFetchPeriodSeconds`;
export const CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = `CryptnetPreFetchMinAfterNextUpdatePreFetchPeriodSeconds`;
export const CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME = `CryptnetPreFetchAfterCurrentTimePreFetchPeriodSeconds`;
export const CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_VALUE_NAME = `CryptnetPreFetchTriggerPeriodSeconds`;
export const CRYPTNET_PRE_FETCH_TRIGGER_DISABLE = 4294967295;
export const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_VALUE_NAME = `CryptnetPreFetchScanAfterTriggerDelaySeconds`;
export const CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT = 60;
export const CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_VALUE_NAME = `CryptnetPreFetchRetrievalTimeoutSeconds`;
export const CRYPTNET_CRL_PRE_FETCH_PROCESS_NAME_LIST_VALUE_NAME = `ProcessNameList`;
export const CRYPTNET_CRL_PRE_FETCH_URL_LIST_VALUE_NAME = `PreFetchUrlList`;
export const CRYPTNET_CRL_PRE_FETCH_DISABLE_INFORMATION_EVENTS_VALUE_NAME = `DisableInformationEvents`;
export const CRYPTNET_CRL_PRE_FETCH_LOG_FILE_NAME_VALUE_NAME = `LogFileName`;
export const CRYPTNET_CRL_PRE_FETCH_TIMEOUT_SECONDS_VALUE_NAME = `TimeoutSeconds`;
export const CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_VALUE_NAME = `MaxAgeSeconds`;
export const CRYPTNET_CRL_PRE_FETCH_PUBLISH_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = `PublishBeforeNextUpdateSeconds`;
export const CRYPTNET_CRL_PRE_FETCH_PUBLISH_RANDOM_INTERVAL_SECONDS_VALUE_NAME = `PublishRandomIntervalSeconds`;
export const CRYPTNET_CRL_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME = `MinBeforeNextUpdateSeconds`;
export const CRYPTNET_CRL_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME = `MinAfterNextUpdateSeconds`;
export const CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = `ChainUrlRetrievalTimeoutMilliseconds`;
export const CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME = `ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds`;
export const CERT_RETR_BEHAVIOR_INET_AUTH_VALUE_NAME = `EnableInetUnknownAuth`;
export const CERT_RETR_BEHAVIOR_INET_STATUS_VALUE_NAME = `EnableInetLocal`;
export const CERT_RETR_BEHAVIOR_FILE_VALUE_NAME = `AllowFileUrlScheme`;
export const CERT_RETR_BEHAVIOR_LDAP_VALUE_NAME = `DisableLDAPSignAndEncrypt`;
export const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_VALUE_NAME = `CryptnetCachedOcspSwitchToCrlCount`;
export const CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT = 50;
export const CRYPTNET_CRL_BEFORE_OCSP_ENABLE = 4294967295;
export const CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME = `DisableAIAUrlRetrieval`;
export const CERT_CHAIN_OPTIONS_VALUE_NAME = `Options`;
export const CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL = 2;
export const CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL = 4;
export const CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_VALUE_NAME = `CrossCertDownloadIntervalHours`;
export const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_VALUE_NAME = `CRLValidityExtensionPeriod`;
export const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT = 12;
export const CERT_CHAIN_CACHE_END_CERT = 1;
export const CERT_CHAIN_THREAD_STORE_SYNC = 2;
export const CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL = 4;
export const CERT_CHAIN_USE_LOCAL_MACHINE_STORE = 8;
export const CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE = 16;
export const CERT_CHAIN_ENABLE_SHARE_STORE = 32;
export const CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG = 1;
export const CERT_TRUST_NO_ERROR = 0;
export const CERT_TRUST_IS_NOT_TIME_VALID = 1;
export const CERT_TRUST_IS_NOT_TIME_NESTED = 2;
export const CERT_TRUST_IS_REVOKED = 4;
export const CERT_TRUST_IS_NOT_SIGNATURE_VALID = 8;
export const CERT_TRUST_IS_NOT_VALID_FOR_USAGE = 16;
export const CERT_TRUST_IS_UNTRUSTED_ROOT = 32;
export const CERT_TRUST_REVOCATION_STATUS_UNKNOWN = 64;
export const CERT_TRUST_IS_CYCLIC = 128;
export const CERT_TRUST_INVALID_EXTENSION = 256;
export const CERT_TRUST_INVALID_POLICY_CONSTRAINTS = 512;
export const CERT_TRUST_INVALID_BASIC_CONSTRAINTS = 1024;
export const CERT_TRUST_INVALID_NAME_CONSTRAINTS = 2048;
export const CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 4096;
export const CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT = 8192;
export const CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 16384;
export const CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT = 32768;
export const CERT_TRUST_IS_OFFLINE_REVOCATION = 16777216;
export const CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY = 33554432;
export const CERT_TRUST_IS_EXPLICIT_DISTRUST = 67108864;
export const CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT = 134217728;
export const CERT_TRUST_HAS_WEAK_SIGNATURE = 1048576;
export const CERT_TRUST_HAS_WEAK_HYGIENE = 2097152;
export const CERT_TRUST_IS_PARTIAL_CHAIN = 65536;
export const CERT_TRUST_CTL_IS_NOT_TIME_VALID = 131072;
export const CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID = 262144;
export const CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = 524288;
export const CERT_TRUST_HAS_EXACT_MATCH_ISSUER = 1;
export const CERT_TRUST_HAS_KEY_MATCH_ISSUER = 2;
export const CERT_TRUST_HAS_NAME_MATCH_ISSUER = 4;
export const CERT_TRUST_IS_SELF_SIGNED = 8;
export const CERT_TRUST_AUTO_UPDATE_CA_REVOCATION = 16;
export const CERT_TRUST_AUTO_UPDATE_END_REVOCATION = 32;
export const CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL = 64;
export const CERT_TRUST_IS_KEY_ROLLOVER = 128;
export const CERT_TRUST_SSL_HANDSHAKE_OCSP = 262144;
export const CERT_TRUST_SSL_TIME_VALID_OCSP = 524288;
export const CERT_TRUST_SSL_RECONNECT_OCSP = 1048576;
export const CERT_TRUST_HAS_PREFERRED_ISSUER = 256;
export const CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY = 512;
export const CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS = 1024;
export const CERT_TRUST_IS_PEER_TRUSTED = 2048;
export const CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED = 4096;
export const CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = 8192;
export const CERT_TRUST_IS_CA_TRUSTED = 16384;
export const CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE = 32768;
export const CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE = 131072;
export const CERT_TRUST_IS_COMPLEX_CHAIN = 65536;
export const CERT_TRUST_SSL_TIME_VALID = 16777216;
export const CERT_TRUST_NO_TIME_CHECK = 33554432;
export const USAGE_MATCH_TYPE_AND = 0;
export const USAGE_MATCH_TYPE_OR = 1;
export const CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG = 1;
export const CERT_CHAIN_REVOCATION_CHECK_END_CERT = 268435456;
export const CERT_CHAIN_REVOCATION_CHECK_CHAIN = 536870912;
export const CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = 1073741824;
export const CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY = 2147483648;
export const CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT = 134217728;
export const CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT = 67108864;
export const CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING = 64;
export const CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS = 128;
export const CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE = 256;
export const CERT_CHAIN_TIMESTAMP_TIME = 512;
export const CERT_CHAIN_ENABLE_PEER_TRUST = 1024;
export const CERT_CHAIN_DISABLE_MY_PEER_TRUST = 2048;
export const CERT_CHAIN_DISABLE_MD2_MD4 = 4096;
export const CERT_CHAIN_DISABLE_AIA = 8192;
export const CERT_CHAIN_HAS_MOTW = 16384;
export const CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT = 32768;
export const CERT_CHAIN_OPT_IN_WEAK_SIGNATURE = 65536;
export const REVOCATION_OID_CRL_REVOCATION = 2216203124737;
export const CERT_CHAIN_FIND_BY_ISSUER = 1;
export const CERT_CHAIN_POLICY_IGNORE_WEAK_SIGNATURE_FLAG = 134217728;
export const CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC = `CertDllVerifyCertificateChainPolicy`;
export const CERT_CHAIN_POLICY_BASE = 2216203124737;
export const CERT_CHAIN_POLICY_AUTHENTICODE = 4415226380290;
export const CERT_CHAIN_POLICY_AUTHENTICODE_TS = 5514738008067;
export const CERT_CHAIN_POLICY_SSL = 1518001159355236356n;
export const CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = 6614249635845;
export const CERT_CHAIN_POLICY_NT_AUTH = 7713761263622;
export const CERT_CHAIN_POLICY_MICROSOFT_ROOT = 290488781625098247n;
export const CERT_CHAIN_POLICY_EV = 16509854285832;
export const CERT_CHAIN_POLICY_SSL_F12 = 13211319402505;
export const CERT_CHAIN_POLICY_SSL_HPKP_HEADER = 12111807774730;
export const CERT_CHAIN_POLICY_THIRD_PARTY_ROOT = 1147907319267339;
export const CERT_CHAIN_POLICY_SSL_KEY_PIN = 14310831030284;
export const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG = 2147483648;
export const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG = 1073741824;
export const MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG = 65536;
export const MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = 131072;
export const MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG = 262144;
export const SSL_F12_ERROR_TEXT_LENGTH = 256;
export const CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL = 0;
export const CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL = 1;
export const CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL = 2;
export const CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY = 0;
export const CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY = 1;
export const CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY = 2;
export const SSL_HPKP_PKP_HEADER_INDEX = 0;
export const SSL_HPKP_PKP_RO_HEADER_INDEX = 1;
export const SSL_HPKP_HEADER_COUNT = 2;
export const SSL_KEY_PIN_ERROR_TEXT_LENGTH = 512;
export const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR = `-2`;
export const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR = `-1`;
export const CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS = 0;
export const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING = 1;
export const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING = 2;
export const CRYPT_STRING_BASE64URI = 13;
export const CRYPT_STRING_ENCODEMASK = 255;
export const CRYPT_STRING_RESERVED100 = 256;
export const CRYPT_STRING_RESERVED200 = 512;
export const CRYPT_STRING_PERCENTESCAPE = 134217728;
export const CRYPT_STRING_HASHDATA = 268435456;
export const CRYPT_STRING_NOCRLF = 1073741824;
export const CRYPT_STRING_NOCR = 2147483648;
export const szOID_PKCS_12_PbeIds = `1.2.840.113549.1.12.1`;
export const szOID_PKCS_12_pbeWithSHA1And128BitRC4 = `1.2.840.113549.1.12.1.1`;
export const szOID_PKCS_12_pbeWithSHA1And40BitRC4 = `1.2.840.113549.1.12.1.2`;
export const szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES = `1.2.840.113549.1.12.1.3`;
export const szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES = `1.2.840.113549.1.12.1.4`;
export const szOID_PKCS_12_pbeWithSHA1And128BitRC2 = `1.2.840.113549.1.12.1.5`;
export const szOID_PKCS_12_pbeWithSHA1And40BitRC2 = `1.2.840.113549.1.12.1.6`;
export const szOID_PKCS_5_PBKDF2 = `1.2.840.113549.1.5.12`;
export const szOID_PKCS_5_PBES2 = `1.2.840.113549.1.5.13`;
export const PKCS12_IMPORT_SILENT = 64;
export const PKCS12_ONLY_CERTIFICATES = 1024;
export const PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES = 2048;
export const PKCS12_VIRTUAL_ISOLATION_KEY = 65536;
export const PKCS12_IMPORT_RESERVED_MASK = 4294901760;
export const PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE = 0;
export const PKCS12_ONLY_CERTIFICATES_PROVIDER_NAME = `PfxProvider`;
export const PKCS12_ONLY_CERTIFICATES_CONTAINER_NAME = `PfxContainer`;
export const REPORT_NO_PRIVATE_KEY = 1;
export const REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY = 2;
export const EXPORT_PRIVATE_KEYS = 4;
export const PKCS12_PROTECT_TO_DOMAIN_SIDS = 32;
export const PKCS12_EXPORT_SILENT = 64;
export const PKCS12_EXPORT_PBES2_PARAMS = 128;
export const PKCS12_DISABLE_ENCRYPT_CERTIFICATES = 256;
export const PKCS12_ENCRYPT_CERTIFICATES = 512;
export const PKCS12_EXPORT_ECC_CURVE_PARAMETERS = 4096;
export const PKCS12_EXPORT_ECC_CURVE_OID = 8192;
export const PKCS12_EXPORT_RESERVED_MASK = 4294901760;
export const PKCS12_PBKDF2_ID_HMAC_SHA1 = `1.2.840.113549.2.7`;
export const PKCS12_PBKDF2_ID_HMAC_SHA256 = `1.2.840.113549.2.9`;
export const PKCS12_PBKDF2_ID_HMAC_SHA384 = `1.2.840.113549.2.10`;
export const PKCS12_PBKDF2_ID_HMAC_SHA512 = `1.2.840.113549.2.11`;
export const PKCS12_PBES2_ALG_AES256_SHA256 = `AES256-SHA256`;
export const PKCS12_CONFIG_REGPATH = `Software\\Microsoft\\Windows\\CurrentVersion\\PFX`;
export const PKCS12_ENCRYPT_CERTIFICATES_VALUE_NAME = `EncryptCertificates`;
export const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG = 1;
export const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG = 2;
export const CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG = 1;
export const CERT_RETRIEVE_ISSUER_LOGO = 2216203124737;
export const CERT_RETRIEVE_SUBJECT_LOGO = 4415226380290;
export const CERT_RETRIEVE_COMMUNITY_LOGO = 5514738008067;
export const CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE = 1100628319273960;
export const CERT_SELECT_MAX_PARA = 500;
export const CERT_SELECT_BY_ISSUER_DISPLAYNAME = 12;
export const CERT_SELECT_BY_FRIENDLYNAME = 13;
export const CERT_SELECT_BY_THUMBPRINT = 14;
export const CERT_SELECT_ALLOW_EXPIRED = 1;
export const CERT_SELECT_TRUSTED_ROOT = 2;
export const CERT_SELECT_DISALLOW_SELFSIGNED = 4;
export const CERT_SELECT_HAS_PRIVATE_KEY = 8;
export const CERT_SELECT_HAS_KEY_FOR_SIGNATURE = 16;
export const CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE = 32;
export const CERT_SELECT_HARDWARE_ONLY = 64;
export const CERT_SELECT_ALLOW_DUPLICATES = 128;
export const CERT_SELECT_IGNORE_AUTOSELECT = 256;
export const TIMESTAMP_FAILURE_BAD_ALG = 0;
export const TIMESTAMP_FAILURE_BAD_REQUEST = 2;
export const TIMESTAMP_FAILURE_BAD_FORMAT = 5;
export const TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE = 14;
export const TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED = 15;
export const TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED = 16;
export const TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE = 17;
export const TIMESTAMP_FAILURE_SYSTEM_FAILURE = 25;
export const TIMESTAMP_DONT_HASH_DATA = 1;
export const TIMESTAMP_VERIFY_CONTEXT_SIGNATURE = 32;
export const TIMESTAMP_NO_AUTH_RETRIEVAL = 131072;
export const CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE = 1;
export const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE = 32;
export const CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE = 33;
export const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE = 65535;
export const SSL_OBJECT_LOCATOR_PFX_FUNC = `SslObjectLocatorInitializePfx`;
export const SSL_OBJECT_LOCATOR_ISSUER_LIST_FUNC = `SslObjectLocatorInitializeIssuerList`;
export const SSL_OBJECT_LOCATOR_CERT_VALIDATION_CONFIG_FUNC = `SslObjectLocatorInitializeCertValidationConfig`;
export const CERT_FILE_HASH_USE_TYPE = 1;
export const CERT_TIMESTAMP_HASH_USE_TYPE = 2;
export const RECIPIENTPOLICYV1 = 1;
export const RECIPIENTPOLICYV2 = 2;
export const E_ICARD_COMMUNICATION = 360570565079400704n;
export const E_ICARD_DATA_ACCESS = 360571664591028481n;
export const E_ICARD_EXPORT = 360572764102656258n;
export const E_ICARD_IDENTITY = 360573863614284035n;
export const E_ICARD_IMPORT = 360574963125911812n;
export const E_ICARD_ARGUMENT = 360576062637539589n;
export const E_ICARD_REQUEST = 360577162149167366n;
export const E_ICARD_INFORMATIONCARD = 360578261660795143n;
export const E_ICARD_STOREKEY = 360579361172422920n;
export const E_ICARD_LOGOVALIDATION = 360580460684050697n;
export const E_ICARD_PASSWORDVALIDATION = 360581560195678474n;
export const E_ICARD_POLICY = 360582659707306251n;
export const E_ICARD_PROCESSDIED = 360583759218934028n;
export const E_ICARD_SERVICEBUSY = 360584858730561805n;
export const E_ICARD_SERVICE = 360585958242189582n;
export const E_ICARD_SHUTTINGDOWN = 360587057753817359n;
export const E_ICARD_TOKENCREATION = 360588157265445136n;
export const E_ICARD_TRUSTEXCHANGE = 360589256777072913n;
export const E_ICARD_UNTRUSTED = 360590356288700690n;
export const E_ICARD_USERCANCELLED = 360591455800328467n;
export const E_ICARD_STORE_IMPORT = 360592555311956244n;
export const E_ICARD_FAIL = 360598052870095125n;
export const E_ICARD_UI_INITIALIZATION = 360710203056128282n;
export const E_ICARD_REFRESH_REQUIRED = 360711302567756160n;
export const E_ICARD_MISSING_APPLIESTO = 360712402079383937n;
export const E_ICARD_INVALID_PROOF_KEY = 360713501591011714n;
export const E_ICARD_UNKNOWN_REFERENCE = 360714601102639491n;
export const E_ICARD_FAILED_REQUIRED_CLAIMS = 360850940544483716n;
export const AUDIT_CARD_WRITTEN = 360852037908627968n;
export const AUDIT_CARD_DELETE = 360853137420255745n;
export const AUDIT_CARD_IMPORT = 360854236931883522n;
export const AUDIT_STORE_IMPORT = 360855336443511299n;
export const AUDIT_STORE_EXPORT = 360856435955139076n;
export const AUDIT_STORE_DELETE = 360857535466766853n;
export const AUDIT_SERVICE_IDLE_STOP = 1226386526142005766n;
export const szOID_CATALOG_LIST = `1.3.6.1.4.1.311.12.1.1`;
export const szOID_CATALOG_LIST_MEMBER = `1.3.6.1.4.1.311.12.1.2`;
export const szOID_CATALOG_LIST_MEMBER2 = `1.3.6.1.4.1.311.12.1.3`;
export const CRYPTCAT_FILEEXT = `CAT`;
export const CRYPTCAT_MAX_MEMBERTAG = 64;
export const CRYPTCAT_MEMBER_SORTED = 1073741824;
export const CRYPTCAT_ATTR_AUTHENTICATED = 268435456;
export const CRYPTCAT_ATTR_UNAUTHENTICATED = 536870912;
export const CRYPTCAT_ATTR_NAMEASCII = 1;
export const CRYPTCAT_ATTR_NAMEOBJID = 2;
export const CRYPTCAT_ATTR_DATAASCII = 65536;
export const CRYPTCAT_ATTR_DATABASE64 = 131072;
export const CRYPTCAT_ATTR_DATAREPLACE = 262144;
export const CRYPTCAT_ATTR_NO_AUTO_COMPAT_ENTRY = 16777216;
export const CRYPTCAT_E_AREA_HEADER = 0;
export const CRYPTCAT_E_AREA_MEMBER = 65536;
export const CRYPTCAT_E_AREA_ATTRIBUTE = 131072;
export const CRYPTCAT_E_CDF_UNSUPPORTED = 1;
export const CRYPTCAT_E_CDF_DUPLICATE = 2;
export const CRYPTCAT_E_CDF_TAGNOTFOUND = 4;
export const CRYPTCAT_E_CDF_MEMBER_FILE_PATH = 65537;
export const CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA = 65538;
export const CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND = 65540;
export const CRYPTCAT_E_CDF_BAD_GUID_CONV = 131073;
export const CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES = 131074;
export const CRYPTCAT_E_CDF_ATTR_TYPECOMBO = 131076;
export const CRYPTCAT_ADDCATALOG_NONE = 0;
export const CRYPTCAT_ADDCATALOG_HARDLINK = 1;
export const MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE = 65536;
export const MSSIP_FLAGS_USE_CATALOG = 131072;
export const MSSIP_FLAGS_MULTI_HASH = 262144;
export const SPC_INC_PE_RESOURCES_FLAG = 128;
export const SPC_INC_PE_DEBUG_INFO_FLAG = 64;
export const SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG = 32;
export const SPC_EXC_PE_PAGE_HASHES_FLAG = 16;
export const SPC_INC_PE_PAGE_HASHES_FLAG = 256;
export const SPC_DIGEST_GENERATE_FLAG = 512;
export const SPC_DIGEST_SIGN_FLAG = 1024;
export const SPC_DIGEST_SIGN_EX_FLAG = 16384;
export const SPC_RELAXED_PE_MARKER_CHECK = 2048;
export const SPC_MARKER_CHECK_SKIP_SIP_INDIRECT_DATA_FLAG = 1;
export const SPC_MARKER_CHECK_CURRENTLY_SUPPORTED_FLAGS = 1;
export const MSSIP_ADDINFO_NONE = 0;
export const MSSIP_ADDINFO_FLAT = 1;
export const MSSIP_ADDINFO_CATMEMBER = 2;
export const MSSIP_ADDINFO_BLOB = 3;
export const MSSIP_ADDINFO_NONMSSIP = 500;
export const SIP_CAP_SET_VERSION_2 = 2;
export const SIP_CAP_SET_VERSION_3 = 3;
export const SIP_CAP_SET_CUR_VER = 3;
export const SIP_CAP_FLAG_SEALING = 1;
export const SIP_MAX_MAGIC_NUMBER = 4;
export const CRYTPDLG_FLAGS_MASK = 4278190080;
export const CRYPTDLG_REVOCATION_DEFAULT = 0;
export const CRYPTDLG_REVOCATION_ONLINE = 2147483648;
export const CRYPTDLG_REVOCATION_CACHE = 1073741824;
export const CRYPTDLG_REVOCATION_NONE = 536870912;
export const CRYPTDLG_CACHE_ONLY_URL_RETRIEVAL = 268435456;
export const CRYPTDLG_DISABLE_AIA = 134217728;
export const CRYPTDLG_POLICY_MASK = 65535;
export const POLICY_IGNORE_NON_CRITICAL_BC = 1;
export const CRYPTDLG_ACTION_MASK = 4294901760;
export const ACTION_REVOCATION_DEFAULT_ONLINE = 65536;
export const ACTION_REVOCATION_DEFAULT_CACHE = 131072;
export const CERT_DISPWELL_SELECT = 1;
export const CERT_DISPWELL_TRUST_CA_CERT = 2;
export const CERT_DISPWELL_TRUST_LEAF_CERT = 3;
export const CERT_DISPWELL_TRUST_ADD_CA_CERT = 4;
export const CERT_DISPWELL_TRUST_ADD_LEAF_CERT = 5;
export const CERT_DISPWELL_DISTRUST_CA_CERT = 6;
export const CERT_DISPWELL_DISTRUST_LEAF_CERT = 7;
export const CERT_DISPWELL_DISTRUST_ADD_CA_CERT = 8;
export const CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT = 9;
export const CSS_SELECTCERT_MASK = 16777215;
export const SELCERT_PROPERTIES = 100;
export const SELCERT_FINEPRINT = 101;
export const SELCERT_CERTLIST = 102;
export const SELCERT_ISSUED_TO = 103;
export const SELCERT_VALIDITY = 104;
export const SELCERT_ALGORITHM = 105;
export const SELCERT_SERIAL_NUM = 106;
export const SELCERT_THUMBPRINT = 107;
export const CM_VIEWFLAGS_MASK = 16777215;
export const CERTVIEW_CRYPTUI_LPARAM = 8388608;
export const CERT_FILTER_OP_EXISTS = 1;
export const CERT_FILTER_OP_NOT_EXISTS = 2;
export const CERT_FILTER_OP_EQUALITY = 3;
export const CERT_FILTER_INCLUDE_V1_CERTS = 1;
export const CERT_FILTER_VALID_TIME_RANGE = 2;
export const CERT_FILTER_VALID_SIGNATURE = 4;
export const CERT_FILTER_LEAF_CERTS_ONLY = 8;
export const CERT_FILTER_ISSUER_CERTS_ONLY = 16;
export const CERT_FILTER_KEY_EXISTS = 32;
export const szCERT_CERTIFICATE_ACTION_VERIFY = `{7801ebd0-cf4b-11d0-851f-0060979387ea}`;
export const CERT_VALIDITY_BEFORE_START = 1;
export const CERT_VALIDITY_AFTER_END = 2;
export const CERT_VALIDITY_SIGNATURE_FAILS = 4;
export const CERT_VALIDITY_CERTIFICATE_REVOKED = 8;
export const CERT_VALIDITY_KEY_USAGE_EXT_FAILURE = 16;
export const CERT_VALIDITY_EXTENDED_USAGE_FAILURE = 32;
export const CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE = 64;
export const CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION = 128;
export const CERT_VALIDITY_ISSUER_INVALID = 256;
export const CERT_VALIDITY_OTHER_EXTENSION_FAILURE = 512;
export const CERT_VALIDITY_PERIOD_NESTING_FAILURE = 1024;
export const CERT_VALIDITY_OTHER_ERROR = 2048;
export const CERT_VALIDITY_ISSUER_DISTRUST = 33554432;
export const CERT_VALIDITY_EXPLICITLY_DISTRUSTED = 16777216;
export const CERT_VALIDITY_NO_ISSUER_CERT_FOUND = 268435456;
export const CERT_VALIDITY_NO_CRL_FOUND = 536870912;
export const CERT_VALIDITY_CRL_OUT_OF_DATE = 1073741824;
export const CERT_VALIDITY_NO_TRUST_DATA = 2147483648;
export const CERT_VALIDITY_MASK_TRUST = 4294901760;
export const CERT_VALIDITY_MASK_VALIDITY = 65535;
export const CERT_TRUST_MASK = 16777215;
export const CERT_TRUST_DO_FULL_SEARCH = 1;
export const CERT_TRUST_PERMIT_MISSING_CRLS = 2;
export const CERT_TRUST_DO_FULL_TRUST = 5;
export const CERT_CREDENTIAL_PROVIDER_ID = `-509`;
export const CRYPTUI_SELECT_ISSUEDTO_COLUMN = 1;
export const CRYPTUI_SELECT_ISSUEDBY_COLUMN = 2;
export const CRYPTUI_SELECT_INTENDEDUSE_COLUMN = 4;
export const CRYPTUI_SELECT_FRIENDLYNAME_COLUMN = 8;
export const CRYPTUI_SELECT_LOCATION_COLUMN = 16;
export const CRYPTUI_SELECT_EXPIRATION_COLUMN = 32;
export const CRYPTUI_CERT_MGR_TAB_MASK = 15;
export const CRYPTUI_CERT_MGR_PUBLISHER_TAB = 4;
export const CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG = 32768;
export const CRYPTUI_WIZ_DIGITAL_SIGN_EXCLUDE_PAGE_HASHES = 2;
export const CRYPTUI_WIZ_DIGITAL_SIGN_INCLUDE_PAGE_HASHES = 4;
export const CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE = 5;
export const OCSP_SF_SILENT = 1;
export const OCSP_SF_USE_CACERT = 2;
export const OCSP_SF_ALLOW_SIGNINGCERT_AUTORENEWAL = 4;
export const OCSP_SF_FORCE_SIGNINGCERT_ISSUER_ISCA = 8;
export const OCSP_SF_AUTODISCOVER_SIGNINGCERT = 16;
export const OCSP_SF_MANUAL_ASSIGN_SIGNINGCERT = 32;
export const OCSP_SF_RESPONDER_ID_KEYHASH = 64;
export const OCSP_SF_RESPONDER_ID_NAME = 128;
export const OCSP_SF_ALLOW_NONCE_EXTENSION = 256;
export const OCSP_SF_ALLOW_SIGNINGCERT_AUTOENROLLMENT = 512;
export const OCSP_RF_REJECT_SIGNED_REQUESTS = 1;
export const X509AuthNone = 0;
export const X509AuthAnonymous = 1;
export const X509AuthKerberos = 2;
export const X509AuthUsername = 4;
export const X509AuthCertificate = 8;
export const SCEPMessageUnknown = `-1`;
export const SCEPMessageCertResponse = 3;
export const SCEPMessagePKCSRequest = 19;
export const SCEPMessageGetCertInitial = 20;
export const SCEPMessageGetCert = 21;
export const SCEPMessageGetCRL = 22;
export const SCEPMessageClaimChallengeAnswer = 41;
export const SCEPDispositionUnknown = `-1`;
export const SCEPDispositionSuccess = 0;
export const SCEPDispositionFailure = 2;
export const SCEPDispositionPending = 3;
export const SCEPDispositionPendingChallenge = 11;
export const SCEPFailUnknown = `-1`;
export const SCEPFailBadAlgorithm = 0;
export const SCEPFailBadMessageCheck = 1;
export const SCEPFailBadRequest = 2;
export const SCEPFailBadTime = 3;
export const SCEPFailBadCertId = 4;
export const XCN_OID_NONE = 0;
export const XCN_OID_RSA = 1;
export const XCN_OID_PKCS = 2;
export const XCN_OID_RSA_HASH = 3;
export const XCN_OID_RSA_ENCRYPT = 4;
export const XCN_OID_PKCS_1 = 5;
export const XCN_OID_PKCS_2 = 6;
export const XCN_OID_PKCS_3 = 7;
export const XCN_OID_PKCS_4 = 8;
export const XCN_OID_PKCS_5 = 9;
export const XCN_OID_PKCS_6 = 10;
export const XCN_OID_PKCS_7 = 11;
export const XCN_OID_PKCS_8 = 12;
export const XCN_OID_PKCS_9 = 13;
export const XCN_OID_PKCS_10 = 14;
export const XCN_OID_PKCS_12 = 15;
export const XCN_OID_RSA_RSA = 16;
export const XCN_OID_RSA_MD2RSA = 17;
export const XCN_OID_RSA_MD4RSA = 18;
export const XCN_OID_RSA_MD5RSA = 19;
export const XCN_OID_RSA_SHA1RSA = 20;
export const XCN_OID_RSA_SETOAEP_RSA = 21;
export const XCN_OID_RSA_DH = 22;
export const XCN_OID_RSA_data = 23;
export const XCN_OID_RSA_signedData = 24;
export const XCN_OID_RSA_envelopedData = 25;
export const XCN_OID_RSA_signEnvData = 26;
export const XCN_OID_RSA_digestedData = 27;
export const XCN_OID_RSA_hashedData = 28;
export const XCN_OID_RSA_encryptedData = 29;
export const XCN_OID_RSA_emailAddr = 30;
export const XCN_OID_RSA_unstructName = 31;
export const XCN_OID_RSA_contentType = 32;
export const XCN_OID_RSA_messageDigest = 33;
export const XCN_OID_RSA_signingTime = 34;
export const XCN_OID_RSA_counterSign = 35;
export const XCN_OID_RSA_challengePwd = 36;
export const XCN_OID_RSA_unstructAddr = 37;
export const XCN_OID_RSA_extCertAttrs = 38;
export const XCN_OID_RSA_certExtensions = 39;
export const XCN_OID_RSA_SMIMECapabilities = 40;
export const XCN_OID_RSA_preferSignedData = 41;
export const XCN_OID_RSA_SMIMEalg = 42;
export const XCN_OID_RSA_SMIMEalgESDH = 43;
export const XCN_OID_RSA_SMIMEalgCMS3DESwrap = 44;
export const XCN_OID_RSA_SMIMEalgCMSRC2wrap = 45;
export const XCN_OID_RSA_MD2 = 46;
export const XCN_OID_RSA_MD4 = 47;
export const XCN_OID_RSA_MD5 = 48;
export const XCN_OID_RSA_RC2CBC = 49;
export const XCN_OID_RSA_RC4 = 50;
export const XCN_OID_RSA_DES_EDE3_CBC = 51;
export const XCN_OID_RSA_RC5_CBCPad = 52;
export const XCN_OID_ANSI_X942 = 53;
export const XCN_OID_ANSI_X942_DH = 54;
export const XCN_OID_X957 = 55;
export const XCN_OID_X957_DSA = 56;
export const XCN_OID_X957_SHA1DSA = 57;
export const XCN_OID_DS = 58;
export const XCN_OID_DSALG = 59;
export const XCN_OID_DSALG_CRPT = 60;
export const XCN_OID_DSALG_HASH = 61;
export const XCN_OID_DSALG_SIGN = 62;
export const XCN_OID_DSALG_RSA = 63;
export const XCN_OID_OIW = 64;
export const XCN_OID_OIWSEC = 65;
export const XCN_OID_OIWSEC_md4RSA = 66;
export const XCN_OID_OIWSEC_md5RSA = 67;
export const XCN_OID_OIWSEC_md4RSA2 = 68;
export const XCN_OID_OIWSEC_desECB = 69;
export const XCN_OID_OIWSEC_desCBC = 70;
export const XCN_OID_OIWSEC_desOFB = 71;
export const XCN_OID_OIWSEC_desCFB = 72;
export const XCN_OID_OIWSEC_desMAC = 73;
export const XCN_OID_OIWSEC_rsaSign = 74;
export const XCN_OID_OIWSEC_dsa = 75;
export const XCN_OID_OIWSEC_shaDSA = 76;
export const XCN_OID_OIWSEC_mdc2RSA = 77;
export const XCN_OID_OIWSEC_shaRSA = 78;
export const XCN_OID_OIWSEC_dhCommMod = 79;
export const XCN_OID_OIWSEC_desEDE = 80;
export const XCN_OID_OIWSEC_sha = 81;
export const XCN_OID_OIWSEC_mdc2 = 82;
export const XCN_OID_OIWSEC_dsaComm = 83;
export const XCN_OID_OIWSEC_dsaCommSHA = 84;
export const XCN_OID_OIWSEC_rsaXchg = 85;
export const XCN_OID_OIWSEC_keyHashSeal = 86;
export const XCN_OID_OIWSEC_md2RSASign = 87;
export const XCN_OID_OIWSEC_md5RSASign = 88;
export const XCN_OID_OIWSEC_sha1 = 89;
export const XCN_OID_OIWSEC_dsaSHA1 = 90;
export const XCN_OID_OIWSEC_dsaCommSHA1 = 91;
export const XCN_OID_OIWSEC_sha1RSASign = 92;
export const XCN_OID_OIWDIR = 93;
export const XCN_OID_OIWDIR_CRPT = 94;
export const XCN_OID_OIWDIR_HASH = 95;
export const XCN_OID_OIWDIR_SIGN = 96;
export const XCN_OID_OIWDIR_md2 = 97;
export const XCN_OID_OIWDIR_md2RSA = 98;
export const XCN_OID_INFOSEC = 99;
export const XCN_OID_INFOSEC_sdnsSignature = 100;
export const XCN_OID_INFOSEC_mosaicSignature = 101;
export const XCN_OID_INFOSEC_sdnsConfidentiality = 102;
export const XCN_OID_INFOSEC_mosaicConfidentiality = 103;
export const XCN_OID_INFOSEC_sdnsIntegrity = 104;
export const XCN_OID_INFOSEC_mosaicIntegrity = 105;
export const XCN_OID_INFOSEC_sdnsTokenProtection = 106;
export const XCN_OID_INFOSEC_mosaicTokenProtection = 107;
export const XCN_OID_INFOSEC_sdnsKeyManagement = 108;
export const XCN_OID_INFOSEC_mosaicKeyManagement = 109;
export const XCN_OID_INFOSEC_sdnsKMandSig = 110;
export const XCN_OID_INFOSEC_mosaicKMandSig = 111;
export const XCN_OID_INFOSEC_SuiteASignature = 112;
export const XCN_OID_INFOSEC_SuiteAConfidentiality = 113;
export const XCN_OID_INFOSEC_SuiteAIntegrity = 114;
export const XCN_OID_INFOSEC_SuiteATokenProtection = 115;
export const XCN_OID_INFOSEC_SuiteAKeyManagement = 116;
export const XCN_OID_INFOSEC_SuiteAKMandSig = 117;
export const XCN_OID_INFOSEC_mosaicUpdatedSig = 118;
export const XCN_OID_INFOSEC_mosaicKMandUpdSig = 119;
export const XCN_OID_INFOSEC_mosaicUpdatedInteg = 120;
export const XCN_OID_COMMON_NAME = 121;
export const XCN_OID_SUR_NAME = 122;
export const XCN_OID_DEVICE_SERIAL_NUMBER = 123;
export const XCN_OID_COUNTRY_NAME = 124;
export const XCN_OID_LOCALITY_NAME = 125;
export const XCN_OID_STATE_OR_PROVINCE_NAME = 126;
export const XCN_OID_STREET_ADDRESS = 127;
export const XCN_OID_ORGANIZATION_NAME = 128;
export const XCN_OID_ORGANIZATIONAL_UNIT_NAME = 129;
export const XCN_OID_TITLE = 130;
export const XCN_OID_DESCRIPTION = 131;
export const XCN_OID_SEARCH_GUIDE = 132;
export const XCN_OID_BUSINESS_CATEGORY = 133;
export const XCN_OID_POSTAL_ADDRESS = 134;
export const XCN_OID_POSTAL_CODE = 135;
export const XCN_OID_POST_OFFICE_BOX = 136;
export const XCN_OID_PHYSICAL_DELIVERY_OFFICE_NAME = 137;
export const XCN_OID_TELEPHONE_NUMBER = 138;
export const XCN_OID_TELEX_NUMBER = 139;
export const XCN_OID_TELETEXT_TERMINAL_IDENTIFIER = 140;
export const XCN_OID_FACSIMILE_TELEPHONE_NUMBER = 141;
export const XCN_OID_X21_ADDRESS = 142;
export const XCN_OID_INTERNATIONAL_ISDN_NUMBER = 143;
export const XCN_OID_REGISTERED_ADDRESS = 144;
export const XCN_OID_DESTINATION_INDICATOR = 145;
export const XCN_OID_PREFERRED_DELIVERY_METHOD = 146;
export const XCN_OID_PRESENTATION_ADDRESS = 147;
export const XCN_OID_SUPPORTED_APPLICATION_CONTEXT = 148;
export const XCN_OID_MEMBER = 149;
export const XCN_OID_OWNER = 150;
export const XCN_OID_ROLE_OCCUPANT = 151;
export const XCN_OID_SEE_ALSO = 152;
export const XCN_OID_USER_PASSWORD = 153;
export const XCN_OID_USER_CERTIFICATE = 154;
export const XCN_OID_CA_CERTIFICATE = 155;
export const XCN_OID_AUTHORITY_REVOCATION_LIST = 156;
export const XCN_OID_CERTIFICATE_REVOCATION_LIST = 157;
export const XCN_OID_CROSS_CERTIFICATE_PAIR = 158;
export const XCN_OID_GIVEN_NAME = 159;
export const XCN_OID_INITIALS = 160;
export const XCN_OID_DN_QUALIFIER = 161;
export const XCN_OID_DOMAIN_COMPONENT = 162;
export const XCN_OID_PKCS_12_FRIENDLY_NAME_ATTR = 163;
export const XCN_OID_PKCS_12_LOCAL_KEY_ID = 164;
export const XCN_OID_PKCS_12_KEY_PROVIDER_NAME_ATTR = 165;
export const XCN_OID_LOCAL_MACHINE_KEYSET = 166;
export const XCN_OID_PKCS_12_EXTENDED_ATTRIBUTES = 167;
export const XCN_OID_KEYID_RDN = 168;
export const XCN_OID_AUTHORITY_KEY_IDENTIFIER = 169;
export const XCN_OID_KEY_ATTRIBUTES = 170;
export const XCN_OID_CERT_POLICIES_95 = 171;
export const XCN_OID_KEY_USAGE_RESTRICTION = 172;
export const XCN_OID_SUBJECT_ALT_NAME = 173;
export const XCN_OID_ISSUER_ALT_NAME = 174;
export const XCN_OID_BASIC_CONSTRAINTS = 175;
export const XCN_OID_KEY_USAGE = 176;
export const XCN_OID_PRIVATEKEY_USAGE_PERIOD = 177;
export const XCN_OID_BASIC_CONSTRAINTS2 = 178;
export const XCN_OID_CERT_POLICIES = 179;
export const XCN_OID_ANY_CERT_POLICY = 180;
export const XCN_OID_AUTHORITY_KEY_IDENTIFIER2 = 181;
export const XCN_OID_SUBJECT_KEY_IDENTIFIER = 182;
export const XCN_OID_SUBJECT_ALT_NAME2 = 183;
export const XCN_OID_ISSUER_ALT_NAME2 = 184;
export const XCN_OID_CRL_REASON_CODE = 185;
export const XCN_OID_REASON_CODE_HOLD = 186;
export const XCN_OID_CRL_DIST_POINTS = 187;
export const XCN_OID_ENHANCED_KEY_USAGE = 188;
export const XCN_OID_CRL_NUMBER = 189;
export const XCN_OID_DELTA_CRL_INDICATOR = 190;
export const XCN_OID_ISSUING_DIST_POINT = 191;
export const XCN_OID_FRESHEST_CRL = 192;
export const XCN_OID_NAME_CONSTRAINTS = 193;
export const XCN_OID_POLICY_MAPPINGS = 194;
export const XCN_OID_LEGACY_POLICY_MAPPINGS = 195;
export const XCN_OID_POLICY_CONSTRAINTS = 196;
export const XCN_OID_RENEWAL_CERTIFICATE = 197;
export const XCN_OID_ENROLLMENT_NAME_VALUE_PAIR = 198;
export const XCN_OID_ENROLLMENT_CSP_PROVIDER = 199;
export const XCN_OID_OS_VERSION = 200;
export const XCN_OID_ENROLLMENT_AGENT = 201;
export const XCN_OID_PKIX = 202;
export const XCN_OID_PKIX_PE = 203;
export const XCN_OID_AUTHORITY_INFO_ACCESS = 204;
export const XCN_OID_BIOMETRIC_EXT = 205;
export const XCN_OID_LOGOTYPE_EXT = 206;
export const XCN_OID_CERT_EXTENSIONS = 207;
export const XCN_OID_NEXT_UPDATE_LOCATION = 208;
export const XCN_OID_REMOVE_CERTIFICATE = 209;
export const XCN_OID_CROSS_CERT_DIST_POINTS = 210;
export const XCN_OID_CTL = 211;
export const XCN_OID_SORTED_CTL = 212;
export const XCN_OID_SERIALIZED = 213;
export const XCN_OID_NT_PRINCIPAL_NAME = 214;
export const XCN_OID_PRODUCT_UPDATE = 215;
export const XCN_OID_ANY_APPLICATION_POLICY = 216;
export const XCN_OID_AUTO_ENROLL_CTL_USAGE = 217;
export const XCN_OID_ENROLL_CERTTYPE_EXTENSION = 218;
export const XCN_OID_CERT_MANIFOLD = 219;
export const XCN_OID_CERTSRV_CA_VERSION = 220;
export const XCN_OID_CERTSRV_PREVIOUS_CERT_HASH = 221;
export const XCN_OID_CRL_VIRTUAL_BASE = 222;
export const XCN_OID_CRL_NEXT_PUBLISH = 223;
export const XCN_OID_KP_CA_EXCHANGE = 224;
export const XCN_OID_KP_KEY_RECOVERY_AGENT = 225;
export const XCN_OID_CERTIFICATE_TEMPLATE = 226;
export const XCN_OID_ENTERPRISE_OID_ROOT = 227;
export const XCN_OID_RDN_DUMMY_SIGNER = 228;
export const XCN_OID_APPLICATION_CERT_POLICIES = 229;
export const XCN_OID_APPLICATION_POLICY_MAPPINGS = 230;
export const XCN_OID_APPLICATION_POLICY_CONSTRAINTS = 231;
export const XCN_OID_ARCHIVED_KEY_ATTR = 232;
export const XCN_OID_CRL_SELF_CDP = 233;
export const XCN_OID_REQUIRE_CERT_CHAIN_POLICY = 234;
export const XCN_OID_ARCHIVED_KEY_CERT_HASH = 235;
export const XCN_OID_ISSUED_CERT_HASH = 236;
export const XCN_OID_DS_EMAIL_REPLICATION = 237;
export const XCN_OID_REQUEST_CLIENT_INFO = 238;
export const XCN_OID_ENCRYPTED_KEY_HASH = 239;
export const XCN_OID_CERTSRV_CROSSCA_VERSION = 240;
export const XCN_OID_NTDS_REPLICATION = 241;
export const XCN_OID_SUBJECT_DIR_ATTRS = 242;
export const XCN_OID_PKIX_KP = 243;
export const XCN_OID_PKIX_KP_SERVER_AUTH = 244;
export const XCN_OID_PKIX_KP_CLIENT_AUTH = 245;
export const XCN_OID_PKIX_KP_CODE_SIGNING = 246;
export const XCN_OID_PKIX_KP_EMAIL_PROTECTION = 247;
export const XCN_OID_PKIX_KP_IPSEC_END_SYSTEM = 248;
export const XCN_OID_PKIX_KP_IPSEC_TUNNEL = 249;
export const XCN_OID_PKIX_KP_IPSEC_USER = 250;
export const XCN_OID_PKIX_KP_TIMESTAMP_SIGNING = 251;
export const XCN_OID_PKIX_KP_OCSP_SIGNING = 252;
export const XCN_OID_PKIX_OCSP_NOCHECK = 253;
export const XCN_OID_IPSEC_KP_IKE_INTERMEDIATE = 254;
export const XCN_OID_KP_CTL_USAGE_SIGNING = 255;
export const XCN_OID_KP_TIME_STAMP_SIGNING = 256;
export const XCN_OID_SERVER_GATED_CRYPTO = 257;
export const XCN_OID_SGC_NETSCAPE = 258;
export const XCN_OID_KP_EFS = 259;
export const XCN_OID_EFS_RECOVERY = 260;
export const XCN_OID_WHQL_CRYPTO = 261;
export const XCN_OID_NT5_CRYPTO = 262;
export const XCN_OID_OEM_WHQL_CRYPTO = 263;
export const XCN_OID_EMBEDDED_NT_CRYPTO = 264;
export const XCN_OID_ROOT_LIST_SIGNER = 265;
export const XCN_OID_KP_QUALIFIED_SUBORDINATION = 266;
export const XCN_OID_KP_KEY_RECOVERY = 267;
export const XCN_OID_KP_DOCUMENT_SIGNING = 268;
export const XCN_OID_KP_LIFETIME_SIGNING = 269;
export const XCN_OID_KP_MOBILE_DEVICE_SOFTWARE = 270;
export const XCN_OID_KP_SMART_DISPLAY = 271;
export const XCN_OID_KP_CSP_SIGNATURE = 272;
export const XCN_OID_DRM = 273;
export const XCN_OID_DRM_INDIVIDUALIZATION = 274;
export const XCN_OID_LICENSES = 275;
export const XCN_OID_LICENSE_SERVER = 276;
export const XCN_OID_KP_SMARTCARD_LOGON = 277;
export const XCN_OID_YESNO_TRUST_ATTR = 278;
export const XCN_OID_PKIX_POLICY_QUALIFIER_CPS = 279;
export const XCN_OID_PKIX_POLICY_QUALIFIER_USERNOTICE = 280;
export const XCN_OID_CERT_POLICIES_95_QUALIFIER1 = 281;
export const XCN_OID_PKIX_ACC_DESCR = 282;
export const XCN_OID_PKIX_OCSP = 283;
export const XCN_OID_PKIX_CA_ISSUERS = 284;
export const XCN_OID_VERISIGN_PRIVATE_6_9 = 285;
export const XCN_OID_VERISIGN_ONSITE_JURISDICTION_HASH = 286;
export const XCN_OID_VERISIGN_BITSTRING_6_13 = 287;
export const XCN_OID_VERISIGN_ISS_STRONG_CRYPTO = 288;
export const XCN_OID_NETSCAPE = 289;
export const XCN_OID_NETSCAPE_CERT_EXTENSION = 290;
export const XCN_OID_NETSCAPE_CERT_TYPE = 291;
export const XCN_OID_NETSCAPE_BASE_URL = 292;
export const XCN_OID_NETSCAPE_REVOCATION_URL = 293;
export const XCN_OID_NETSCAPE_CA_REVOCATION_URL = 294;
export const XCN_OID_NETSCAPE_CERT_RENEWAL_URL = 295;
export const XCN_OID_NETSCAPE_CA_POLICY_URL = 296;
export const XCN_OID_NETSCAPE_SSL_SERVER_NAME = 297;
export const XCN_OID_NETSCAPE_COMMENT = 298;
export const XCN_OID_NETSCAPE_DATA_TYPE = 299;
export const XCN_OID_NETSCAPE_CERT_SEQUENCE = 300;
export const XCN_OID_CT_PKI_DATA = 301;
export const XCN_OID_CT_PKI_RESPONSE = 302;
export const XCN_OID_PKIX_NO_SIGNATURE = 303;
export const XCN_OID_CMC = 304;
export const XCN_OID_CMC_STATUS_INFO = 305;
export const XCN_OID_CMC_IDENTIFICATION = 306;
export const XCN_OID_CMC_IDENTITY_PROOF = 307;
export const XCN_OID_CMC_DATA_RETURN = 308;
export const XCN_OID_CMC_TRANSACTION_ID = 309;
export const XCN_OID_CMC_SENDER_NONCE = 310;
export const XCN_OID_CMC_RECIPIENT_NONCE = 311;
export const XCN_OID_CMC_ADD_EXTENSIONS = 312;
export const XCN_OID_CMC_ENCRYPTED_POP = 313;
export const XCN_OID_CMC_DECRYPTED_POP = 314;
export const XCN_OID_CMC_LRA_POP_WITNESS = 315;
export const XCN_OID_CMC_GET_CERT = 316;
export const XCN_OID_CMC_GET_CRL = 317;
export const XCN_OID_CMC_REVOKE_REQUEST = 318;
export const XCN_OID_CMC_REG_INFO = 319;
export const XCN_OID_CMC_RESPONSE_INFO = 320;
export const XCN_OID_CMC_QUERY_PENDING = 321;
export const XCN_OID_CMC_ID_POP_LINK_RANDOM = 322;
export const XCN_OID_CMC_ID_POP_LINK_WITNESS = 323;
export const XCN_OID_CMC_ID_CONFIRM_CERT_ACCEPTANCE = 324;
export const XCN_OID_CMC_ADD_ATTRIBUTES = 325;
export const XCN_OID_LOYALTY_OTHER_LOGOTYPE = 326;
export const XCN_OID_BACKGROUND_OTHER_LOGOTYPE = 327;
export const XCN_OID_PKIX_OCSP_BASIC_SIGNED_RESPONSE = 328;
export const XCN_OID_PKCS_7_DATA = 329;
export const XCN_OID_PKCS_7_SIGNED = 330;
export const XCN_OID_PKCS_7_ENVELOPED = 331;
export const XCN_OID_PKCS_7_SIGNEDANDENVELOPED = 332;
export const XCN_OID_PKCS_7_DIGESTED = 333;
export const XCN_OID_PKCS_7_ENCRYPTED = 334;
export const XCN_OID_PKCS_9_CONTENT_TYPE = 335;
export const XCN_OID_PKCS_9_MESSAGE_DIGEST = 336;
export const XCN_OID_CERT_PROP_ID_PREFIX = 337;
export const XCN_OID_CERT_KEY_IDENTIFIER_PROP_ID = 338;
export const XCN_OID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = 339;
export const XCN_OID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = 340;
export const XCN_OID_CERT_MD5_HASH_PROP_ID = 341;
export const XCN_OID_RSA_SHA256RSA = 342;
export const XCN_OID_RSA_SHA384RSA = 343;
export const XCN_OID_RSA_SHA512RSA = 344;
export const XCN_OID_NIST_sha256 = 345;
export const XCN_OID_NIST_sha384 = 346;
export const XCN_OID_NIST_sha512 = 347;
export const XCN_OID_RSA_MGF1 = 348;
export const XCN_OID_ECC_PUBLIC_KEY = 349;
export const XCN_OID_ECDSA_SHA1 = 350;
export const XCN_OID_ECDSA_SPECIFIED = 351;
export const XCN_OID_ANY_ENHANCED_KEY_USAGE = 352;
export const XCN_OID_RSA_SSA_PSS = 353;
export const XCN_OID_ATTR_SUPPORTED_ALGORITHMS = 355;
export const XCN_OID_ATTR_TPM_SECURITY_ASSERTIONS = 356;
export const XCN_OID_ATTR_TPM_SPECIFICATION = 357;
export const XCN_OID_CERT_DISALLOWED_FILETIME_PROP_ID = 358;
export const XCN_OID_CERT_SIGNATURE_HASH_PROP_ID = 359;
export const XCN_OID_CERT_STRONG_KEY_OS_1 = 360;
export const XCN_OID_CERT_STRONG_KEY_OS_CURRENT = 361;
export const XCN_OID_CERT_STRONG_KEY_OS_PREFIX = 362;
export const XCN_OID_CERT_STRONG_SIGN_OS_1 = 363;
export const XCN_OID_CERT_STRONG_SIGN_OS_CURRENT = 364;
export const XCN_OID_CERT_STRONG_SIGN_OS_PREFIX = 365;
export const XCN_OID_DH_SINGLE_PASS_STDDH_SHA1_KDF = 366;
export const XCN_OID_DH_SINGLE_PASS_STDDH_SHA256_KDF = 367;
export const XCN_OID_DH_SINGLE_PASS_STDDH_SHA384_KDF = 368;
export const XCN_OID_DISALLOWED_HASH = 369;
export const XCN_OID_DISALLOWED_LIST = 370;
export const XCN_OID_ECC_CURVE_P256 = 371;
export const XCN_OID_ECC_CURVE_P384 = 372;
export const XCN_OID_ECC_CURVE_P521 = 373;
export const XCN_OID_ECDSA_SHA256 = 374;
export const XCN_OID_ECDSA_SHA384 = 375;
export const XCN_OID_ECDSA_SHA512 = 376;
export const XCN_OID_ENROLL_CAXCHGCERT_HASH = 377;
export const XCN_OID_ENROLL_EK_INFO = 378;
export const XCN_OID_ENROLL_EKPUB_CHALLENGE = 379;
export const XCN_OID_ENROLL_EKVERIFYCERT = 380;
export const XCN_OID_ENROLL_EKVERIFYCREDS = 381;
export const XCN_OID_ENROLL_EKVERIFYKEY = 382;
export const XCN_OID_EV_RDN_COUNTRY = 383;
export const XCN_OID_EV_RDN_LOCALE = 384;
export const XCN_OID_EV_RDN_STATE_OR_PROVINCE = 385;
export const XCN_OID_INHIBIT_ANY_POLICY = 386;
export const XCN_OID_INTERNATIONALIZED_EMAIL_ADDRESS = 387;
export const XCN_OID_KP_KERNEL_MODE_CODE_SIGNING = 388;
export const XCN_OID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING = 389;
export const XCN_OID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING = 390;
export const XCN_OID_KP_TPM_AIK_CERTIFICATE = 391;
export const XCN_OID_KP_TPM_EK_CERTIFICATE = 392;
export const XCN_OID_KP_TPM_PLATFORM_CERTIFICATE = 393;
export const XCN_OID_NIST_AES128_CBC = 394;
export const XCN_OID_NIST_AES128_WRAP = 395;
export const XCN_OID_NIST_AES192_CBC = 396;
export const XCN_OID_NIST_AES192_WRAP = 397;
export const XCN_OID_NIST_AES256_CBC = 398;
export const XCN_OID_NIST_AES256_WRAP = 399;
export const XCN_OID_PKCS_12_PbeIds = 400;
export const XCN_OID_PKCS_12_pbeWithSHA1And128BitRC2 = 401;
export const XCN_OID_PKCS_12_pbeWithSHA1And128BitRC4 = 402;
export const XCN_OID_PKCS_12_pbeWithSHA1And2KeyTripleDES = 403;
export const XCN_OID_PKCS_12_pbeWithSHA1And3KeyTripleDES = 404;
export const XCN_OID_PKCS_12_pbeWithSHA1And40BitRC2 = 405;
export const XCN_OID_PKCS_12_pbeWithSHA1And40BitRC4 = 406;
export const XCN_OID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID = 407;
export const XCN_OID_PKINIT_KP_KDC = 408;
export const XCN_OID_PKIX_CA_REPOSITORY = 409;
export const XCN_OID_PKIX_OCSP_NONCE = 410;
export const XCN_OID_PKIX_TIME_STAMPING = 411;
export const XCN_OID_QC_EU_COMPLIANCE = 412;
export const XCN_OID_QC_SSCD = 413;
export const XCN_OID_QC_STATEMENTS_EXT = 414;
export const XCN_OID_RDN_TPM_MANUFACTURER = 415;
export const XCN_OID_RDN_TPM_MODEL = 416;
export const XCN_OID_RDN_TPM_VERSION = 417;
export const XCN_OID_REVOKED_LIST_SIGNER = 418;
export const XCN_OID_RFC3161_counterSign = 419;
export const XCN_OID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION = 420;
export const XCN_OID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION = 421;
export const XCN_OID_ROOT_PROGRAM_FLAGS = 422;
export const XCN_OID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL = 423;
export const XCN_OID_RSA_PSPECIFIED = 424;
export const XCN_OID_RSAES_OAEP = 425;
export const XCN_OID_SUBJECT_INFO_ACCESS = 426;
export const XCN_OID_TIMESTAMP_TOKEN = 427;
export const XCN_OID_ENROLL_SCEP_ERROR = 428;
export const XCN_OIDVerisign_MessageType = 429;
export const XCN_OIDVerisign_PkiStatus = 430;
export const XCN_OIDVerisign_FailInfo = 431;
export const XCN_OIDVerisign_SenderNonce = 432;
export const XCN_OIDVerisign_RecipientNonce = 433;
export const XCN_OIDVerisign_TransactionID = 434;
export const XCN_OID_ENROLL_ATTESTATION_CHALLENGE = 435;
export const XCN_OID_ENROLL_ATTESTATION_STATEMENT = 436;
export const XCN_OID_ENROLL_ENCRYPTION_ALGORITHM = 437;
export const XCN_OID_ENROLL_KSP_NAME = 438;
export const LevelUnsafe = 0;
export const LevelSafe = 1;
export const XCN_CRYPT_STRING_BASE64HEADER = 0;
export const XCN_CRYPT_STRING_BASE64 = 1;
export const XCN_CRYPT_STRING_BINARY = 2;
export const XCN_CRYPT_STRING_BASE64REQUESTHEADER = 3;
export const XCN_CRYPT_STRING_HEX = 4;
export const XCN_CRYPT_STRING_HEXASCII = 5;
export const XCN_CRYPT_STRING_BASE64_ANY = 6;
export const XCN_CRYPT_STRING_ANY = 7;
export const XCN_CRYPT_STRING_HEX_ANY = 8;
export const XCN_CRYPT_STRING_BASE64X509CRLHEADER = 9;
export const XCN_CRYPT_STRING_HEXADDR = 10;
export const XCN_CRYPT_STRING_HEXASCIIADDR = 11;
export const XCN_CRYPT_STRING_HEXRAW = 12;
export const XCN_CRYPT_STRING_BASE64URI = 13;
export const XCN_CRYPT_STRING_ENCODEMASK = 255;
export const XCN_CRYPT_STRING_CHAIN = 256;
export const XCN_CRYPT_STRING_TEXT = 512;
export const XCN_CRYPT_STRING_PERCENTESCAPE = 134217728;
export const XCN_CRYPT_STRING_HASHDATA = 268435456;
export const XCN_CRYPT_STRING_STRICT = 536870912;
export const XCN_CRYPT_STRING_NOCRLF = 1073741824;
export const XCN_CRYPT_STRING_NOCR = `-2147483648`;
export const PFXExportEEOnly = 0;
export const PFXExportChainNoRoot = 1;
export const PFXExportChainWithRoot = 2;
export const XCN_CRYPT_ANY_GROUP_ID = 0;
export const XCN_CRYPT_HASH_ALG_OID_GROUP_ID = 1;
export const XCN_CRYPT_ENCRYPT_ALG_OID_GROUP_ID = 2;
export const XCN_CRYPT_PUBKEY_ALG_OID_GROUP_ID = 3;
export const XCN_CRYPT_SIGN_ALG_OID_GROUP_ID = 4;
export const XCN_CRYPT_RDN_ATTR_OID_GROUP_ID = 5;
export const XCN_CRYPT_EXT_OR_ATTR_OID_GROUP_ID = 6;
export const XCN_CRYPT_ENHKEY_USAGE_OID_GROUP_ID = 7;
export const XCN_CRYPT_POLICY_OID_GROUP_ID = 8;
export const XCN_CRYPT_TEMPLATE_OID_GROUP_ID = 9;
export const XCN_CRYPT_KDF_OID_GROUP_ID = 10;
export const XCN_CRYPT_LAST_OID_GROUP_ID = 10;
export const XCN_CRYPT_FIRST_ALG_OID_GROUP_ID = 1;
export const XCN_CRYPT_LAST_ALG_OID_GROUP_ID = 4;
export const XCN_CRYPT_GROUP_ID_MASK = 65535;
export const XCN_CRYPT_OID_PREFER_CNG_ALGID_FLAG = 1073741824;
export const XCN_CRYPT_OID_DISABLE_SEARCH_DS_FLAG = `-2147483648`;
export const XCN_CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = 268369920;
export const XCN_CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = 16;
export const XCN_CRYPT_KEY_LENGTH_MASK = 268369920;
export const XCN_CRYPT_OID_INFO_PUBKEY_ANY = 0;
export const XCN_CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = `-2147483648`;
export const XCN_CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = 1073741824;
export const AlgorithmFlagsNone = 0;
export const AlgorithmFlagsWrap = 1;
export const XCN_CERT_NAME_STR_NONE = 0;
export const XCN_CERT_SIMPLE_NAME_STR = 1;
export const XCN_CERT_OID_NAME_STR = 2;
export const XCN_CERT_X500_NAME_STR = 3;
export const XCN_CERT_XML_NAME_STR = 4;
export const XCN_CERT_NAME_STR_SEMICOLON_FLAG = 1073741824;
export const XCN_CERT_NAME_STR_NO_PLUS_FLAG = 536870912;
export const XCN_CERT_NAME_STR_NO_QUOTING_FLAG = 268435456;
export const XCN_CERT_NAME_STR_CRLF_FLAG = 134217728;
export const XCN_CERT_NAME_STR_COMMA_FLAG = 67108864;
export const XCN_CERT_NAME_STR_REVERSE_FLAG = 33554432;
export const XCN_CERT_NAME_STR_FORWARD_FLAG = 16777216;
export const XCN_CERT_NAME_STR_AMBIGUOUS_SEPARATOR_FLAGS = 1275068416;
export const XCN_CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = 65536;
export const XCN_CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = 131072;
export const XCN_CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = 262144;
export const XCN_CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = 524288;
export const XCN_CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = 1048576;
export const XCN_CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = 2097152;
export const XCN_CERT_NAME_STR_DS_ESCAPED = 8388608;
export const ContextNone = 0;
export const ContextUser = 1;
export const ContextMachine = 2;
export const ContextAdministratorForceMachine = 3;
export const Enrolled = 1;
export const EnrollPended = 2;
export const EnrollUIDeferredEnrollmentRequired = 4;
export const EnrollError = 16;
export const EnrollUnknown = 32;
export const EnrollSkipped = 64;
export const EnrollDenied = 256;
export const SelectedNo = 0;
export const SelectedYes = 1;
export const DisplayNo = 0;
export const DisplayYes = 1;
export const XCN_PROV_NONE = 0;
export const XCN_PROV_RSA_FULL = 1;
export const XCN_PROV_RSA_SIG = 2;
export const XCN_PROV_DSS = 3;
export const XCN_PROV_FORTEZZA = 4;
export const XCN_PROV_MS_EXCHANGE = 5;
export const XCN_PROV_SSL = 6;
export const XCN_PROV_RSA_SCHANNEL = 12;
export const XCN_PROV_DSS_DH = 13;
export const XCN_PROV_EC_ECDSA_SIG = 14;
export const XCN_PROV_EC_ECNRA_SIG = 15;
export const XCN_PROV_EC_ECDSA_FULL = 16;
export const XCN_PROV_EC_ECNRA_FULL = 17;
export const XCN_PROV_DH_SCHANNEL = 18;
export const XCN_PROV_SPYRUS_LYNKS = 20;
export const XCN_PROV_RNG = 21;
export const XCN_PROV_INTEL_SEC = 22;
export const XCN_PROV_REPLACE_OWF = 23;
export const XCN_PROV_RSA_AES = 24;
export const XCN_BCRYPT_UNKNOWN_INTERFACE = 0;
export const XCN_BCRYPT_CIPHER_INTERFACE = 1;
export const XCN_BCRYPT_HASH_INTERFACE = 2;
export const XCN_BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3;
export const XCN_BCRYPT_SIGNATURE_INTERFACE = 5;
export const XCN_BCRYPT_SECRET_AGREEMENT_INTERFACE = 4;
export const XCN_BCRYPT_RNG_INTERFACE = 6;
export const XCN_BCRYPT_KEY_DERIVATION_INTERFACE = 7;
export const XCN_NCRYPT_NO_OPERATION = 0;
export const XCN_NCRYPT_CIPHER_OPERATION = 1;
export const XCN_NCRYPT_HASH_OPERATION = 2;
export const XCN_NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = 4;
export const XCN_NCRYPT_SECRET_AGREEMENT_OPERATION = 8;
export const XCN_NCRYPT_SIGNATURE_OPERATION = 16;
export const XCN_NCRYPT_RNG_OPERATION = 32;
export const XCN_NCRYPT_KEY_DERIVATION_OPERATION = 64;
export const XCN_NCRYPT_ANY_ASYMMETRIC_OPERATION = 28;
export const XCN_NCRYPT_PREFER_SIGNATURE_ONLY_OPERATION = 2097152;
export const XCN_NCRYPT_PREFER_NON_SIGNATURE_OPERATION = 4194304;
export const XCN_NCRYPT_EXACT_MATCH_OPERATION = 8388608;
export const XCN_NCRYPT_PREFERENCE_MASK_OPERATION = 14680064;
export const XCN_AT_NONE = 0;
export const XCN_AT_KEYEXCHANGE = 1;
export const XCN_AT_SIGNATURE = 2;
export const SKIHashDefault = 0;
export const SKIHashSha1 = 1;
export const SKIHashCapiSha1 = 2;
export const SKIHashSha256 = 3;
export const SKIHashHPKP = 5;
export const XCN_NCRYPT_ALLOW_EXPORT_NONE = 0;
export const XCN_NCRYPT_ALLOW_EXPORT_FLAG = 1;
export const XCN_NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = 2;
export const XCN_NCRYPT_ALLOW_ARCHIVING_FLAG = 4;
export const XCN_NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = 8;
export const XCN_NCRYPT_ALLOW_USAGES_NONE = 0;
export const XCN_NCRYPT_ALLOW_DECRYPT_FLAG = 1;
export const XCN_NCRYPT_ALLOW_SIGNING_FLAG = 2;
export const XCN_NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = 4;
export const XCN_NCRYPT_ALLOW_KEY_IMPORT_FLAG = 8;
export const XCN_NCRYPT_ALLOW_ALL_USAGES = 16777215;
export const XCN_NCRYPT_UI_NO_PROTECTION_FLAG = 0;
export const XCN_NCRYPT_UI_PROTECT_KEY_FLAG = 1;
export const XCN_NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = 2;
export const XCN_NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = 4;
export const XCN_NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = 8;
export const VerifyNone = 0;
export const VerifySilent = 1;
export const VerifySmartCardNone = 2;
export const VerifySmartCardSilent = 3;
export const VerifyAllowUI = 4;
export const XCN_NCRYPT_PCP_NONE = 0;
export const XCN_NCRYPT_TPM12_PROVIDER = 65536;
export const XCN_NCRYPT_PCP_SIGNATURE_KEY = 1;
export const XCN_NCRYPT_PCP_ENCRYPTION_KEY = 2;
export const XCN_NCRYPT_PCP_GENERIC_KEY = 3;
export const XCN_NCRYPT_PCP_STORAGE_KEY = 4;
export const XCN_NCRYPT_PCP_IDENTITY_KEY = 8;
export const XCN_CRYPT_OID_USE_CURVE_NONE = 0;
export const XCN_CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = 536870912;
export const XCN_CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = 268435456;
export const XCN_CERT_NO_KEY_USAGE = 0;
export const XCN_CERT_DIGITAL_SIGNATURE_KEY_USAGE = 128;
export const XCN_CERT_NON_REPUDIATION_KEY_USAGE = 64;
export const XCN_CERT_KEY_ENCIPHERMENT_KEY_USAGE = 32;
export const XCN_CERT_DATA_ENCIPHERMENT_KEY_USAGE = 16;
export const XCN_CERT_KEY_AGREEMENT_KEY_USAGE = 8;
export const XCN_CERT_KEY_CERT_SIGN_KEY_USAGE = 4;
export const XCN_CERT_OFFLINE_CRL_SIGN_KEY_USAGE = 2;
export const XCN_CERT_CRL_SIGN_KEY_USAGE = 2;
export const XCN_CERT_ENCIPHER_ONLY_KEY_USAGE = 1;
export const XCN_CERT_DECIPHER_ONLY_KEY_USAGE = 32768;
export const XCN_CERT_ALT_NAME_UNKNOWN = 0;
export const XCN_CERT_ALT_NAME_OTHER_NAME = 1;
export const XCN_CERT_ALT_NAME_RFC822_NAME = 2;
export const XCN_CERT_ALT_NAME_DNS_NAME = 3;
export const XCN_CERT_ALT_NAME_X400_ADDRESS = 4;
export const XCN_CERT_ALT_NAME_DIRECTORY_NAME = 5;
export const XCN_CERT_ALT_NAME_EDI_PARTY_NAME = 6;
export const XCN_CERT_ALT_NAME_URL = 7;
export const XCN_CERT_ALT_NAME_IP_ADDRESS = 8;
export const XCN_CERT_ALT_NAME_REGISTERED_ID = 9;
export const XCN_CERT_ALT_NAME_GUID = 10;
export const XCN_CERT_ALT_NAME_USER_PRINCIPLE_NAME = 11;
export const PolicyQualifierTypeUnknown = 0;
export const PolicyQualifierTypeUrl = 1;
export const PolicyQualifierTypeUserNotice = 2;
export const PolicyQualifierTypeFlags = 3;
export const ClientIdNone = 0;
export const ClientIdXEnroll2003 = 1;
export const ClientIdAutoEnroll2003 = 2;
export const ClientIdWizard2003 = 3;
export const ClientIdCertReq2003 = 4;
export const ClientIdDefaultRequest = 5;
export const ClientIdAutoEnroll = 6;
export const ClientIdRequestWizard = 7;
export const ClientIdEOBO = 8;
export const ClientIdCertReq = 9;
export const ClientIdTest = 10;
export const ClientIdWinRT = 11;
export const ClientIdUserStart = 1000;
export const XCN_PROPERTYID_NONE = 0;
export const XCN_CERT_KEY_PROV_HANDLE_PROP_ID = 1;
export const XCN_CERT_KEY_PROV_INFO_PROP_ID = 2;
export const XCN_CERT_SHA1_HASH_PROP_ID = 3;
export const XCN_CERT_MD5_HASH_PROP_ID = 4;
export const XCN_CERT_HASH_PROP_ID = 3;
export const XCN_CERT_KEY_CONTEXT_PROP_ID = 5;
export const XCN_CERT_KEY_SPEC_PROP_ID = 6;
export const XCN_CERT_IE30_RESERVED_PROP_ID = 7;
export const XCN_CERT_PUBKEY_HASH_RESERVED_PROP_ID = 8;
export const XCN_CERT_ENHKEY_USAGE_PROP_ID = 9;
export const XCN_CERT_CTL_USAGE_PROP_ID = 9;
export const XCN_CERT_NEXT_UPDATE_LOCATION_PROP_ID = 10;
export const XCN_CERT_FRIENDLY_NAME_PROP_ID = 11;
export const XCN_CERT_PVK_FILE_PROP_ID = 12;
export const XCN_CERT_DESCRIPTION_PROP_ID = 13;
export const XCN_CERT_ACCESS_STATE_PROP_ID = 14;
export const XCN_CERT_SIGNATURE_HASH_PROP_ID = 15;
export const XCN_CERT_SMART_CARD_DATA_PROP_ID = 16;
export const XCN_CERT_EFS_PROP_ID = 17;
export const XCN_CERT_FORTEZZA_DATA_PROP_ID = 18;
export const XCN_CERT_ARCHIVED_PROP_ID = 19;
export const XCN_CERT_KEY_IDENTIFIER_PROP_ID = 20;
export const XCN_CERT_AUTO_ENROLL_PROP_ID = 21;
export const XCN_CERT_PUBKEY_ALG_PARA_PROP_ID = 22;
export const XCN_CERT_CROSS_CERT_DIST_POINTS_PROP_ID = 23;
export const XCN_CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = 24;
export const XCN_CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = 25;
export const XCN_CERT_ENROLLMENT_PROP_ID = 26;
export const XCN_CERT_DATE_STAMP_PROP_ID = 27;
export const XCN_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = 28;
export const XCN_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = 29;
export const XCN_CERT_EXTENDED_ERROR_INFO_PROP_ID = 30;
export const XCN_CERT_RENEWAL_PROP_ID = 64;
export const XCN_CERT_ARCHIVED_KEY_HASH_PROP_ID = 65;
export const XCN_CERT_AUTO_ENROLL_RETRY_PROP_ID = 66;
export const XCN_CERT_AIA_URL_RETRIEVED_PROP_ID = 67;
export const XCN_CERT_AUTHORITY_INFO_ACCESS_PROP_ID = 68;
export const XCN_CERT_BACKED_UP_PROP_ID = 69;
export const XCN_CERT_OCSP_RESPONSE_PROP_ID = 70;
export const XCN_CERT_REQUEST_ORIGINATOR_PROP_ID = 71;
export const XCN_CERT_SOURCE_LOCATION_PROP_ID = 72;
export const XCN_CERT_SOURCE_URL_PROP_ID = 73;
export const XCN_CERT_NEW_KEY_PROP_ID = 74;
export const XCN_CERT_OCSP_CACHE_PREFIX_PROP_ID = 75;
export const XCN_CERT_SMART_CARD_ROOT_INFO_PROP_ID = 76;
export const XCN_CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = 77;
export const XCN_CERT_NCRYPT_KEY_HANDLE_PROP_ID = 78;
export const XCN_CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = 79;
export const XCN_CERT_SUBJECT_INFO_ACCESS_PROP_ID = 80;
export const XCN_CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 81;
export const XCN_CERT_CA_DISABLE_CRL_PROP_ID = 82;
export const XCN_CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = 83;
export const XCN_CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = 84;
export const XCN_CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 85;
export const XCN_CERT_SUBJECT_DISABLE_CRL_PROP_ID = 86;
export const XCN_CERT_CEP_PROP_ID = 87;
export const XCN_CERT_SIGN_HASH_CNG_ALG_PROP_ID = 89;
export const XCN_CERT_SCARD_PIN_ID_PROP_ID = 90;
export const XCN_CERT_SCARD_PIN_INFO_PROP_ID = 91;
export const XCN_CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = 92;
export const XCN_CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 93;
export const XCN_CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = 94;
export const XCN_CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = 95;
export const XCN_CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 96;
export const XCN_CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = 97;
export const XCN_CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = 98;
export const XCN_CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = 99;
export const XCN_CERT_HCRYPTPROV_TRANSFER_PROP_ID = 100;
export const XCN_CERT_SMART_CARD_READER_PROP_ID = 101;
export const XCN_CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = 102;
export const XCN_CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = 103;
export const XCN_CERT_DISALLOWED_FILETIME_PROP_ID = 104;
export const XCN_CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = 105;
export const XCN_CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = 106;
export const XCN_CERT_SHA256_HASH_PROP_ID = 107;
export const XCN_CERT_SCEP_SERVER_CERTS_PROP_ID = 108;
export const XCN_CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = 109;
export const XCN_CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = 110;
export const XCN_CERT_SCEP_CA_CERT_PROP_ID = 111;
export const XCN_CERT_SCEP_SIGNER_CERT_PROP_ID = 112;
export const XCN_CERT_SCEP_NONCE_PROP_ID = 113;
export const XCN_CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = 114;
export const XCN_CERT_SCEP_FLAGS_PROP_ID = 115;
export const XCN_CERT_SCEP_GUID_PROP_ID = 116;
export const XCN_CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = 117;
export const XCN_CERT_ISOLATED_KEY_PROP_ID = 118;
export const XCN_CERT_SERIAL_CHAIN_PROP_ID = 119;
export const XCN_CERT_KEY_CLASSIFICATION_PROP_ID = 120;
export const XCN_CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = 122;
export const XCN_CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = 123;
export const XCN_CERT_PIN_SHA256_HASH_PROP_ID = 124;
export const XCN_CERT_CLR_DELETE_KEY_PROP_ID = 125;
export const XCN_CERT_NOT_BEFORE_FILETIME_PROP_ID = 126;
export const XCN_CERT_CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = 127;
export const XCN_CERT_FIRST_RESERVED_PROP_ID = 128;
export const XCN_CERT_LAST_RESERVED_PROP_ID = 32767;
export const XCN_CERT_FIRST_USER_PROP_ID = 32768;
export const XCN_CERT_LAST_USER_PROP_ID = 65535;
export const XCN_CERT_STORE_LOCALIZED_NAME_PROP_ID = 4096;
export const DefaultNone = 0;
export const DefaultPolicyServer = 1;
export const PsfNone = 0;
export const PsfLocationGroupPolicy = 1;
export const PsfLocationRegistry = 2;
export const PsfUseClientId = 4;
export const PsfAutoEnrollmentEnabled = 16;
export const PsfAllowUnTrustedCA = 32;
export const TemplatePropCommonName = 1;
export const TemplatePropFriendlyName = 2;
export const TemplatePropEKUs = 3;
export const TemplatePropCryptoProviders = 4;
export const TemplatePropMajorRevision = 5;
export const TemplatePropDescription = 6;
export const TemplatePropKeySpec = 7;
export const TemplatePropSchemaVersion = 8;
export const TemplatePropMinorRevision = 9;
export const TemplatePropRASignatureCount = 10;
export const TemplatePropMinimumKeySize = 11;
export const TemplatePropOID = 12;
export const TemplatePropSupersede = 13;
export const TemplatePropRACertificatePolicies = 14;
export const TemplatePropRAEKUs = 15;
export const TemplatePropCertificatePolicies = 16;
export const TemplatePropV1ApplicationPolicy = 17;
export const TemplatePropAsymmetricAlgorithm = 18;
export const TemplatePropKeySecurityDescriptor = 19;
export const TemplatePropSymmetricAlgorithm = 20;
export const TemplatePropSymmetricKeyLength = 21;
export const TemplatePropHashAlgorithm = 22;
export const TemplatePropKeyUsage = 23;
export const TemplatePropEnrollmentFlags = 24;
export const TemplatePropSubjectNameFlags = 25;
export const TemplatePropPrivateKeyFlags = 26;
export const TemplatePropGeneralFlags = 27;
export const TemplatePropSecurityDescriptor = 28;
export const TemplatePropExtensions = 29;
export const TemplatePropValidityPeriod = 30;
export const TemplatePropRenewalPeriod = 31;
export const CommitFlagSaveTemplateGenerateOID = 1;
export const CommitFlagSaveTemplateUseCurrentOID = 2;
export const CommitFlagSaveTemplateOverwrite = 3;
export const CommitFlagDeleteTemplate = 4;
export const CAPropCommonName = 1;
export const CAPropDistinguishedName = 2;
export const CAPropSanitizedName = 3;
export const CAPropSanitizedShortName = 4;
export const CAPropDNSName = 5;
export const CAPropCertificateTypes = 6;
export const CAPropCertificate = 7;
export const CAPropDescription = 8;
export const CAPropWebServers = 9;
export const CAPropSiteName = 10;
export const CAPropSecurity = 11;
export const CAPropRenewalOnly = 12;
export const LoadOptionDefault = 0;
export const LoadOptionCacheOnly = 1;
export const LoadOptionReload = 2;
export const LoadOptionRegisterForADChanges = 4;
export const DisableGroupPolicyList = 2;
export const DisableUserServerList = 4;
export const PsPolicyID = 0;
export const PsFriendlyName = 1;
export const ExportTemplates = 1;
export const ExportOIDs = 2;
export const ExportCAs = 4;
export const TypeAny = 0;
export const TypePkcs10 = 1;
export const TypePkcs7 = 2;
export const TypeCmc = 3;
export const TypeCertificate = 4;
export const InheritDefault = 0;
export const InheritNewDefaultKey = 1;
export const InheritNewSimilarKey = 2;
export const InheritPrivateKey = 3;
export const InheritPublicKey = 4;
export const InheritKeyMask = 15;
export const InheritNone = 16;
export const InheritRenewalCertificateFlag = 32;
export const InheritTemplateFlag = 64;
export const InheritSubjectFlag = 128;
export const InheritExtensionsFlag = 256;
export const InheritSubjectAltNameFlag = 512;
export const InheritValidityPeriodFlag = 1024;
export const InheritReserved80000000 = `-2147483648`;
export const LevelInnermost = 0;
export const LevelNext = 1;
export const AllowedKeySignature = 1;
export const AllowedNullSignature = 2;
export const XCN_NCRYPT_CLAIM_NONE = 0;
export const XCN_NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = 3;
export const XCN_NCRYPT_CLAIM_AUTHORITY_ONLY = 1;
export const XCN_NCRYPT_CLAIM_SUBJECT_ONLY = 2;
export const XCN_NCRYPT_CLAIM_UNKNOWN = 4096;
export const AllowNone = 0;
export const AllowNoOutstandingRequest = 1;
export const AllowUntrustedCertificate = 2;
export const AllowUntrustedRoot = 4;
export const EnrollPrompt = 1;
export const XCN_CRL_REASON_UNSPECIFIED = 0;
export const XCN_CRL_REASON_KEY_COMPROMISE = 1;
export const XCN_CRL_REASON_CA_COMPROMISE = 2;
export const XCN_CRL_REASON_AFFILIATION_CHANGED = 3;
export const XCN_CRL_REASON_SUPERSEDED = 4;
export const XCN_CRL_REASON_CESSATION_OF_OPERATION = 5;
export const XCN_CRL_REASON_CERTIFICATE_HOLD = 6;
export const XCN_CRL_REASON_REMOVE_FROM_CRL = 8;
export const XCN_CRL_REASON_PRIVILEGE_WITHDRAWN = 9;
export const XCN_CRL_REASON_AA_COMPROMISE = 10;
export const SCEPProcessDefault = 0;
export const SCEPProcessSkipCertInstall = 1;
export const DelayRetryUnknown = 0;
export const DelayRetryNone = 1;
export const DelayRetryShort = 2;
export const DelayRetryLong = 3;
export const DelayRetrySuccess = 4;
export const DelayRetryPastSuccess = 5;
export const GeneralMachineType = 64;
export const GeneralCA = 128;
export const GeneralCrossCA = 2048;
export const GeneralDefault = 65536;
export const GeneralModified = 131072;
export const GeneralDonotPersist = 4096;
export const EnrollmentIncludeSymmetricAlgorithms = 1;
export const EnrollmentPendAllRequests = 2;
export const EnrollmentPublishToKRAContainer = 4;
export const EnrollmentPublishToDS = 8;
export const EnrollmentAutoEnrollmentCheckUserDSCertificate = 16;
export const EnrollmentAutoEnrollment = 32;
export const EnrollmentDomainAuthenticationNotRequired = 128;
export const EnrollmentPreviousApprovalValidateReenrollment = 64;
export const EnrollmentUserInteractionRequired = 256;
export const EnrollmentAddTemplateName = 512;
export const EnrollmentRemoveInvalidCertificateFromPersonalStore = 1024;
export const EnrollmentAllowEnrollOnBehalfOf = 2048;
export const EnrollmentAddOCSPNoCheck = 4096;
export const EnrollmentReuseKeyOnFullSmartCard = 8192;
export const EnrollmentNoRevocationInfoInCerts = 16384;
export const EnrollmentIncludeBasicConstraintsForEECerts = 32768;
export const EnrollmentPreviousApprovalKeyBasedValidateReenrollment = 65536;
export const EnrollmentCertificateIssuancePoliciesFromRequest = 131072;
export const EnrollmentSkipAutoRenewal = 262144;
export const SubjectNameEnrolleeSupplies = 1;
export const SubjectNameRequireDirectoryPath = `-2147483648`;
export const SubjectNameRequireCommonName = 1073741824;
export const SubjectNameRequireEmail = 536870912;
export const SubjectNameRequireDNS = 268435456;
export const SubjectNameAndAlternativeNameOldCertSupplies = 8;
export const SubjectAlternativeNameEnrolleeSupplies = 65536;
export const SubjectAlternativeNameRequireDirectoryGUID = 16777216;
export const SubjectAlternativeNameRequireUPN = 33554432;
export const SubjectAlternativeNameRequireEmail = 67108864;
export const SubjectAlternativeNameRequireSPN = 8388608;
export const SubjectAlternativeNameRequireDNS = 134217728;
export const SubjectAlternativeNameRequireDomainDNS = 4194304;
export const PrivateKeyRequireArchival = 1;
export const PrivateKeyExportable = 16;
export const PrivateKeyRequireStrongKeyProtection = 32;
export const PrivateKeyRequireAlternateSignatureAlgorithm = 64;
export const PrivateKeyRequireSameKeyRenewal = 128;
export const PrivateKeyUseLegacyProvider = 256;
export const PrivateKeyEKTrustOnUse = 512;
export const PrivateKeyEKValidateCert = 1024;
export const PrivateKeyEKValidateKey = 2048;
export const PrivateKeyAttestNone = 0;
export const PrivateKeyAttestPreferred = 4096;
export const PrivateKeyAttestRequired = 8192;
export const PrivateKeyAttestMask = 12288;
export const PrivateKeyAttestWithoutPolicy = 16384;
export const PrivateKeyServerVersionMask = 983040;
export const PrivateKeyServerVersionShift = 16;
export const PrivateKeyHelloKspKey = 1048576;
export const PrivateKeyHelloLogonKey = 2097152;
export const PrivateKeyClientVersionMask = 251658240;
export const PrivateKeyClientVersionShift = 24;
export const ImportNone = 0;
export const ImportMachineContext = 1;
export const ImportForceOverwrite = 2;
export const ImportSilent = 4;
export const ImportSaveProperties = 8;
export const ImportExportable = 16;
export const ImportExportableEncrypted = 32;
export const ImportNoUserProtected = 64;
export const ImportUserProtected = 128;
export const ImportUserProtectedHigh = 256;
export const ImportInstallCertificate = 512;
export const ImportInstallChain = 1024;
export const ImportInstallChainAndRoot = 2048;
export const ENUM_ENTERPRISE_ROOTCA = 0;
export const ENUM_ENTERPRISE_SUBCA = 1;
export const ENUM_STANDALONE_ROOTCA = 3;
export const ENUM_STANDALONE_SUBCA = 4;
export const ENUM_UNKNOWN_CA = 5;
export const BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = 1;
export const BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = 2;
export const BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = 3;
export const BCRYPT_NO_CURVE_GENERATION_ALG_ID = 0;
export const DSA_HASH_ALGORITHM_SHA1 = 0;
export const DSA_HASH_ALGORITHM_SHA256 = 1;
export const DSA_HASH_ALGORITHM_SHA512 = 2;
export const DSA_FIPS186_2 = 0;
export const DSA_FIPS186_3 = 1;
export const BCRYPT_HASH_OPERATION_HASH_DATA = 1;
export const BCRYPT_HASH_OPERATION_FINISH_HASH = 2;
export const BCRYPT_OPERATION_TYPE_HASH = 1;
export const KeyTypeOther = 0;
export const KeyTypeVirtualSmartCard = 1;
export const KeyTypePhysicalSmartCard = 2;
export const KeyTypePassport = 3;
export const KeyTypePassportRemote = 4;
export const KeyTypePassportSmartCard = 5;
export const KeyTypeHardware = 6;
export const KeyTypeSoftware = 7;
export const KeyTypeSelfSigned = 8;
export const CRYPT_XML_CHARSET_AUTO = 0;
export const CRYPT_XML_CHARSET_UTF8 = 1;
export const CRYPT_XML_CHARSET_UTF16LE = 2;
export const CRYPT_XML_CHARSET_UTF16BE = 3;
export const CRYPT_XML_PROPERTY_MAX_HEAP_SIZE = 1;
export const CRYPT_XML_PROPERTY_SIGNATURE_LOCATION = 2;
export const CRYPT_XML_PROPERTY_MAX_SIGNATURES = 3;
export const CRYPT_XML_PROPERTY_DOC_DECLARATION = 4;
export const CRYPT_XML_PROPERTY_XML_OUTPUT_CHARSET = 5;
export const CRYPT_XML_KEYINFO_SPEC_NONE = 0;
export const CRYPT_XML_KEYINFO_SPEC_ENCODED = 1;
export const CRYPT_XML_KEYINFO_SPEC_PARAM = 2;
export const Asymmetric = 1;
export const Symmetric = 2;
export const Transform = 3;
export const Hash = 4;
export const None = 1;
export const PKCS7 = 2;
export const Zeros = 3;
export const ANSIX923 = 4;
export const ISO10126 = 5;
export const DirectionEncrypt = 1;
export const DirectionDecrypt = 2;
export const ENUM_SETUPPROP_INVALID = `-1`;
export const ENUM_SETUPPROP_CATYPE = 0;
export const ENUM_SETUPPROP_CAKEYINFORMATION = 1;
export const ENUM_SETUPPROP_INTERACTIVE = 2;
export const ENUM_SETUPPROP_CANAME = 3;
export const ENUM_SETUPPROP_CADSSUFFIX = 4;
export const ENUM_SETUPPROP_VALIDITYPERIOD = 5;
export const ENUM_SETUPPROP_VALIDITYPERIODUNIT = 6;
export const ENUM_SETUPPROP_EXPIRATIONDATE = 7;
export const ENUM_SETUPPROP_PRESERVEDATABASE = 8;
export const ENUM_SETUPPROP_DATABASEDIRECTORY = 9;
export const ENUM_SETUPPROP_LOGDIRECTORY = 10;
export const ENUM_SETUPPROP_SHAREDFOLDER = 11;
export const ENUM_SETUPPROP_PARENTCAMACHINE = 12;
export const ENUM_SETUPPROP_PARENTCANAME = 13;
export const ENUM_SETUPPROP_REQUESTFILE = 14;
export const ENUM_SETUPPROP_WEBCAMACHINE = 15;
export const ENUM_SETUPPROP_WEBCANAME = 16;
export const ENUM_CEPSETUPPROP_USELOCALSYSTEM = 0;
export const ENUM_CEPSETUPPROP_USECHALLENGE = 1;
export const ENUM_CEPSETUPPROP_RANAME_CN = 2;
export const ENUM_CEPSETUPPROP_RANAME_EMAIL = 3;
export const ENUM_CEPSETUPPROP_RANAME_COMPANY = 4;
export const ENUM_CEPSETUPPROP_RANAME_DEPT = 5;
export const ENUM_CEPSETUPPROP_RANAME_CITY = 6;
export const ENUM_CEPSETUPPROP_RANAME_STATE = 7;
export const ENUM_CEPSETUPPROP_RANAME_COUNTRY = 8;
export const ENUM_CEPSETUPPROP_SIGNINGKEYINFORMATION = 9;
export const ENUM_CEPSETUPPROP_EXCHANGEKEYINFORMATION = 10;
export const ENUM_CEPSETUPPROP_CAINFORMATION = 11;
export const ENUM_CEPSETUPPROP_MSCEPURL = 12;
export const ENUM_CEPSETUPPROP_CHALLENGEURL = 13;
export const ENUM_CESSETUPPROP_USE_IISAPPPOOLIDENTITY = 0;
export const ENUM_CESSETUPPROP_CACONFIG = 1;
export const ENUM_CESSETUPPROP_AUTHENTICATION = 2;
export const ENUM_CESSETUPPROP_SSLCERTHASH = 3;
export const ENUM_CESSETUPPROP_URL = 4;
export const ENUM_CESSETUPPROP_RENEWALONLY = 5;
export const ENUM_CESSETUPPROP_ALLOW_KEYBASED_RENEWAL = 6;
export const ENUM_CEPSETUPPROP_AUTHENTICATION = 0;
export const ENUM_CEPSETUPPROP_SSLCERTHASH = 1;
export const ENUM_CEPSETUPPROP_URL = 2;
export const ENUM_CEPSETUPPROP_KEYBASED_RENEWAL = 3;
export const ATTRIBUTE_SECURITY_INFORMATION = 32;
export const BACKUP_SECURITY_INFORMATION = 65536;
export const DACL_SECURITY_INFORMATION = 4;
export const GROUP_SECURITY_INFORMATION = 2;
export const LABEL_SECURITY_INFORMATION = 16;
export const OWNER_SECURITY_INFORMATION = 1;
export const PROTECTED_DACL_SECURITY_INFORMATION = 2147483648;
export const PROTECTED_SACL_SECURITY_INFORMATION = 1073741824;
export const SACL_SECURITY_INFORMATION = 8;
export const SCOPE_SECURITY_INFORMATION = 64;
export const UNPROTECTED_DACL_SECURITY_INFORMATION = 536870912;
export const UNPROTECTED_SACL_SECURITY_INFORMATION = 268435456;
export const REG_NONE = 0;
export const REG_SZ = 1;
export const REG_EXPAND_SZ = 2;
export const REG_BINARY = 3;
export const REG_DWORD = 4;
export const REG_DWORD_LITTLE_ENDIAN = 4;
export const REG_DWORD_BIG_ENDIAN = 5;
export const REG_LINK = 6;
export const REG_MULTI_SZ = 7;
export const REG_RESOURCE_LIST = 8;
export const REG_FULL_RESOURCE_DESCRIPTOR = 9;
export const REG_RESOURCE_REQUIREMENTS_LIST = 10;
export const REG_QWORD = 11;
export const REG_QWORD_LITTLE_ENDIAN = 11;

// Structs

export type HCRYPTASYNC = Deno.PointerValue;

export type HCERTCHAINENGINE = Deno.PointerValue;

export type BCRYPT_ALG_HANDLE = Deno.PointerValue;

export type BCRYPT_KEY_HANDLE = Deno.PointerValue;

export type BCRYPT_HASH_HANDLE = Deno.PointerValue;

export type BCRYPT_SECRET_HANDLE = Deno.PointerValue;

export type BCRYPT_HANDLE = Deno.PointerValue;

export type NCRYPT_HANDLE = Deno.PointerValue;

export type NCRYPT_PROV_HANDLE = Deno.PointerValue;

export type NCRYPT_KEY_HANDLE = Deno.PointerValue;

export type NCRYPT_HASH_HANDLE = Deno.PointerValue;

export type NCRYPT_SECRET_HANDLE = Deno.PointerValue;

export type HCRYPTPROV_LEGACY = Deno.PointerValue;

export type HCRYPTPROV_OR_NCRYPT_KEY_HANDLE = Deno.PointerValue;

export type HCERTSTORE = Deno.PointerValue | Uint8Array;

export type HCERTSTOREPROV = Deno.PointerValue | Uint8Array;

export type PWSTR = Deno.PointerValue | Uint8Array;

/**
 * Windows.Win32.Security.Cryptography.Certificates.CSEDB_RSTMAPW (size: 16)
 */
export interface CSEDB_RSTMAPW {
  /** Windows.Win32.Foundation.PWSTR */
  pwszDatabaseName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszNewDatabaseName: string | null | Uint8Array | Uint16Array;
}

export const sizeofCSEDB_RSTMAPW = 16;

export function allocCSEDB_RSTMAPW(data?: Partial<CSEDB_RSTMAPW>): Uint8Array {
  const buf = new Uint8Array(sizeofCSEDB_RSTMAPW);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pwszDatabaseName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pwszDatabaseName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pwszNewDatabaseName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszNewDatabaseName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CSEDB_RSTMAPWView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pwszDatabaseName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pwszNewDatabaseName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pwszDatabaseName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pwszNewDatabaseName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Certificates.CERTTRANSBLOB (size: 16)
 */
export interface CERTTRANSBLOB {
  /** u32 */
  cb: number;
  /** ptr */
  pb: Deno.PointerValue | Uint8Array;
}

export const sizeofCERTTRANSBLOB = 16;

export function allocCERTTRANSBLOB(data?: Partial<CERTTRANSBLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofCERTTRANSBLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cb !== undefined) view.setUint32(0, Number(data.cb), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pb !== undefined) view.setBigUint64(8, data.pb === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pb))), true);
  return buf;
}

export class CERTTRANSBLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cb(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pb(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cb(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pb(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Certificates.CERTVIEWRESTRICTION (size: 32)
 */
export interface CERTVIEWRESTRICTION {
  /** u32 */
  ColumnIndex: number;
  /** i32 */
  SeekOperator: number;
  /** i32 */
  SortOrder: number;
  /** ptr */
  pbValue: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbValue: number;
}

export const sizeofCERTVIEWRESTRICTION = 32;

export function allocCERTVIEWRESTRICTION(data?: Partial<CERTVIEWRESTRICTION>): Uint8Array {
  const buf = new Uint8Array(sizeofCERTVIEWRESTRICTION);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.ColumnIndex !== undefined) view.setUint32(0, Number(data.ColumnIndex), true);
  // 0x04: i32
  if (data?.SeekOperator !== undefined) view.setInt32(4, Number(data.SeekOperator), true);
  // 0x08: i32
  if (data?.SortOrder !== undefined) view.setInt32(8, Number(data.SortOrder), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.pbValue !== undefined) view.setBigUint64(16, data.pbValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbValue))), true);
  // 0x18: u32
  if (data?.cbValue !== undefined) view.setUint32(24, Number(data.cbValue), true);
  // 0x1c: pad4
  return buf;
}

export class CERTVIEWRESTRICTIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get ColumnIndex(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get SeekOperator(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: i32
  get SortOrder(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get pbValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cbValue(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: u32
  set ColumnIndex(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set SeekOperator(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: i32
  set SortOrder(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set pbValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set cbValue(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.Certificates.CAINFO (size: 40)
 */
export interface CAINFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.Certificates.ENUM_CATYPES */
  CAType: ENUM_CATYPES;
  /** u32 */
  cCASignatureCerts: number;
  /** u32 */
  cCAExchangeCerts: number;
  /** u32 */
  cExitModules: number;
  /** i32 */
  lPropIdMax: number;
  /** i32 */
  lRoleSeparationEnabled: number;
  /** u32 */
  cKRACertUsedCount: number;
  /** u32 */
  cKRACertCount: number;
  /** u32 */
  fAdvancedServer: number;
}

export const sizeofCAINFO = 40;

export function allocCAINFO(data?: Partial<CAINFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCAINFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: i32
  if (data?.CAType !== undefined) view.setInt32(4, Number(data.CAType), true);
  // 0x08: u32
  if (data?.cCASignatureCerts !== undefined) view.setUint32(8, Number(data.cCASignatureCerts), true);
  // 0x0c: u32
  if (data?.cCAExchangeCerts !== undefined) view.setUint32(12, Number(data.cCAExchangeCerts), true);
  // 0x10: u32
  if (data?.cExitModules !== undefined) view.setUint32(16, Number(data.cExitModules), true);
  // 0x14: i32
  if (data?.lPropIdMax !== undefined) view.setInt32(20, Number(data.lPropIdMax), true);
  // 0x18: i32
  if (data?.lRoleSeparationEnabled !== undefined) view.setInt32(24, Number(data.lRoleSeparationEnabled), true);
  // 0x1c: u32
  if (data?.cKRACertUsedCount !== undefined) view.setUint32(28, Number(data.cKRACertUsedCount), true);
  // 0x20: u32
  if (data?.cKRACertCount !== undefined) view.setUint32(32, Number(data.cKRACertCount), true);
  // 0x24: u32
  if (data?.fAdvancedServer !== undefined) view.setUint32(36, Number(data.fAdvancedServer), true);
  return buf;
}

export class CAINFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get CAType(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: u32
  get cCASignatureCerts(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cCAExchangeCerts(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cExitModules(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: i32
  get lPropIdMax(): number {
    return this.view.getInt32(20, true);
  }

  // 0x18: i32
  get lRoleSeparationEnabled(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: u32
  get cKRACertUsedCount(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: u32
  get cKRACertCount(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: u32
  get fAdvancedServer(): number {
    return this.view.getUint32(36, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set CAType(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: u32
  set cCASignatureCerts(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cCAExchangeCerts(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cExitModules(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: i32
  set lPropIdMax(value: number) {
    this.view.setInt32(20, value, true);
  }

  // 0x18: i32
  set lRoleSeparationEnabled(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: u32
  set cKRACertUsedCount(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: u32
  set cKRACertCount(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: u32
  set fAdvancedServer(value: number) {
    this.view.setUint32(36, value, true);
  }
}

export type HANDLE = Deno.PointerValue;

/**
 * Windows.Win32.Security.Cryptography.Catalog.CRYPTCATSTORE (size: 64)
 */
export interface CRYPTCATSTORE {
  /** u32 */
  cbStruct: number;
  /** u32 */
  dwPublicVersion: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszP7File: string | null | Uint8Array | Uint16Array;
  /** usize */
  hProv: Deno.PointerValue;
  /** u32 */
  dwEncodingType: number;
  /** Windows.Win32.Security.Cryptography.Catalog.CRYPTCAT_OPEN_FLAGS */
  fdwStoreFlags: CRYPTCAT_OPEN_FLAGS;
  /** Windows.Win32.Foundation.HANDLE */
  hReserved: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.HANDLE */
  hAttrs: Uint8Array | Deno.PointerValue;
  /** ptr */
  hCryptMsg: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.HANDLE */
  hSorted: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPTCATSTORE = 64;

export function allocCRYPTCATSTORE(data?: Partial<CRYPTCATSTORE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTCATSTORE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: u32
  if (data?.dwPublicVersion !== undefined) view.setUint32(4, Number(data.dwPublicVersion), true);
  // 0x08: buffer
  if (data?.pwszP7File !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszP7File);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: usize
  if (data?.hProv !== undefined) view.setBigUint64(16, BigInt(data.hProv), true);
  // 0x18: u32
  if (data?.dwEncodingType !== undefined) view.setUint32(24, Number(data.dwEncodingType), true);
  // 0x1c: u32
  if (data?.fdwStoreFlags !== undefined) view.setUint32(28, Number(data.fdwStoreFlags), true);
  // 0x20: pointer
  if (data?.hReserved !== undefined) view.setBigUint64(32, data.hReserved === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hReserved))), true);
  // 0x28: pointer
  if (data?.hAttrs !== undefined) view.setBigUint64(40, data.hAttrs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hAttrs))), true);
  // 0x30: pointer
  if (data?.hCryptMsg !== undefined) view.setBigUint64(48, data.hCryptMsg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptMsg))), true);
  // 0x38: pointer
  if (data?.hSorted !== undefined) view.setBigUint64(56, data.hSorted === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hSorted))), true);
  return buf;
}

export class CRYPTCATSTOREView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwPublicVersion(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: buffer
  get pwszP7File(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: usize
  get hProv(): Deno.PointerValue {
    return Number(this.view.getBigUint64(16, true));
  }

  // 0x18: u32
  get dwEncodingType(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get fdwStoreFlags(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: pointer
  get hReserved(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get hAttrs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get hCryptMsg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get hSorted(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwPublicVersion(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: buffer
  set pwszP7File(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: usize
  set hProv(value: Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(value), true);
  }

  // 0x18: u32
  set dwEncodingType(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set fdwStoreFlags(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: pointer
  set hReserved(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set hAttrs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set hCryptMsg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set hSorted(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB (size: 16)
 */
export interface CRYPTOAPI_BLOB {
  /** u32 */
  cbData: number;
  /** ptr */
  pbData: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPTOAPI_BLOB = 16;

export function allocCRYPTOAPI_BLOB(data?: Partial<CRYPTOAPI_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTOAPI_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbData !== undefined) view.setUint32(0, Number(data.cbData), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbData !== undefined) view.setBigUint64(8, data.pbData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbData))), true);
  return buf;
}

export class CRYPTOAPI_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbData(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbData(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Catalog.CRYPTCATMEMBER (size: 80)
 */
export interface CRYPTCATMEMBER {
  /** u32 */
  cbStruct: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszReferenceTag: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszFileName: string | null | Uint8Array | Uint16Array;
  /** System.Guid */
  gSubjectType: Uint8Array | Deno.PointerValue;
  /** u32 */
  fdwMemberFlags: number;
  /** ptr */
  pIndirectData: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwCertVersion: number;
  /** u32 */
  dwReserved: number;
  /** Windows.Win32.Foundation.HANDLE */
  hReserved: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  sEncodedIndirectData: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  sEncodedMemberInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPTCATMEMBER = 80;

export function allocCRYPTCATMEMBER(data?: Partial<CRYPTCATMEMBER>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTCATMEMBER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pwszReferenceTag !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszReferenceTag);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pwszFileName !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszFileName);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: pointer
  if (data?.gSubjectType !== undefined) view.setBigUint64(24, data.gSubjectType === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.gSubjectType))), true);
  // 0x20: u32
  if (data?.fdwMemberFlags !== undefined) view.setUint32(32, Number(data.fdwMemberFlags), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.pIndirectData !== undefined) view.setBigUint64(40, data.pIndirectData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pIndirectData))), true);
  // 0x30: u32
  if (data?.dwCertVersion !== undefined) view.setUint32(48, Number(data.dwCertVersion), true);
  // 0x34: u32
  if (data?.dwReserved !== undefined) view.setUint32(52, Number(data.dwReserved), true);
  // 0x38: pointer
  if (data?.hReserved !== undefined) view.setBigUint64(56, data.hReserved === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hReserved))), true);
  // 0x40: pointer
  if (data?.sEncodedIndirectData !== undefined) view.setBigUint64(64, data.sEncodedIndirectData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.sEncodedIndirectData))), true);
  // 0x48: pointer
  if (data?.sEncodedMemberInfo !== undefined) view.setBigUint64(72, data.sEncodedMemberInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.sEncodedMemberInfo))), true);
  return buf;
}

export class CRYPTCATMEMBERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pwszReferenceTag(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get gSubjectType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get fdwMemberFlags(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get pIndirectData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get dwCertVersion(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: u32
  get dwReserved(): number {
    return this.view.getUint32(52, true);
  }

  // 0x38: pointer
  get hReserved(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: pointer
  get sEncodedIndirectData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: pointer
  get sEncodedMemberInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pwszReferenceTag(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pwszFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: pointer
  set gSubjectType(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set fdwMemberFlags(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set pIndirectData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set dwCertVersion(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: u32
  set dwReserved(value: number) {
    this.view.setUint32(52, value, true);
  }

  // 0x38: pointer
  set hReserved(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: pointer
  set sEncodedIndirectData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: pointer
  set sEncodedMemberInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Catalog.CRYPTCATATTRIBUTE (size: 40)
 */
export interface CRYPTCATATTRIBUTE {
  /** u32 */
  cbStruct: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszReferenceTag: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwAttrTypeAndAction: number;
  /** u32 */
  cbValue: number;
  /** ptr */
  pbValue: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwReserved: number;
}

export const sizeofCRYPTCATATTRIBUTE = 40;

export function allocCRYPTCATATTRIBUTE(data?: Partial<CRYPTCATATTRIBUTE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTCATATTRIBUTE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pwszReferenceTag !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszReferenceTag);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.dwAttrTypeAndAction !== undefined) view.setUint32(16, Number(data.dwAttrTypeAndAction), true);
  // 0x14: u32
  if (data?.cbValue !== undefined) view.setUint32(20, Number(data.cbValue), true);
  // 0x18: pointer
  if (data?.pbValue !== undefined) view.setBigUint64(24, data.pbValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbValue))), true);
  // 0x20: u32
  if (data?.dwReserved !== undefined) view.setUint32(32, Number(data.dwReserved), true);
  // 0x24: pad4
  return buf;
}

export class CRYPTCATATTRIBUTEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pwszReferenceTag(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwAttrTypeAndAction(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get cbValue(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get pbValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwReserved(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pwszReferenceTag(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set dwAttrTypeAndAction(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set cbValue(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set pbValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set dwReserved(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

export type BOOL = number;

/**
 * Windows.Win32.Security.Cryptography.Catalog.CRYPTCATCDF (size: 48)
 */
export interface CRYPTCATCDF {
  /** u32 */
  cbStruct: number;
  /** Windows.Win32.Foundation.HANDLE */
  hFile: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwCurFilePos: number;
  /** u32 */
  dwLastMemberOffset: number;
  /** Windows.Win32.Foundation.BOOL */
  fEOF: boolean;
  /** Windows.Win32.Foundation.PWSTR */
  pwszResultDir: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.HANDLE */
  hCATStore: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPTCATCDF = 48;

export function allocCRYPTCATCDF(data?: Partial<CRYPTCATCDF>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTCATCDF);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hFile !== undefined) view.setBigUint64(8, data.hFile === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hFile))), true);
  // 0x10: u32
  if (data?.dwCurFilePos !== undefined) view.setUint32(16, Number(data.dwCurFilePos), true);
  // 0x14: u32
  if (data?.dwLastMemberOffset !== undefined) view.setUint32(20, Number(data.dwLastMemberOffset), true);
  // 0x18: i32
  if (data?.fEOF !== undefined) view.setInt32(24, Number(data.fEOF), true);
  // 0x1c: pad4
  // 0x20: buffer
  if (data?.pwszResultDir !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.pwszResultDir);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: pointer
  if (data?.hCATStore !== undefined) view.setBigUint64(40, data.hCATStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCATStore))), true);
  return buf;
}

export class CRYPTCATCDFView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hFile(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwCurFilePos(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwLastMemberOffset(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: i32
  get fEOF(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  get pwszResultDir(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get hCATStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hFile(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwCurFilePos(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwLastMemberOffset(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: i32
  set fEOF(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  set pwszResultDir(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: pointer
  set hCATStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Catalog.CATALOG_INFO (size: 16)
 */
export interface CATALOG_INFO {
  /** u32 */
  cbStruct: number;
  /** array */
  wszCatalogFile: Deno.PointerValue;
}

export const sizeofCATALOG_INFO = 16;

export function allocCATALOG_INFO(data?: Partial<CATALOG_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCATALOG_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.wszCatalogFile !== undefined) view.setBigUint64(8, data.wszCatalogFile === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.wszCatalogFile))), true);
  return buf;
}

export class CATALOG_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get wszCatalogFile(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set wszCatalogFile(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMS_KEY_INFO (size: 24)
 */
export interface CMS_KEY_INFO {
  /** u32 */
  dwVersion: number;
  /** u32 */
  Algid: number;
  /** ptr */
  pbOID: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbOID: number;
}

export const sizeofCMS_KEY_INFO = 24;

export function allocCMS_KEY_INFO(data?: Partial<CMS_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMS_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: u32
  if (data?.Algid !== undefined) view.setUint32(4, Number(data.Algid), true);
  // 0x08: pointer
  if (data?.pbOID !== undefined) view.setBigUint64(8, data.pbOID === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbOID))), true);
  // 0x10: u32
  if (data?.cbOID !== undefined) view.setUint32(16, Number(data.cbOID), true);
  // 0x14: pad4
  return buf;
}

export class CMS_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Algid(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pbOID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbOID(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Algid(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pbOID(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbOID(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.HMAC_INFO (size: 40)
 */
export interface HMAC_INFO {
  /** u32 */
  HashAlgid: number;
  /** ptr */
  pbInnerString: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbInnerString: number;
  /** ptr */
  pbOuterString: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbOuterString: number;
}

export const sizeofHMAC_INFO = 40;

export function allocHMAC_INFO(data?: Partial<HMAC_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofHMAC_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.HashAlgid !== undefined) view.setUint32(0, Number(data.HashAlgid), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbInnerString !== undefined) view.setBigUint64(8, data.pbInnerString === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbInnerString))), true);
  // 0x10: u32
  if (data?.cbInnerString !== undefined) view.setUint32(16, Number(data.cbInnerString), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pbOuterString !== undefined) view.setBigUint64(24, data.pbOuterString === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbOuterString))), true);
  // 0x20: u32
  if (data?.cbOuterString !== undefined) view.setUint32(32, Number(data.cbOuterString), true);
  // 0x24: pad4
  return buf;
}

export class HMAC_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get HashAlgid(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbInnerString(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbInnerString(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pbOuterString(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cbOuterString(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: u32
  set HashAlgid(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbInnerString(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbInnerString(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pbOuterString(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cbOuterString(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.Security.Cryptography.SCHANNEL_ALG (size: 24)
 */
export interface SCHANNEL_ALG {
  /** u32 */
  dwUse: number;
  /** u32 */
  Algid: number;
  /** u32 */
  cBits: number;
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwReserved: number;
}

export const sizeofSCHANNEL_ALG = 24;

export function allocSCHANNEL_ALG(data?: Partial<SCHANNEL_ALG>): Uint8Array {
  const buf = new Uint8Array(sizeofSCHANNEL_ALG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwUse !== undefined) view.setUint32(0, Number(data.dwUse), true);
  // 0x04: u32
  if (data?.Algid !== undefined) view.setUint32(4, Number(data.Algid), true);
  // 0x08: u32
  if (data?.cBits !== undefined) view.setUint32(8, Number(data.cBits), true);
  // 0x0c: u32
  if (data?.dwFlags !== undefined) view.setUint32(12, Number(data.dwFlags), true);
  // 0x10: u32
  if (data?.dwReserved !== undefined) view.setUint32(16, Number(data.dwReserved), true);
  // 0x14: pad4
  return buf;
}

export class SCHANNEL_ALGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwUse(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Algid(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cBits(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwFlags(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get dwReserved(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set dwUse(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Algid(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cBits(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwFlags(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set dwReserved(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.PROV_ENUMALGS (size: 24)
 */
export interface PROV_ENUMALGS {
  /** u32 */
  aiAlgid: number;
  /** u32 */
  dwBitLen: number;
  /** u32 */
  dwNameLen: number;
  /** array */
  szName: Deno.PointerValue;
}

export const sizeofPROV_ENUMALGS = 24;

export function allocPROV_ENUMALGS(data?: Partial<PROV_ENUMALGS>): Uint8Array {
  const buf = new Uint8Array(sizeofPROV_ENUMALGS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.aiAlgid !== undefined) view.setUint32(0, Number(data.aiAlgid), true);
  // 0x04: u32
  if (data?.dwBitLen !== undefined) view.setUint32(4, Number(data.dwBitLen), true);
  // 0x08: u32
  if (data?.dwNameLen !== undefined) view.setUint32(8, Number(data.dwNameLen), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.szName !== undefined) view.setBigUint64(16, data.szName === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.szName))), true);
  return buf;
}

export class PROV_ENUMALGSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get aiAlgid(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwBitLen(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwNameLen(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get szName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set aiAlgid(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwBitLen(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwNameLen(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set szName(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.PROV_ENUMALGS_EX (size: 48)
 */
export interface PROV_ENUMALGS_EX {
  /** u32 */
  aiAlgid: number;
  /** u32 */
  dwDefaultLen: number;
  /** u32 */
  dwMinLen: number;
  /** u32 */
  dwMaxLen: number;
  /** u32 */
  dwProtocols: number;
  /** u32 */
  dwNameLen: number;
  /** array */
  szName: Deno.PointerValue;
  /** u32 */
  dwLongNameLen: number;
  /** array */
  szLongName: Deno.PointerValue;
}

export const sizeofPROV_ENUMALGS_EX = 48;

export function allocPROV_ENUMALGS_EX(data?: Partial<PROV_ENUMALGS_EX>): Uint8Array {
  const buf = new Uint8Array(sizeofPROV_ENUMALGS_EX);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.aiAlgid !== undefined) view.setUint32(0, Number(data.aiAlgid), true);
  // 0x04: u32
  if (data?.dwDefaultLen !== undefined) view.setUint32(4, Number(data.dwDefaultLen), true);
  // 0x08: u32
  if (data?.dwMinLen !== undefined) view.setUint32(8, Number(data.dwMinLen), true);
  // 0x0c: u32
  if (data?.dwMaxLen !== undefined) view.setUint32(12, Number(data.dwMaxLen), true);
  // 0x10: u32
  if (data?.dwProtocols !== undefined) view.setUint32(16, Number(data.dwProtocols), true);
  // 0x14: u32
  if (data?.dwNameLen !== undefined) view.setUint32(20, Number(data.dwNameLen), true);
  // 0x18: pointer
  if (data?.szName !== undefined) view.setBigUint64(24, data.szName === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.szName))), true);
  // 0x20: u32
  if (data?.dwLongNameLen !== undefined) view.setUint32(32, Number(data.dwLongNameLen), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.szLongName !== undefined) view.setBigUint64(40, data.szLongName === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.szLongName))), true);
  return buf;
}

export class PROV_ENUMALGS_EXView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get aiAlgid(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwDefaultLen(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwMinLen(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwMaxLen(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get dwProtocols(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwNameLen(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get szName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwLongNameLen(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get szLongName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set aiAlgid(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwDefaultLen(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwMinLen(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwMaxLen(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set dwProtocols(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwNameLen(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set szName(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set dwLongNameLen(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set szLongName(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.PUBLICKEYSTRUC (size: 8)
 */
export interface PUBLICKEYSTRUC {
  /** u8 */
  bType: number;
  /** u8 */
  bVersion: number;
  /** u16 */
  reserved: number;
  /** u32 */
  aiKeyAlg: number;
}

export const sizeofPUBLICKEYSTRUC = 8;

export function allocPUBLICKEYSTRUC(data?: Partial<PUBLICKEYSTRUC>): Uint8Array {
  const buf = new Uint8Array(sizeofPUBLICKEYSTRUC);
  const view = new DataView(buf.buffer);
  // 0x00: u8
  if (data?.bType !== undefined) view.setUint8(0, Number(data.bType));
  // 0x01: u8
  if (data?.bVersion !== undefined) view.setUint8(1, Number(data.bVersion));
  // 0x02: u16
  if (data?.reserved !== undefined) view.setUint16(2, Number(data.reserved), true);
  // 0x04: u32
  if (data?.aiKeyAlg !== undefined) view.setUint32(4, Number(data.aiKeyAlg), true);
  return buf;
}

export class PUBLICKEYSTRUCView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u8
  get bType(): number {
    return this.view.getUint8(0);
  }

  // 0x01: u8
  get bVersion(): number {
    return this.view.getUint8(1);
  }

  // 0x02: u16
  get reserved(): number {
    return this.view.getUint16(2, true);
  }

  // 0x04: u32
  get aiKeyAlg(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u8
  set bType(value: number) {
    this.view.setUint8(0, value);
  }

  // 0x01: u8
  set bVersion(value: number) {
    this.view.setUint8(1, value);
  }

  // 0x02: u16
  set reserved(value: number) {
    this.view.setUint16(2, value, true);
  }

  // 0x04: u32
  set aiKeyAlg(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.RSAPUBKEY (size: 16)
 */
export interface RSAPUBKEY {
  /** u32 */
  magic: number;
  /** u32 */
  bitlen: number;
  /** u32 */
  pubexp: number;
}

export const sizeofRSAPUBKEY = 16;

export function allocRSAPUBKEY(data?: Partial<RSAPUBKEY>): Uint8Array {
  const buf = new Uint8Array(sizeofRSAPUBKEY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.magic !== undefined) view.setUint32(0, Number(data.magic), true);
  // 0x04: u32
  if (data?.bitlen !== undefined) view.setUint32(4, Number(data.bitlen), true);
  // 0x08: u32
  if (data?.pubexp !== undefined) view.setUint32(8, Number(data.pubexp), true);
  // 0x0c: pad4
  return buf;
}

export class RSAPUBKEYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get bitlen(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get pubexp(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set bitlen(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set pubexp(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.PUBKEY (size: 8)
 */
export interface PUBKEY {
  /** u32 */
  magic: number;
  /** u32 */
  bitlen: number;
}

export const sizeofPUBKEY = 8;

export function allocPUBKEY(data?: Partial<PUBKEY>): Uint8Array {
  const buf = new Uint8Array(sizeofPUBKEY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.magic !== undefined) view.setUint32(0, Number(data.magic), true);
  // 0x04: u32
  if (data?.bitlen !== undefined) view.setUint32(4, Number(data.bitlen), true);
  return buf;
}

export class PUBKEYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get bitlen(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set bitlen(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.DSSSEED (size: 16)
 */
export interface DSSSEED {
  /** u32 */
  counter: number;
  /** array */
  seed: Deno.PointerValue;
}

export const sizeofDSSSEED = 16;

export function allocDSSSEED(data?: Partial<DSSSEED>): Uint8Array {
  const buf = new Uint8Array(sizeofDSSSEED);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.counter !== undefined) view.setUint32(0, Number(data.counter), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.seed !== undefined) view.setBigUint64(8, data.seed === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.seed))), true);
  return buf;
}

export class DSSSEEDView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get counter(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get seed(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set counter(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set seed(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.PUBKEYVER3 (size: 24)
 */
export interface PUBKEYVER3 {
  /** u32 */
  magic: number;
  /** u32 */
  bitlenP: number;
  /** u32 */
  bitlenQ: number;
  /** u32 */
  bitlenJ: number;
  /** Windows.Win32.Security.Cryptography.DSSSEED */
  DSSSeed: Uint8Array | Deno.PointerValue;
}

export const sizeofPUBKEYVER3 = 24;

export function allocPUBKEYVER3(data?: Partial<PUBKEYVER3>): Uint8Array {
  const buf = new Uint8Array(sizeofPUBKEYVER3);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.magic !== undefined) view.setUint32(0, Number(data.magic), true);
  // 0x04: u32
  if (data?.bitlenP !== undefined) view.setUint32(4, Number(data.bitlenP), true);
  // 0x08: u32
  if (data?.bitlenQ !== undefined) view.setUint32(8, Number(data.bitlenQ), true);
  // 0x0c: u32
  if (data?.bitlenJ !== undefined) view.setUint32(12, Number(data.bitlenJ), true);
  // 0x10: pointer
  if (data?.DSSSeed !== undefined) view.setBigUint64(16, data.DSSSeed === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DSSSeed))), true);
  return buf;
}

export class PUBKEYVER3View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get bitlenP(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get bitlenQ(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get bitlenJ(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: pointer
  get DSSSeed(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set bitlenP(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set bitlenQ(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set bitlenJ(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: pointer
  set DSSSeed(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.PRIVKEYVER3 (size: 32)
 */
export interface PRIVKEYVER3 {
  /** u32 */
  magic: number;
  /** u32 */
  bitlenP: number;
  /** u32 */
  bitlenQ: number;
  /** u32 */
  bitlenJ: number;
  /** u32 */
  bitlenX: number;
  /** Windows.Win32.Security.Cryptography.DSSSEED */
  DSSSeed: Uint8Array | Deno.PointerValue;
}

export const sizeofPRIVKEYVER3 = 32;

export function allocPRIVKEYVER3(data?: Partial<PRIVKEYVER3>): Uint8Array {
  const buf = new Uint8Array(sizeofPRIVKEYVER3);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.magic !== undefined) view.setUint32(0, Number(data.magic), true);
  // 0x04: u32
  if (data?.bitlenP !== undefined) view.setUint32(4, Number(data.bitlenP), true);
  // 0x08: u32
  if (data?.bitlenQ !== undefined) view.setUint32(8, Number(data.bitlenQ), true);
  // 0x0c: u32
  if (data?.bitlenJ !== undefined) view.setUint32(12, Number(data.bitlenJ), true);
  // 0x10: u32
  if (data?.bitlenX !== undefined) view.setUint32(16, Number(data.bitlenX), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.DSSSeed !== undefined) view.setBigUint64(24, data.DSSSeed === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DSSSeed))), true);
  return buf;
}

export class PRIVKEYVER3View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get bitlenP(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get bitlenQ(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get bitlenJ(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get bitlenX(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get DSSSeed(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set bitlenP(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set bitlenQ(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set bitlenJ(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set bitlenX(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set DSSSeed(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.KEY_TYPE_SUBTYPE (size: 24)
 */
export interface KEY_TYPE_SUBTYPE {
  /** u32 */
  dwKeySpec: number;
  /** System.Guid */
  Type: Uint8Array | Deno.PointerValue;
  /** System.Guid */
  Subtype: Uint8Array | Deno.PointerValue;
}

export const sizeofKEY_TYPE_SUBTYPE = 24;

export function allocKEY_TYPE_SUBTYPE(data?: Partial<KEY_TYPE_SUBTYPE>): Uint8Array {
  const buf = new Uint8Array(sizeofKEY_TYPE_SUBTYPE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(0, Number(data.dwKeySpec), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Type !== undefined) view.setBigUint64(8, data.Type === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Type))), true);
  // 0x10: pointer
  if (data?.Subtype !== undefined) view.setBigUint64(16, data.Subtype === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Subtype))), true);
  return buf;
}

export class KEY_TYPE_SUBTYPEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwKeySpec(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Type(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Subtype(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Type(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Subtype(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_FORTEZZA_DATA_PROP (size: 24)
 */
export interface CERT_FORTEZZA_DATA_PROP {
  /** array */
  SerialNumber: Deno.PointerValue;
  /** i32 */
  CertIndex: number;
  /** array */
  CertLabel: Deno.PointerValue;
}

export const sizeofCERT_FORTEZZA_DATA_PROP = 24;

export function allocCERT_FORTEZZA_DATA_PROP(data?: Partial<CERT_FORTEZZA_DATA_PROP>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_FORTEZZA_DATA_PROP);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.SerialNumber !== undefined) view.setBigUint64(0, data.SerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SerialNumber))), true);
  // 0x08: i32
  if (data?.CertIndex !== undefined) view.setInt32(8, Number(data.CertIndex), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.CertLabel !== undefined) view.setBigUint64(16, data.CertLabel === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CertLabel))), true);
  return buf;
}

export class CERT_FORTEZZA_DATA_PROPView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get SerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: i32
  get CertIndex(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get CertLabel(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set SerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: i32
  set CertIndex(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set CertLabel(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_RC4_KEY_STATE (size: 24)
 */
export interface CRYPT_RC4_KEY_STATE {
  /** array */
  Key: Deno.PointerValue;
  /** array */
  SBox: Deno.PointerValue;
  /** u8 */
  i: number;
  /** u8 */
  j: number;
}

export const sizeofCRYPT_RC4_KEY_STATE = 24;

export function allocCRYPT_RC4_KEY_STATE(data?: Partial<CRYPT_RC4_KEY_STATE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_RC4_KEY_STATE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Key !== undefined) view.setBigUint64(0, data.Key === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Key))), true);
  // 0x08: pointer
  if (data?.SBox !== undefined) view.setBigUint64(8, data.SBox === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SBox))), true);
  // 0x10: u8
  if (data?.i !== undefined) view.setUint8(16, Number(data.i));
  // 0x11: u8
  if (data?.j !== undefined) view.setUint8(17, Number(data.j));
  // 0x12: pad6
  return buf;
}

export class CRYPT_RC4_KEY_STATEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Key(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get SBox(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u8
  get i(): number {
    return this.view.getUint8(16);
  }

  // 0x11: u8
  get j(): number {
    return this.view.getUint8(17);
  }

  // 0x12: pad6

  // 0x00: pointer
  set Key(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set SBox(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u8
  set i(value: number) {
    this.view.setUint8(16, value);
  }

  // 0x11: u8
  set j(value: number) {
    this.view.setUint8(17, value);
  }

  // 0x12: pad6
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_DES_KEY_STATE (size: 24)
 */
export interface CRYPT_DES_KEY_STATE {
  /** array */
  Key: Deno.PointerValue;
  /** array */
  IV: Deno.PointerValue;
  /** array */
  Feedback: Deno.PointerValue;
}

export const sizeofCRYPT_DES_KEY_STATE = 24;

export function allocCRYPT_DES_KEY_STATE(data?: Partial<CRYPT_DES_KEY_STATE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_DES_KEY_STATE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Key !== undefined) view.setBigUint64(0, data.Key === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Key))), true);
  // 0x08: pointer
  if (data?.IV !== undefined) view.setBigUint64(8, data.IV === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IV))), true);
  // 0x10: pointer
  if (data?.Feedback !== undefined) view.setBigUint64(16, data.Feedback === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Feedback))), true);
  return buf;
}

export class CRYPT_DES_KEY_STATEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Key(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get IV(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Feedback(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Key(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set IV(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Feedback(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_3DES_KEY_STATE (size: 24)
 */
export interface CRYPT_3DES_KEY_STATE {
  /** array */
  Key: Deno.PointerValue;
  /** array */
  IV: Deno.PointerValue;
  /** array */
  Feedback: Deno.PointerValue;
}

export const sizeofCRYPT_3DES_KEY_STATE = 24;

export function allocCRYPT_3DES_KEY_STATE(data?: Partial<CRYPT_3DES_KEY_STATE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_3DES_KEY_STATE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Key !== undefined) view.setBigUint64(0, data.Key === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Key))), true);
  // 0x08: pointer
  if (data?.IV !== undefined) view.setBigUint64(8, data.IV === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IV))), true);
  // 0x10: pointer
  if (data?.Feedback !== undefined) view.setBigUint64(16, data.Feedback === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Feedback))), true);
  return buf;
}

export class CRYPT_3DES_KEY_STATEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Key(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get IV(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Feedback(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Key(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set IV(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Feedback(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_AES_128_KEY_STATE (size: 40)
 */
export interface CRYPT_AES_128_KEY_STATE {
  /** array */
  Key: Deno.PointerValue;
  /** array */
  IV: Deno.PointerValue;
  /** array */
  EncryptionState: Deno.PointerValue;
  /** array */
  DecryptionState: Deno.PointerValue;
  /** array */
  Feedback: Deno.PointerValue;
}

export const sizeofCRYPT_AES_128_KEY_STATE = 40;

export function allocCRYPT_AES_128_KEY_STATE(data?: Partial<CRYPT_AES_128_KEY_STATE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_AES_128_KEY_STATE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Key !== undefined) view.setBigUint64(0, data.Key === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Key))), true);
  // 0x08: pointer
  if (data?.IV !== undefined) view.setBigUint64(8, data.IV === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IV))), true);
  // 0x10: pointer
  if (data?.EncryptionState !== undefined) view.setBigUint64(16, data.EncryptionState === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptionState))), true);
  // 0x18: pointer
  if (data?.DecryptionState !== undefined) view.setBigUint64(24, data.DecryptionState === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DecryptionState))), true);
  // 0x20: pointer
  if (data?.Feedback !== undefined) view.setBigUint64(32, data.Feedback === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Feedback))), true);
  return buf;
}

export class CRYPT_AES_128_KEY_STATEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Key(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get IV(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get EncryptionState(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get DecryptionState(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get Feedback(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Key(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set IV(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set EncryptionState(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set DecryptionState(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set Feedback(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_AES_256_KEY_STATE (size: 40)
 */
export interface CRYPT_AES_256_KEY_STATE {
  /** array */
  Key: Deno.PointerValue;
  /** array */
  IV: Deno.PointerValue;
  /** array */
  EncryptionState: Deno.PointerValue;
  /** array */
  DecryptionState: Deno.PointerValue;
  /** array */
  Feedback: Deno.PointerValue;
}

export const sizeofCRYPT_AES_256_KEY_STATE = 40;

export function allocCRYPT_AES_256_KEY_STATE(data?: Partial<CRYPT_AES_256_KEY_STATE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_AES_256_KEY_STATE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Key !== undefined) view.setBigUint64(0, data.Key === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Key))), true);
  // 0x08: pointer
  if (data?.IV !== undefined) view.setBigUint64(8, data.IV === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IV))), true);
  // 0x10: pointer
  if (data?.EncryptionState !== undefined) view.setBigUint64(16, data.EncryptionState === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptionState))), true);
  // 0x18: pointer
  if (data?.DecryptionState !== undefined) view.setBigUint64(24, data.DecryptionState === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DecryptionState))), true);
  // 0x20: pointer
  if (data?.Feedback !== undefined) view.setBigUint64(32, data.Feedback === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Feedback))), true);
  return buf;
}

export class CRYPT_AES_256_KEY_STATEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Key(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get IV(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get EncryptionState(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get DecryptionState(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get Feedback(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Key(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set IV(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set EncryptionState(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set DecryptionState(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set Feedback(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

export type PSTR = Deno.PointerValue | Uint8Array;

/**
 * Windows.Win32.Security.Cryptography.CMS_DH_KEY_INFO (size: 32)
 */
export interface CMS_DH_KEY_INFO {
  /** u32 */
  dwVersion: number;
  /** u32 */
  Algid: number;
  /** Windows.Win32.Foundation.PSTR */
  pszContentEncObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  PubInfo: Uint8Array | Deno.PointerValue;
  /** ptr */
  pReserved: Deno.PointerValue | Uint8Array;
}

export const sizeofCMS_DH_KEY_INFO = 32;

export function allocCMS_DH_KEY_INFO(data?: Partial<CMS_DH_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMS_DH_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: u32
  if (data?.Algid !== undefined) view.setUint32(4, Number(data.Algid), true);
  // 0x08: buffer
  if (data?.pszContentEncObjId !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszContentEncObjId);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.PubInfo !== undefined) view.setBigUint64(16, data.PubInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PubInfo))), true);
  // 0x18: pointer
  if (data?.pReserved !== undefined) view.setBigUint64(24, data.pReserved === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pReserved))), true);
  return buf;
}

export class CMS_DH_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Algid(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: buffer
  get pszContentEncObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get PubInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pReserved(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Algid(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: buffer
  set pszContentEncObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set PubInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pReserved(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_KEY_LENGTHS_STRUCT (size: 16)
 */
export interface BCRYPT_KEY_LENGTHS_STRUCT {
  /** u32 */
  dwMinLength: number;
  /** u32 */
  dwMaxLength: number;
  /** u32 */
  dwIncrement: number;
}

export const sizeofBCRYPT_KEY_LENGTHS_STRUCT = 16;

export function allocBCRYPT_KEY_LENGTHS_STRUCT(data?: Partial<BCRYPT_KEY_LENGTHS_STRUCT>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_KEY_LENGTHS_STRUCT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMinLength !== undefined) view.setUint32(0, Number(data.dwMinLength), true);
  // 0x04: u32
  if (data?.dwMaxLength !== undefined) view.setUint32(4, Number(data.dwMaxLength), true);
  // 0x08: u32
  if (data?.dwIncrement !== undefined) view.setUint32(8, Number(data.dwIncrement), true);
  // 0x0c: pad4
  return buf;
}

export class BCRYPT_KEY_LENGTHS_STRUCTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMinLength(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMaxLength(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwIncrement(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set dwMinLength(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMaxLength(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwIncrement(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_OID (size: 16)
 */
export interface BCRYPT_OID {
  /** u32 */
  cbOID: number;
  /** ptr */
  pbOID: Deno.PointerValue | Uint8Array;
}

export const sizeofBCRYPT_OID = 16;

export function allocBCRYPT_OID(data?: Partial<BCRYPT_OID>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_OID);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbOID !== undefined) view.setUint32(0, Number(data.cbOID), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbOID !== undefined) view.setBigUint64(8, data.pbOID === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbOID))), true);
  return buf;
}

export class BCRYPT_OIDView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbOID(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbOID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbOID(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbOID(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_OID_LIST (size: 16)
 */
export interface BCRYPT_OID_LIST {
  /** u32 */
  dwOIDCount: number;
  /** ptr */
  pOIDs: Deno.PointerValue | Uint8Array;
}

export const sizeofBCRYPT_OID_LIST = 16;

export function allocBCRYPT_OID_LIST(data?: Partial<BCRYPT_OID_LIST>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_OID_LIST);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwOIDCount !== undefined) view.setUint32(0, Number(data.dwOIDCount), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pOIDs !== undefined) view.setBigUint64(8, data.pOIDs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pOIDs))), true);
  return buf;
}

export class BCRYPT_OID_LISTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwOIDCount(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pOIDs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwOIDCount(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pOIDs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_PKCS1_PADDING_INFO (size: 8)
 */
export interface BCRYPT_PKCS1_PADDING_INFO {
  /** Windows.Win32.Foundation.PWSTR */
  pszAlgId: string | null | Uint8Array | Uint16Array;
}

export const sizeofBCRYPT_PKCS1_PADDING_INFO = 8;

export function allocBCRYPT_PKCS1_PADDING_INFO(data?: Partial<BCRYPT_PKCS1_PADDING_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_PKCS1_PADDING_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszAlgId !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszAlgId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  return buf;
}

export class BCRYPT_PKCS1_PADDING_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszAlgId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszAlgId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_PSS_PADDING_INFO (size: 16)
 */
export interface BCRYPT_PSS_PADDING_INFO {
  /** Windows.Win32.Foundation.PWSTR */
  pszAlgId: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cbSalt: number;
}

export const sizeofBCRYPT_PSS_PADDING_INFO = 16;

export function allocBCRYPT_PSS_PADDING_INFO(data?: Partial<BCRYPT_PSS_PADDING_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_PSS_PADDING_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszAlgId !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszAlgId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cbSalt !== undefined) view.setUint32(8, Number(data.cbSalt), true);
  // 0x0c: pad4
  return buf;
}

export class BCRYPT_PSS_PADDING_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszAlgId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cbSalt(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: buffer
  set pszAlgId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cbSalt(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_OAEP_PADDING_INFO (size: 24)
 */
export interface BCRYPT_OAEP_PADDING_INFO {
  /** Windows.Win32.Foundation.PWSTR */
  pszAlgId: string | null | Uint8Array | Uint16Array;
  /** ptr */
  pbLabel: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbLabel: number;
}

export const sizeofBCRYPT_OAEP_PADDING_INFO = 24;

export function allocBCRYPT_OAEP_PADDING_INFO(data?: Partial<BCRYPT_OAEP_PADDING_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_OAEP_PADDING_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszAlgId !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszAlgId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.pbLabel !== undefined) view.setBigUint64(8, data.pbLabel === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbLabel))), true);
  // 0x10: u32
  if (data?.cbLabel !== undefined) view.setUint32(16, Number(data.cbLabel), true);
  // 0x14: pad4
  return buf;
}

export class BCRYPT_OAEP_PADDING_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszAlgId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pbLabel(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbLabel(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: buffer
  set pszAlgId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set pbLabel(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbLabel(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO (size: 88)
 */
export interface BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwInfoVersion: number;
  /** ptr */
  pbNonce: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbNonce: number;
  /** ptr */
  pbAuthData: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbAuthData: number;
  /** ptr */
  pbTag: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbTag: number;
  /** ptr */
  pbMacContext: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbMacContext: number;
  /** u32 */
  cbAAD: number;
  /** u64 */
  cbData: Deno.PointerValue;
  /** u32 */
  dwFlags: number;
}

export const sizeofBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = 88;

export function allocBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(data?: Partial<BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwInfoVersion !== undefined) view.setUint32(4, Number(data.dwInfoVersion), true);
  // 0x08: pointer
  if (data?.pbNonce !== undefined) view.setBigUint64(8, data.pbNonce === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbNonce))), true);
  // 0x10: u32
  if (data?.cbNonce !== undefined) view.setUint32(16, Number(data.cbNonce), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pbAuthData !== undefined) view.setBigUint64(24, data.pbAuthData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbAuthData))), true);
  // 0x20: u32
  if (data?.cbAuthData !== undefined) view.setUint32(32, Number(data.cbAuthData), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.pbTag !== undefined) view.setBigUint64(40, data.pbTag === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbTag))), true);
  // 0x30: u32
  if (data?.cbTag !== undefined) view.setUint32(48, Number(data.cbTag), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.pbMacContext !== undefined) view.setBigUint64(56, data.pbMacContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbMacContext))), true);
  // 0x40: u32
  if (data?.cbMacContext !== undefined) view.setUint32(64, Number(data.cbMacContext), true);
  // 0x44: u32
  if (data?.cbAAD !== undefined) view.setUint32(68, Number(data.cbAAD), true);
  // 0x48: u64
  if (data?.cbData !== undefined) view.setBigUint64(72, BigInt(data.cbData), true);
  // 0x50: u32
  if (data?.dwFlags !== undefined) view.setUint32(80, Number(data.dwFlags), true);
  // 0x54: pad4
  return buf;
}

export class BCRYPT_AUTHENTICATED_CIPHER_MODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwInfoVersion(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pbNonce(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbNonce(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pbAuthData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cbAuthData(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get pbTag(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cbTag(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get pbMacContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: u32
  get cbMacContext(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: u32
  get cbAAD(): number {
    return this.view.getUint32(68, true);
  }

  // 0x48: u64
  get cbData(): Deno.PointerValue {
    return Number(this.view.getBigUint64(72, true));
  }

  // 0x50: u32
  get dwFlags(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwInfoVersion(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pbNonce(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbNonce(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pbAuthData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cbAuthData(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set pbTag(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cbTag(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set pbMacContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: u32
  set cbMacContext(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: u32
  set cbAAD(value: number) {
    this.view.setUint32(68, value, true);
  }

  // 0x48: u64
  set cbData(value: Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(value), true);
  }

  // 0x50: u32
  set dwFlags(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCryptBuffer (size: 16)
 */
export interface BCryptBuffer {
  /** u32 */
  cbBuffer: number;
  /** u32 */
  BufferType: number;
  /** ptr */
  pvBuffer: Deno.PointerValue | Uint8Array;
}

export const sizeofBCryptBuffer = 16;

export function allocBCryptBuffer(data?: Partial<BCryptBuffer>): Uint8Array {
  const buf = new Uint8Array(sizeofBCryptBuffer);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbBuffer !== undefined) view.setUint32(0, Number(data.cbBuffer), true);
  // 0x04: u32
  if (data?.BufferType !== undefined) view.setUint32(4, Number(data.BufferType), true);
  // 0x08: pointer
  if (data?.pvBuffer !== undefined) view.setBigUint64(8, data.pvBuffer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvBuffer))), true);
  return buf;
}

export class BCryptBufferView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbBuffer(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get BufferType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pvBuffer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbBuffer(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set BufferType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pvBuffer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCryptBufferDesc (size: 16)
 */
export interface BCryptBufferDesc {
  /** u32 */
  ulVersion: number;
  /** u32 */
  cBuffers: number;
  /** ptr */
  pBuffers: Deno.PointerValue | Uint8Array;
}

export const sizeofBCryptBufferDesc = 16;

export function allocBCryptBufferDesc(data?: Partial<BCryptBufferDesc>): Uint8Array {
  const buf = new Uint8Array(sizeofBCryptBufferDesc);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.ulVersion !== undefined) view.setUint32(0, Number(data.ulVersion), true);
  // 0x04: u32
  if (data?.cBuffers !== undefined) view.setUint32(4, Number(data.cBuffers), true);
  // 0x08: pointer
  if (data?.pBuffers !== undefined) view.setBigUint64(8, data.pBuffers === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pBuffers))), true);
  return buf;
}

export class BCryptBufferDescView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get ulVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cBuffers(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pBuffers(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set ulVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cBuffers(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pBuffers(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_KEY_BLOB (size: 8)
 */
export interface BCRYPT_KEY_BLOB {
  /** u32 */
  Magic: number;
}

export const sizeofBCRYPT_KEY_BLOB = 8;

export function allocBCRYPT_KEY_BLOB(data?: Partial<BCRYPT_KEY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_KEY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Magic !== undefined) view.setUint32(0, Number(data.Magic), true);
  // 0x04: pad4
  return buf;
}

export class BCRYPT_KEY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x00: u32
  set Magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_RSAKEY_BLOB (size: 24)
 */
export interface BCRYPT_RSAKEY_BLOB {
  /** Windows.Win32.Security.Cryptography.BCRYPT_RSAKEY_BLOB_MAGIC */
  Magic: BCRYPT_RSAKEY_BLOB_MAGIC;
  /** u32 */
  BitLength: number;
  /** u32 */
  cbPublicExp: number;
  /** u32 */
  cbModulus: number;
  /** u32 */
  cbPrime1: number;
  /** u32 */
  cbPrime2: number;
}

export const sizeofBCRYPT_RSAKEY_BLOB = 24;

export function allocBCRYPT_RSAKEY_BLOB(data?: Partial<BCRYPT_RSAKEY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_RSAKEY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Magic !== undefined) view.setUint32(0, Number(data.Magic), true);
  // 0x04: u32
  if (data?.BitLength !== undefined) view.setUint32(4, Number(data.BitLength), true);
  // 0x08: u32
  if (data?.cbPublicExp !== undefined) view.setUint32(8, Number(data.cbPublicExp), true);
  // 0x0c: u32
  if (data?.cbModulus !== undefined) view.setUint32(12, Number(data.cbModulus), true);
  // 0x10: u32
  if (data?.cbPrime1 !== undefined) view.setUint32(16, Number(data.cbPrime1), true);
  // 0x14: u32
  if (data?.cbPrime2 !== undefined) view.setUint32(20, Number(data.cbPrime2), true);
  return buf;
}

export class BCRYPT_RSAKEY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get BitLength(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbPublicExp(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbModulus(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cbPrime1(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get cbPrime2(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: u32
  set Magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set BitLength(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbPublicExp(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbModulus(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cbPrime1(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set cbPrime2(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_ECCKEY_BLOB (size: 8)
 */
export interface BCRYPT_ECCKEY_BLOB {
  /** u32 */
  dwMagic: number;
  /** u32 */
  cbKey: number;
}

export const sizeofBCRYPT_ECCKEY_BLOB = 8;

export function allocBCRYPT_ECCKEY_BLOB(data?: Partial<BCRYPT_ECCKEY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_ECCKEY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMagic !== undefined) view.setUint32(0, Number(data.dwMagic), true);
  // 0x04: u32
  if (data?.cbKey !== undefined) view.setUint32(4, Number(data.cbKey), true);
  return buf;
}

export class BCRYPT_ECCKEY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMagic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbKey(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwMagic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbKey(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.SSL_ECCKEY_BLOB (size: 8)
 */
export interface SSL_ECCKEY_BLOB {
  /** u32 */
  dwCurveType: number;
  /** u32 */
  cbKey: number;
}

export const sizeofSSL_ECCKEY_BLOB = 8;

export function allocSSL_ECCKEY_BLOB(data?: Partial<SSL_ECCKEY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofSSL_ECCKEY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwCurveType !== undefined) view.setUint32(0, Number(data.dwCurveType), true);
  // 0x04: u32
  if (data?.cbKey !== undefined) view.setUint32(4, Number(data.cbKey), true);
  return buf;
}

export class SSL_ECCKEY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwCurveType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbKey(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwCurveType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbKey(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_ECCFULLKEY_BLOB (size: 32)
 */
export interface BCRYPT_ECCFULLKEY_BLOB {
  /** u32 */
  dwMagic: number;
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.ECC_CURVE_TYPE_ENUM */
  dwCurveType: ECC_CURVE_TYPE_ENUM;
  /** Windows.Win32.Security.Cryptography.ECC_CURVE_ALG_ID_ENUM */
  dwCurveGenerationAlgId: ECC_CURVE_ALG_ID_ENUM;
  /** u32 */
  cbFieldLength: number;
  /** u32 */
  cbSubgroupOrder: number;
  /** u32 */
  cbCofactor: number;
  /** u32 */
  cbSeed: number;
}

export const sizeofBCRYPT_ECCFULLKEY_BLOB = 32;

export function allocBCRYPT_ECCFULLKEY_BLOB(data?: Partial<BCRYPT_ECCFULLKEY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_ECCFULLKEY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMagic !== undefined) view.setUint32(0, Number(data.dwMagic), true);
  // 0x04: u32
  if (data?.dwVersion !== undefined) view.setUint32(4, Number(data.dwVersion), true);
  // 0x08: i32
  if (data?.dwCurveType !== undefined) view.setInt32(8, Number(data.dwCurveType), true);
  // 0x0c: i32
  if (data?.dwCurveGenerationAlgId !== undefined) view.setInt32(12, Number(data.dwCurveGenerationAlgId), true);
  // 0x10: u32
  if (data?.cbFieldLength !== undefined) view.setUint32(16, Number(data.cbFieldLength), true);
  // 0x14: u32
  if (data?.cbSubgroupOrder !== undefined) view.setUint32(20, Number(data.cbSubgroupOrder), true);
  // 0x18: u32
  if (data?.cbCofactor !== undefined) view.setUint32(24, Number(data.cbCofactor), true);
  // 0x1c: u32
  if (data?.cbSeed !== undefined) view.setUint32(28, Number(data.cbSeed), true);
  return buf;
}

export class BCRYPT_ECCFULLKEY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMagic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwVersion(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get dwCurveType(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: i32
  get dwCurveGenerationAlgId(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: u32
  get cbFieldLength(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get cbSubgroupOrder(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: u32
  get cbCofactor(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get cbSeed(): number {
    return this.view.getUint32(28, true);
  }

  // 0x00: u32
  set dwMagic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwVersion(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set dwCurveType(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: i32
  set dwCurveGenerationAlgId(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: u32
  set cbFieldLength(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set cbSubgroupOrder(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: u32
  set cbCofactor(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set cbSeed(value: number) {
    this.view.setUint32(28, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_DH_KEY_BLOB (size: 8)
 */
export interface BCRYPT_DH_KEY_BLOB {
  /** Windows.Win32.Security.Cryptography.BCRYPT_DH_KEY_BLOB_MAGIC */
  dwMagic: BCRYPT_DH_KEY_BLOB_MAGIC;
  /** u32 */
  cbKey: number;
}

export const sizeofBCRYPT_DH_KEY_BLOB = 8;

export function allocBCRYPT_DH_KEY_BLOB(data?: Partial<BCRYPT_DH_KEY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_DH_KEY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMagic !== undefined) view.setUint32(0, Number(data.dwMagic), true);
  // 0x04: u32
  if (data?.cbKey !== undefined) view.setUint32(4, Number(data.cbKey), true);
  return buf;
}

export class BCRYPT_DH_KEY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMagic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbKey(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwMagic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbKey(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_DH_PARAMETER_HEADER (size: 16)
 */
export interface BCRYPT_DH_PARAMETER_HEADER {
  /** u32 */
  cbLength: number;
  /** u32 */
  dwMagic: number;
  /** u32 */
  cbKeyLength: number;
}

export const sizeofBCRYPT_DH_PARAMETER_HEADER = 16;

export function allocBCRYPT_DH_PARAMETER_HEADER(data?: Partial<BCRYPT_DH_PARAMETER_HEADER>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_DH_PARAMETER_HEADER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbLength !== undefined) view.setUint32(0, Number(data.cbLength), true);
  // 0x04: u32
  if (data?.dwMagic !== undefined) view.setUint32(4, Number(data.dwMagic), true);
  // 0x08: u32
  if (data?.cbKeyLength !== undefined) view.setUint32(8, Number(data.cbKeyLength), true);
  // 0x0c: pad4
  return buf;
}

export class BCRYPT_DH_PARAMETER_HEADERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbLength(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMagic(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbKeyLength(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set cbLength(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMagic(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbKeyLength(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_DSA_KEY_BLOB (size: 32)
 */
export interface BCRYPT_DSA_KEY_BLOB {
  /** Windows.Win32.Security.Cryptography.BCRYPT_DSA_MAGIC */
  dwMagic: BCRYPT_DSA_MAGIC;
  /** u32 */
  cbKey: number;
  /** array */
  Count: Deno.PointerValue;
  /** array */
  Seed: Deno.PointerValue;
  /** array */
  q: Deno.PointerValue;
}

export const sizeofBCRYPT_DSA_KEY_BLOB = 32;

export function allocBCRYPT_DSA_KEY_BLOB(data?: Partial<BCRYPT_DSA_KEY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_DSA_KEY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMagic !== undefined) view.setUint32(0, Number(data.dwMagic), true);
  // 0x04: u32
  if (data?.cbKey !== undefined) view.setUint32(4, Number(data.cbKey), true);
  // 0x08: pointer
  if (data?.Count !== undefined) view.setBigUint64(8, data.Count === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Count))), true);
  // 0x10: pointer
  if (data?.Seed !== undefined) view.setBigUint64(16, data.Seed === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Seed))), true);
  // 0x18: pointer
  if (data?.q !== undefined) view.setBigUint64(24, data.q === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.q))), true);
  return buf;
}

export class BCRYPT_DSA_KEY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMagic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbKey(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get Count(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Seed(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get q(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwMagic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbKey(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set Count(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Seed(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set q(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_DSA_KEY_BLOB_V2 (size: 32)
 */
export interface BCRYPT_DSA_KEY_BLOB_V2 {
  /** Windows.Win32.Security.Cryptography.BCRYPT_DSA_MAGIC */
  dwMagic: BCRYPT_DSA_MAGIC;
  /** u32 */
  cbKey: number;
  /** Windows.Win32.Security.Cryptography.HASHALGORITHM_ENUM */
  hashAlgorithm: HASHALGORITHM_ENUM;
  /** Windows.Win32.Security.Cryptography.DSAFIPSVERSION_ENUM */
  standardVersion: DSAFIPSVERSION_ENUM;
  /** u32 */
  cbSeedLength: number;
  /** u32 */
  cbGroupSize: number;
  /** array */
  Count: Deno.PointerValue;
}

export const sizeofBCRYPT_DSA_KEY_BLOB_V2 = 32;

export function allocBCRYPT_DSA_KEY_BLOB_V2(data?: Partial<BCRYPT_DSA_KEY_BLOB_V2>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_DSA_KEY_BLOB_V2);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMagic !== undefined) view.setUint32(0, Number(data.dwMagic), true);
  // 0x04: u32
  if (data?.cbKey !== undefined) view.setUint32(4, Number(data.cbKey), true);
  // 0x08: i32
  if (data?.hashAlgorithm !== undefined) view.setInt32(8, Number(data.hashAlgorithm), true);
  // 0x0c: i32
  if (data?.standardVersion !== undefined) view.setInt32(12, Number(data.standardVersion), true);
  // 0x10: u32
  if (data?.cbSeedLength !== undefined) view.setUint32(16, Number(data.cbSeedLength), true);
  // 0x14: u32
  if (data?.cbGroupSize !== undefined) view.setUint32(20, Number(data.cbGroupSize), true);
  // 0x18: pointer
  if (data?.Count !== undefined) view.setBigUint64(24, data.Count === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Count))), true);
  return buf;
}

export class BCRYPT_DSA_KEY_BLOB_V2View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMagic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbKey(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get hashAlgorithm(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: i32
  get standardVersion(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: u32
  get cbSeedLength(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get cbGroupSize(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get Count(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwMagic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbKey(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set hashAlgorithm(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: i32
  set standardVersion(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: u32
  set cbSeedLength(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set cbGroupSize(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set Count(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_KEY_DATA_BLOB_HEADER (size: 16)
 */
export interface BCRYPT_KEY_DATA_BLOB_HEADER {
  /** u32 */
  dwMagic: number;
  /** u32 */
  dwVersion: number;
  /** u32 */
  cbKeyData: number;
}

export const sizeofBCRYPT_KEY_DATA_BLOB_HEADER = 16;

export function allocBCRYPT_KEY_DATA_BLOB_HEADER(data?: Partial<BCRYPT_KEY_DATA_BLOB_HEADER>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_KEY_DATA_BLOB_HEADER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMagic !== undefined) view.setUint32(0, Number(data.dwMagic), true);
  // 0x04: u32
  if (data?.dwVersion !== undefined) view.setUint32(4, Number(data.dwVersion), true);
  // 0x08: u32
  if (data?.cbKeyData !== undefined) view.setUint32(8, Number(data.cbKeyData), true);
  // 0x0c: pad4
  return buf;
}

export class BCRYPT_KEY_DATA_BLOB_HEADERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMagic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwVersion(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbKeyData(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set dwMagic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwVersion(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbKeyData(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_DSA_PARAMETER_HEADER (size: 40)
 */
export interface BCRYPT_DSA_PARAMETER_HEADER {
  /** u32 */
  cbLength: number;
  /** u32 */
  dwMagic: number;
  /** u32 */
  cbKeyLength: number;
  /** array */
  Count: Deno.PointerValue;
  /** array */
  Seed: Deno.PointerValue;
  /** array */
  q: Deno.PointerValue;
}

export const sizeofBCRYPT_DSA_PARAMETER_HEADER = 40;

export function allocBCRYPT_DSA_PARAMETER_HEADER(data?: Partial<BCRYPT_DSA_PARAMETER_HEADER>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_DSA_PARAMETER_HEADER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbLength !== undefined) view.setUint32(0, Number(data.cbLength), true);
  // 0x04: u32
  if (data?.dwMagic !== undefined) view.setUint32(4, Number(data.dwMagic), true);
  // 0x08: u32
  if (data?.cbKeyLength !== undefined) view.setUint32(8, Number(data.cbKeyLength), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Count !== undefined) view.setBigUint64(16, data.Count === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Count))), true);
  // 0x18: pointer
  if (data?.Seed !== undefined) view.setBigUint64(24, data.Seed === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Seed))), true);
  // 0x20: pointer
  if (data?.q !== undefined) view.setBigUint64(32, data.q === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.q))), true);
  return buf;
}

export class BCRYPT_DSA_PARAMETER_HEADERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbLength(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMagic(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbKeyLength(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Count(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get Seed(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get q(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbLength(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMagic(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbKeyLength(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Count(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set Seed(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set q(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_DSA_PARAMETER_HEADER_V2 (size: 40)
 */
export interface BCRYPT_DSA_PARAMETER_HEADER_V2 {
  /** u32 */
  cbLength: number;
  /** u32 */
  dwMagic: number;
  /** u32 */
  cbKeyLength: number;
  /** Windows.Win32.Security.Cryptography.HASHALGORITHM_ENUM */
  hashAlgorithm: HASHALGORITHM_ENUM;
  /** Windows.Win32.Security.Cryptography.DSAFIPSVERSION_ENUM */
  standardVersion: DSAFIPSVERSION_ENUM;
  /** u32 */
  cbSeedLength: number;
  /** u32 */
  cbGroupSize: number;
  /** array */
  Count: Deno.PointerValue;
}

export const sizeofBCRYPT_DSA_PARAMETER_HEADER_V2 = 40;

export function allocBCRYPT_DSA_PARAMETER_HEADER_V2(data?: Partial<BCRYPT_DSA_PARAMETER_HEADER_V2>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_DSA_PARAMETER_HEADER_V2);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbLength !== undefined) view.setUint32(0, Number(data.cbLength), true);
  // 0x04: u32
  if (data?.dwMagic !== undefined) view.setUint32(4, Number(data.dwMagic), true);
  // 0x08: u32
  if (data?.cbKeyLength !== undefined) view.setUint32(8, Number(data.cbKeyLength), true);
  // 0x0c: i32
  if (data?.hashAlgorithm !== undefined) view.setInt32(12, Number(data.hashAlgorithm), true);
  // 0x10: i32
  if (data?.standardVersion !== undefined) view.setInt32(16, Number(data.standardVersion), true);
  // 0x14: u32
  if (data?.cbSeedLength !== undefined) view.setUint32(20, Number(data.cbSeedLength), true);
  // 0x18: u32
  if (data?.cbGroupSize !== undefined) view.setUint32(24, Number(data.cbGroupSize), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Count !== undefined) view.setBigUint64(32, data.Count === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Count))), true);
  return buf;
}

export class BCRYPT_DSA_PARAMETER_HEADER_V2View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbLength(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMagic(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbKeyLength(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: i32
  get hashAlgorithm(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: i32
  get standardVersion(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: u32
  get cbSeedLength(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: u32
  get cbGroupSize(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Count(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbLength(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMagic(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbKeyLength(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: i32
  set hashAlgorithm(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: i32
  set standardVersion(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: u32
  set cbSeedLength(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: u32
  set cbGroupSize(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Count(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_ECC_CURVE_NAMES (size: 16)
 */
export interface BCRYPT_ECC_CURVE_NAMES {
  /** u32 */
  dwEccCurveNames: number;
  /** ptr */
  pEccCurveNames: Deno.PointerValue | Uint8Array;
}

export const sizeofBCRYPT_ECC_CURVE_NAMES = 16;

export function allocBCRYPT_ECC_CURVE_NAMES(data?: Partial<BCRYPT_ECC_CURVE_NAMES>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_ECC_CURVE_NAMES);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwEccCurveNames !== undefined) view.setUint32(0, Number(data.dwEccCurveNames), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pEccCurveNames !== undefined) view.setBigUint64(8, data.pEccCurveNames === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pEccCurveNames))), true);
  return buf;
}

export class BCRYPT_ECC_CURVE_NAMESView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwEccCurveNames(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pEccCurveNames(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwEccCurveNames(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pEccCurveNames(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_MULTI_HASH_OPERATION (size: 24)
 */
export interface BCRYPT_MULTI_HASH_OPERATION {
  /** u32 */
  iHash: number;
  /** Windows.Win32.Security.Cryptography.BCRYPT_HASH_OPERATION_TYPE */
  hashOperation: BCRYPT_HASH_OPERATION_TYPE;
  /** ptr */
  pbBuffer: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbBuffer: number;
}

export const sizeofBCRYPT_MULTI_HASH_OPERATION = 24;

export function allocBCRYPT_MULTI_HASH_OPERATION(data?: Partial<BCRYPT_MULTI_HASH_OPERATION>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_MULTI_HASH_OPERATION);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.iHash !== undefined) view.setUint32(0, Number(data.iHash), true);
  // 0x04: i32
  if (data?.hashOperation !== undefined) view.setInt32(4, Number(data.hashOperation), true);
  // 0x08: pointer
  if (data?.pbBuffer !== undefined) view.setBigUint64(8, data.pbBuffer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbBuffer))), true);
  // 0x10: u32
  if (data?.cbBuffer !== undefined) view.setUint32(16, Number(data.cbBuffer), true);
  // 0x14: pad4
  return buf;
}

export class BCRYPT_MULTI_HASH_OPERATIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get iHash(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get hashOperation(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: pointer
  get pbBuffer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbBuffer(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set iHash(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set hashOperation(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: pointer
  set pbBuffer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbBuffer(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_MULTI_OBJECT_LENGTH_STRUCT (size: 8)
 */
export interface BCRYPT_MULTI_OBJECT_LENGTH_STRUCT {
  /** u32 */
  cbPerObject: number;
  /** u32 */
  cbPerElement: number;
}

export const sizeofBCRYPT_MULTI_OBJECT_LENGTH_STRUCT = 8;

export function allocBCRYPT_MULTI_OBJECT_LENGTH_STRUCT(data?: Partial<BCRYPT_MULTI_OBJECT_LENGTH_STRUCT>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_MULTI_OBJECT_LENGTH_STRUCT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbPerObject !== undefined) view.setUint32(0, Number(data.cbPerObject), true);
  // 0x04: u32
  if (data?.cbPerElement !== undefined) view.setUint32(4, Number(data.cbPerElement), true);
  return buf;
}

export class BCRYPT_MULTI_OBJECT_LENGTH_STRUCTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbPerObject(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbPerElement(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set cbPerObject(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbPerElement(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_ALGORITHM_IDENTIFIER (size: 16)
 */
export interface BCRYPT_ALGORITHM_IDENTIFIER {
  /** Windows.Win32.Foundation.PWSTR */
  pszName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwClass: number;
  /** u32 */
  dwFlags: number;
}

export const sizeofBCRYPT_ALGORITHM_IDENTIFIER = 16;

export function allocBCRYPT_ALGORITHM_IDENTIFIER(data?: Partial<BCRYPT_ALGORITHM_IDENTIFIER>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_ALGORITHM_IDENTIFIER);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.dwClass !== undefined) view.setUint32(8, Number(data.dwClass), true);
  // 0x0c: u32
  if (data?.dwFlags !== undefined) view.setUint32(12, Number(data.dwFlags), true);
  return buf;
}

export class BCRYPT_ALGORITHM_IDENTIFIERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwClass(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwFlags(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: buffer
  set pszName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set dwClass(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwFlags(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_PROVIDER_NAME (size: 8)
 */
export interface BCRYPT_PROVIDER_NAME {
  /** Windows.Win32.Foundation.PWSTR */
  pszProviderName: string | null | Uint8Array | Uint16Array;
}

export const sizeofBCRYPT_PROVIDER_NAME = 8;

export function allocBCRYPT_PROVIDER_NAME(data?: Partial<BCRYPT_PROVIDER_NAME>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_PROVIDER_NAME);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszProviderName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszProviderName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  return buf;
}

export class BCRYPT_PROVIDER_NAMEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszProviderName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszProviderName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE_VERSION (size: 8)
 */
export interface BCRYPT_INTERFACE_VERSION {
  /** u16 */
  MajorVersion: number;
  /** u16 */
  MinorVersion: number;
}

export const sizeofBCRYPT_INTERFACE_VERSION = 8;

export function allocBCRYPT_INTERFACE_VERSION(data?: Partial<BCRYPT_INTERFACE_VERSION>): Uint8Array {
  const buf = new Uint8Array(sizeofBCRYPT_INTERFACE_VERSION);
  const view = new DataView(buf.buffer);
  // 0x00: u16
  if (data?.MajorVersion !== undefined) view.setUint16(0, Number(data.MajorVersion), true);
  // 0x02: u16
  if (data?.MinorVersion !== undefined) view.setUint16(2, Number(data.MinorVersion), true);
  // 0x04: pad4
  return buf;
}

export class BCRYPT_INTERFACE_VERSIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u16
  get MajorVersion(): number {
    return this.view.getUint16(0, true);
  }

  // 0x02: u16
  get MinorVersion(): number {
    return this.view.getUint16(2, true);
  }

  // 0x04: pad4

  // 0x00: u16
  set MajorVersion(value: number) {
    this.view.setUint16(0, value, true);
  }

  // 0x02: u16
  set MinorVersion(value: number) {
    this.view.setUint16(2, value, true);
  }

  // 0x04: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_INTERFACE_REG (size: 24)
 */
export interface CRYPT_INTERFACE_REG {
  /** Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */
  dwInterface: BCRYPT_INTERFACE;
  /** Windows.Win32.Security.Cryptography.BCRYPT_TABLE */
  dwFlags: BCRYPT_TABLE;
  /** u32 */
  cFunctions: number;
  /** ptr */
  rgpszFunctions: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_INTERFACE_REG = 24;

export function allocCRYPT_INTERFACE_REG(data?: Partial<CRYPT_INTERFACE_REG>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_INTERFACE_REG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwInterface !== undefined) view.setUint32(0, Number(data.dwInterface), true);
  // 0x04: u32
  if (data?.dwFlags !== undefined) view.setUint32(4, Number(data.dwFlags), true);
  // 0x08: u32
  if (data?.cFunctions !== undefined) view.setUint32(8, Number(data.cFunctions), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgpszFunctions !== undefined) view.setBigUint64(16, data.rgpszFunctions === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszFunctions))), true);
  return buf;
}

export class CRYPT_INTERFACE_REGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwInterface(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cFunctions(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgpszFunctions(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwInterface(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cFunctions(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgpszFunctions(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_IMAGE_REG (size: 24)
 */
export interface CRYPT_IMAGE_REG {
  /** Windows.Win32.Foundation.PWSTR */
  pszImage: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cInterfaces: number;
  /** ptr */
  rgpInterfaces: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_IMAGE_REG = 24;

export function allocCRYPT_IMAGE_REG(data?: Partial<CRYPT_IMAGE_REG>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_IMAGE_REG);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszImage !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszImage);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cInterfaces !== undefined) view.setUint32(8, Number(data.cInterfaces), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgpInterfaces !== undefined) view.setBigUint64(16, data.rgpInterfaces === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpInterfaces))), true);
  return buf;
}

export class CRYPT_IMAGE_REGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszImage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cInterfaces(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgpInterfaces(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszImage(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cInterfaces(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgpInterfaces(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PROVIDER_REG (size: 32)
 */
export interface CRYPT_PROVIDER_REG {
  /** u32 */
  cAliases: number;
  /** ptr */
  rgpszAliases: Deno.PointerValue | Uint8Array;
  /** ptr */
  pUM: Deno.PointerValue | Uint8Array;
  /** ptr */
  pKM: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PROVIDER_REG = 32;

export function allocCRYPT_PROVIDER_REG(data?: Partial<CRYPT_PROVIDER_REG>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PROVIDER_REG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cAliases !== undefined) view.setUint32(0, Number(data.cAliases), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszAliases !== undefined) view.setBigUint64(8, data.rgpszAliases === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszAliases))), true);
  // 0x10: pointer
  if (data?.pUM !== undefined) view.setBigUint64(16, data.pUM === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pUM))), true);
  // 0x18: pointer
  if (data?.pKM !== undefined) view.setBigUint64(24, data.pKM === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pKM))), true);
  return buf;
}

export class CRYPT_PROVIDER_REGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cAliases(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszAliases(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pUM(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pKM(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cAliases(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszAliases(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pUM(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pKM(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PROVIDERS (size: 16)
 */
export interface CRYPT_PROVIDERS {
  /** u32 */
  cProviders: number;
  /** ptr */
  rgpszProviders: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PROVIDERS = 16;

export function allocCRYPT_PROVIDERS(data?: Partial<CRYPT_PROVIDERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PROVIDERS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cProviders !== undefined) view.setUint32(0, Number(data.cProviders), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszProviders !== undefined) view.setBigUint64(8, data.rgpszProviders === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszProviders))), true);
  return buf;
}

export class CRYPT_PROVIDERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cProviders(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszProviders(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cProviders(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszProviders(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CONTEXT_CONFIG (size: 8)
 */
export interface CRYPT_CONTEXT_CONFIG {
  /** Windows.Win32.Security.Cryptography.CRYPT_CONTEXT_CONFIG_FLAGS */
  dwFlags: CRYPT_CONTEXT_CONFIG_FLAGS;
  /** u32 */
  dwReserved: number;
}

export const sizeofCRYPT_CONTEXT_CONFIG = 8;

export function allocCRYPT_CONTEXT_CONFIG(data?: Partial<CRYPT_CONTEXT_CONFIG>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CONTEXT_CONFIG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwFlags !== undefined) view.setUint32(0, Number(data.dwFlags), true);
  // 0x04: u32
  if (data?.dwReserved !== undefined) view.setUint32(4, Number(data.dwReserved), true);
  return buf;
}

export class CRYPT_CONTEXT_CONFIGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwFlags(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwReserved(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwFlags(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwReserved(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CONTEXT_FUNCTION_CONFIG (size: 8)
 */
export interface CRYPT_CONTEXT_FUNCTION_CONFIG {
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwReserved: number;
}

export const sizeofCRYPT_CONTEXT_FUNCTION_CONFIG = 8;

export function allocCRYPT_CONTEXT_FUNCTION_CONFIG(data?: Partial<CRYPT_CONTEXT_FUNCTION_CONFIG>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CONTEXT_FUNCTION_CONFIG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwFlags !== undefined) view.setUint32(0, Number(data.dwFlags), true);
  // 0x04: u32
  if (data?.dwReserved !== undefined) view.setUint32(4, Number(data.dwReserved), true);
  return buf;
}

export class CRYPT_CONTEXT_FUNCTION_CONFIGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwFlags(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwReserved(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwFlags(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwReserved(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CONTEXTS (size: 16)
 */
export interface CRYPT_CONTEXTS {
  /** u32 */
  cContexts: number;
  /** ptr */
  rgpszContexts: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_CONTEXTS = 16;

export function allocCRYPT_CONTEXTS(data?: Partial<CRYPT_CONTEXTS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CONTEXTS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cContexts !== undefined) view.setUint32(0, Number(data.cContexts), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszContexts !== undefined) view.setBigUint64(8, data.rgpszContexts === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszContexts))), true);
  return buf;
}

export class CRYPT_CONTEXTSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cContexts(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszContexts(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cContexts(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszContexts(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CONTEXT_FUNCTIONS (size: 16)
 */
export interface CRYPT_CONTEXT_FUNCTIONS {
  /** u32 */
  cFunctions: number;
  /** ptr */
  rgpszFunctions: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_CONTEXT_FUNCTIONS = 16;

export function allocCRYPT_CONTEXT_FUNCTIONS(data?: Partial<CRYPT_CONTEXT_FUNCTIONS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CONTEXT_FUNCTIONS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cFunctions !== undefined) view.setUint32(0, Number(data.cFunctions), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszFunctions !== undefined) view.setBigUint64(8, data.rgpszFunctions === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszFunctions))), true);
  return buf;
}

export class CRYPT_CONTEXT_FUNCTIONSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cFunctions(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszFunctions(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cFunctions(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszFunctions(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CONTEXT_FUNCTION_PROVIDERS (size: 16)
 */
export interface CRYPT_CONTEXT_FUNCTION_PROVIDERS {
  /** u32 */
  cProviders: number;
  /** ptr */
  rgpszProviders: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_CONTEXT_FUNCTION_PROVIDERS = 16;

export function allocCRYPT_CONTEXT_FUNCTION_PROVIDERS(data?: Partial<CRYPT_CONTEXT_FUNCTION_PROVIDERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CONTEXT_FUNCTION_PROVIDERS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cProviders !== undefined) view.setUint32(0, Number(data.cProviders), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszProviders !== undefined) view.setBigUint64(8, data.rgpszProviders === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszProviders))), true);
  return buf;
}

export class CRYPT_CONTEXT_FUNCTION_PROVIDERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cProviders(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszProviders(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cProviders(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszProviders(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PROPERTY_REF (size: 24)
 */
export interface CRYPT_PROPERTY_REF {
  /** Windows.Win32.Foundation.PWSTR */
  pszProperty: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cbValue: number;
  /** ptr */
  pbValue: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PROPERTY_REF = 24;

export function allocCRYPT_PROPERTY_REF(data?: Partial<CRYPT_PROPERTY_REF>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PROPERTY_REF);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszProperty !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszProperty);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cbValue !== undefined) view.setUint32(8, Number(data.cbValue), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.pbValue !== undefined) view.setBigUint64(16, data.pbValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbValue))), true);
  return buf;
}

export class CRYPT_PROPERTY_REFView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszProperty(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cbValue(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get pbValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszProperty(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cbValue(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set pbValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_IMAGE_REF (size: 16)
 */
export interface CRYPT_IMAGE_REF {
  /** Windows.Win32.Foundation.PWSTR */
  pszImage: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_IMAGE_REF_FLAGS */
  dwFlags: CRYPT_IMAGE_REF_FLAGS;
}

export const sizeofCRYPT_IMAGE_REF = 16;

export function allocCRYPT_IMAGE_REF(data?: Partial<CRYPT_IMAGE_REF>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_IMAGE_REF);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszImage !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszImage);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.dwFlags !== undefined) view.setUint32(8, Number(data.dwFlags), true);
  // 0x0c: pad4
  return buf;
}

export class CRYPT_IMAGE_REFView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszImage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwFlags(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: buffer
  set pszImage(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set dwFlags(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PROVIDER_REF (size: 56)
 */
export interface CRYPT_PROVIDER_REF {
  /** u32 */
  dwInterface: number;
  /** Windows.Win32.Foundation.PWSTR */
  pszFunction: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pszProvider: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cProperties: number;
  /** ptr */
  rgpProperties: Deno.PointerValue | Uint8Array;
  /** ptr */
  pUM: Deno.PointerValue | Uint8Array;
  /** ptr */
  pKM: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PROVIDER_REF = 56;

export function allocCRYPT_PROVIDER_REF(data?: Partial<CRYPT_PROVIDER_REF>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PROVIDER_REF);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwInterface !== undefined) view.setUint32(0, Number(data.dwInterface), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszFunction !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pszFunction);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pszProvider !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pszProvider);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: u32
  if (data?.cProperties !== undefined) view.setUint32(24, Number(data.cProperties), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgpProperties !== undefined) view.setBigUint64(32, data.rgpProperties === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpProperties))), true);
  // 0x28: pointer
  if (data?.pUM !== undefined) view.setBigUint64(40, data.pUM === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pUM))), true);
  // 0x30: pointer
  if (data?.pKM !== undefined) view.setBigUint64(48, data.pKM === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pKM))), true);
  return buf;
}

export class CRYPT_PROVIDER_REFView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwInterface(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszFunction(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pszProvider(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cProperties(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgpProperties(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pUM(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get pKM(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwInterface(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszFunction(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pszProvider(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: u32
  set cProperties(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgpProperties(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pUM(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set pKM(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PROVIDER_REFS (size: 16)
 */
export interface CRYPT_PROVIDER_REFS {
  /** u32 */
  cProviders: number;
  /** ptr */
  rgpProviders: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PROVIDER_REFS = 16;

export function allocCRYPT_PROVIDER_REFS(data?: Partial<CRYPT_PROVIDER_REFS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PROVIDER_REFS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cProviders !== undefined) view.setUint32(0, Number(data.cProviders), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpProviders !== undefined) view.setBigUint64(8, data.rgpProviders === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpProviders))), true);
  return buf;
}

export class CRYPT_PROVIDER_REFSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cProviders(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpProviders(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cProviders(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpProviders(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_ALLOC_PARA (size: 24)
 */
export interface NCRYPT_ALLOC_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.PFN_NCRYPT_ALLOC */
  pfnAlloc: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_NCRYPT_FREE */
  pfnFree: Uint8Array | Deno.PointerValue;
}

export const sizeofNCRYPT_ALLOC_PARA = 24;

export function allocNCRYPT_ALLOC_PARA(data?: Partial<NCRYPT_ALLOC_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_ALLOC_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pfnAlloc !== undefined) view.setBigUint64(8, data.pfnAlloc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnAlloc))), true);
  // 0x10: pointer
  if (data?.pfnFree !== undefined) view.setBigUint64(16, data.pfnFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFree))), true);
  return buf;
}

export class NCRYPT_ALLOC_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pfnAlloc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pfnFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pfnAlloc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pfnFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_CIPHER_PADDING_INFO (size: 40)
 */
export interface NCRYPT_CIPHER_PADDING_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwFlags: number;
  /** ptr */
  pbIV: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbIV: number;
  /** ptr */
  pbOtherInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbOtherInfo: number;
}

export const sizeofNCRYPT_CIPHER_PADDING_INFO = 40;

export function allocNCRYPT_CIPHER_PADDING_INFO(data?: Partial<NCRYPT_CIPHER_PADDING_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_CIPHER_PADDING_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwFlags !== undefined) view.setUint32(4, Number(data.dwFlags), true);
  // 0x08: pointer
  if (data?.pbIV !== undefined) view.setBigUint64(8, data.pbIV === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbIV))), true);
  // 0x10: u32
  if (data?.cbIV !== undefined) view.setUint32(16, Number(data.cbIV), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pbOtherInfo !== undefined) view.setBigUint64(24, data.pbOtherInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbOtherInfo))), true);
  // 0x20: u32
  if (data?.cbOtherInfo !== undefined) view.setUint32(32, Number(data.cbOtherInfo), true);
  // 0x24: pad4
  return buf;
}

export class NCRYPT_CIPHER_PADDING_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pbIV(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbIV(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pbOtherInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cbOtherInfo(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pbIV(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbIV(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pbOtherInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cbOtherInfo(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_PLATFORM_ATTEST_PADDING_INFO (size: 8)
 */
export interface NCRYPT_PLATFORM_ATTEST_PADDING_INFO {
  /** u32 */
  magic: number;
  /** u32 */
  pcrMask: number;
}

export const sizeofNCRYPT_PLATFORM_ATTEST_PADDING_INFO = 8;

export function allocNCRYPT_PLATFORM_ATTEST_PADDING_INFO(data?: Partial<NCRYPT_PLATFORM_ATTEST_PADDING_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_PLATFORM_ATTEST_PADDING_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.magic !== undefined) view.setUint32(0, Number(data.magic), true);
  // 0x04: u32
  if (data?.pcrMask !== undefined) view.setUint32(4, Number(data.pcrMask), true);
  return buf;
}

export class NCRYPT_PLATFORM_ATTEST_PADDING_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get pcrMask(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set pcrMask(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_KEY_ATTEST_PADDING_INFO (size: 40)
 */
export interface NCRYPT_KEY_ATTEST_PADDING_INFO {
  /** u32 */
  magic: number;
  /** ptr */
  pbKeyBlob: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbKeyBlob: number;
  /** ptr */
  pbKeyAuth: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbKeyAuth: number;
}

export const sizeofNCRYPT_KEY_ATTEST_PADDING_INFO = 40;

export function allocNCRYPT_KEY_ATTEST_PADDING_INFO(data?: Partial<NCRYPT_KEY_ATTEST_PADDING_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_KEY_ATTEST_PADDING_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.magic !== undefined) view.setUint32(0, Number(data.magic), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbKeyBlob !== undefined) view.setBigUint64(8, data.pbKeyBlob === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbKeyBlob))), true);
  // 0x10: u32
  if (data?.cbKeyBlob !== undefined) view.setUint32(16, Number(data.cbKeyBlob), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pbKeyAuth !== undefined) view.setBigUint64(24, data.pbKeyAuth === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbKeyAuth))), true);
  // 0x20: u32
  if (data?.cbKeyAuth !== undefined) view.setUint32(32, Number(data.cbKeyAuth), true);
  // 0x24: pad4
  return buf;
}

export class NCRYPT_KEY_ATTEST_PADDING_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbKeyBlob(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbKeyBlob(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pbKeyAuth(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cbKeyAuth(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: u32
  set magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbKeyBlob(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbKeyBlob(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pbKeyAuth(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cbKeyAuth(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES (size: 16)
 */
export interface NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES {
  /** u32 */
  Version: number;
  /** u32 */
  Flags: number;
  /** u32 */
  cbPublicKeyBlob: number;
}

export const sizeofNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = 16;

export function allocNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES(data?: Partial<NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Version !== undefined) view.setUint32(0, Number(data.Version), true);
  // 0x04: u32
  if (data?.Flags !== undefined) view.setUint32(4, Number(data.Flags), true);
  // 0x08: u32
  if (data?.cbPublicKeyBlob !== undefined) view.setUint32(8, Number(data.cbPublicKeyBlob), true);
  // 0x0c: pad4
  return buf;
}

export class NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTESView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Version(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Flags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbPublicKeyBlob(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set Version(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Flags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbPublicKeyBlob(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_VSM_KEY_ATTESTATION_STATEMENT (size: 24)
 */
export interface NCRYPT_VSM_KEY_ATTESTATION_STATEMENT {
  /** u32 */
  Magic: number;
  /** u32 */
  Version: number;
  /** u32 */
  cbSignature: number;
  /** u32 */
  cbReport: number;
  /** u32 */
  cbAttributes: number;
}

export const sizeofNCRYPT_VSM_KEY_ATTESTATION_STATEMENT = 24;

export function allocNCRYPT_VSM_KEY_ATTESTATION_STATEMENT(data?: Partial<NCRYPT_VSM_KEY_ATTESTATION_STATEMENT>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_VSM_KEY_ATTESTATION_STATEMENT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Magic !== undefined) view.setUint32(0, Number(data.Magic), true);
  // 0x04: u32
  if (data?.Version !== undefined) view.setUint32(4, Number(data.Version), true);
  // 0x08: u32
  if (data?.cbSignature !== undefined) view.setUint32(8, Number(data.cbSignature), true);
  // 0x0c: u32
  if (data?.cbReport !== undefined) view.setUint32(12, Number(data.cbReport), true);
  // 0x10: u32
  if (data?.cbAttributes !== undefined) view.setUint32(16, Number(data.cbAttributes), true);
  // 0x14: pad4
  return buf;
}

export class NCRYPT_VSM_KEY_ATTESTATION_STATEMENTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Version(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbSignature(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbReport(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cbAttributes(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set Magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Version(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbSignature(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbReport(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cbAttributes(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS (size: 32)
 */
export interface NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS {
  /** u32 */
  Version: number;
  /** u64 */
  TrustletId: Deno.PointerValue;
  /** u32 */
  MinSvn: number;
  /** u32 */
  FlagsMask: number;
  /** u32 */
  FlagsExpected: number;
  /** u32 */
  _bitfield: number;
}

export const sizeofNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = 32;

export function allocNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS(data?: Partial<NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Version !== undefined) view.setUint32(0, Number(data.Version), true);
  // 0x04: pad4
  // 0x08: u64
  if (data?.TrustletId !== undefined) view.setBigUint64(8, BigInt(data.TrustletId), true);
  // 0x10: u32
  if (data?.MinSvn !== undefined) view.setUint32(16, Number(data.MinSvn), true);
  // 0x14: u32
  if (data?.FlagsMask !== undefined) view.setUint32(20, Number(data.FlagsMask), true);
  // 0x18: u32
  if (data?.FlagsExpected !== undefined) view.setUint32(24, Number(data.FlagsExpected), true);
  // 0x1c: u32
  if (data?._bitfield !== undefined) view.setUint32(28, Number(data._bitfield), true);
  return buf;
}

export class NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Version(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: u64
  get TrustletId(): Deno.PointerValue {
    return Number(this.view.getBigUint64(8, true));
  }

  // 0x10: u32
  get MinSvn(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get FlagsMask(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: u32
  get FlagsExpected(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get _bitfield(): number {
    return this.view.getUint32(28, true);
  }

  // 0x00: u32
  set Version(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: u64
  set TrustletId(value: Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(value), true);
  }

  // 0x10: u32
  set MinSvn(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set FlagsMask(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: u32
  set FlagsExpected(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set _bitfield(value: number) {
    this.view.setUint32(28, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_EXPORTED_ISOLATED_KEY_HEADER (size: 32)
 */
export interface NCRYPT_EXPORTED_ISOLATED_KEY_HEADER {
  /** u32 */
  Version: number;
  /** u32 */
  KeyUsage: number;
  /** u32 */
  _bitfield: number;
  /** u32 */
  cbAlgName: number;
  /** u32 */
  cbNonce: number;
  /** u32 */
  cbAuthTag: number;
  /** u32 */
  cbWrappingKey: number;
  /** u32 */
  cbIsolatedKey: number;
}

export const sizeofNCRYPT_EXPORTED_ISOLATED_KEY_HEADER = 32;

export function allocNCRYPT_EXPORTED_ISOLATED_KEY_HEADER(data?: Partial<NCRYPT_EXPORTED_ISOLATED_KEY_HEADER>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_EXPORTED_ISOLATED_KEY_HEADER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Version !== undefined) view.setUint32(0, Number(data.Version), true);
  // 0x04: u32
  if (data?.KeyUsage !== undefined) view.setUint32(4, Number(data.KeyUsage), true);
  // 0x08: u32
  if (data?._bitfield !== undefined) view.setUint32(8, Number(data._bitfield), true);
  // 0x0c: u32
  if (data?.cbAlgName !== undefined) view.setUint32(12, Number(data.cbAlgName), true);
  // 0x10: u32
  if (data?.cbNonce !== undefined) view.setUint32(16, Number(data.cbNonce), true);
  // 0x14: u32
  if (data?.cbAuthTag !== undefined) view.setUint32(20, Number(data.cbAuthTag), true);
  // 0x18: u32
  if (data?.cbWrappingKey !== undefined) view.setUint32(24, Number(data.cbWrappingKey), true);
  // 0x1c: u32
  if (data?.cbIsolatedKey !== undefined) view.setUint32(28, Number(data.cbIsolatedKey), true);
  return buf;
}

export class NCRYPT_EXPORTED_ISOLATED_KEY_HEADERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Version(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get KeyUsage(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get _bitfield(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbAlgName(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cbNonce(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get cbAuthTag(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: u32
  get cbWrappingKey(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get cbIsolatedKey(): number {
    return this.view.getUint32(28, true);
  }

  // 0x00: u32
  set Version(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set KeyUsage(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set _bitfield(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbAlgName(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cbNonce(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set cbAuthTag(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: u32
  set cbWrappingKey(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set cbIsolatedKey(value: number) {
    this.view.setUint32(28, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE (size: 8)
 */
export interface NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE {
  /** Windows.Win32.Security.Cryptography.NCRYPT_EXPORTED_ISOLATED_KEY_HEADER */
  Header: Uint8Array | Deno.PointerValue;
}

export const sizeofNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = 8;

export function allocNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE(data?: Partial<NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Header !== undefined) view.setBigUint64(0, data.Header === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Header))), true);
  return buf;
}

export class NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Header(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Header(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT (size: 24)
 */
export interface NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT {
  /** u32 */
  Magic: number;
  /** u32 */
  Version: number;
  /** u32 */
  HeaderSize: number;
  /** u32 */
  cbCertifyInfo: number;
  /** u32 */
  cbSignature: number;
  /** u32 */
  cbTpmPublic: number;
}

export const sizeofNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = 24;

export function allocNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT(data?: Partial<NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Magic !== undefined) view.setUint32(0, Number(data.Magic), true);
  // 0x04: u32
  if (data?.Version !== undefined) view.setUint32(4, Number(data.Version), true);
  // 0x08: u32
  if (data?.HeaderSize !== undefined) view.setUint32(8, Number(data.HeaderSize), true);
  // 0x0c: u32
  if (data?.cbCertifyInfo !== undefined) view.setUint32(12, Number(data.cbCertifyInfo), true);
  // 0x10: u32
  if (data?.cbSignature !== undefined) view.setUint32(16, Number(data.cbSignature), true);
  // 0x14: u32
  if (data?.cbTpmPublic !== undefined) view.setUint32(20, Number(data.cbTpmPublic), true);
  return buf;
}

export class NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Version(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get HeaderSize(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbCertifyInfo(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cbSignature(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get cbTpmPublic(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: u32
  set Magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Version(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set HeaderSize(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbCertifyInfo(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cbSignature(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set cbTpmPublic(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT (size: 24)
 */
export interface NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT {
  /** u32 */
  Magic: number;
  /** u32 */
  Version: number;
  /** u32 */
  pcrAlg: number;
  /** u32 */
  cbSignature: number;
  /** u32 */
  cbQuote: number;
  /** u32 */
  cbPcrs: number;
}

export const sizeofNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = 24;

export function allocNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT(data?: Partial<NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Magic !== undefined) view.setUint32(0, Number(data.Magic), true);
  // 0x04: u32
  if (data?.Version !== undefined) view.setUint32(4, Number(data.Version), true);
  // 0x08: u32
  if (data?.pcrAlg !== undefined) view.setUint32(8, Number(data.pcrAlg), true);
  // 0x0c: u32
  if (data?.cbSignature !== undefined) view.setUint32(12, Number(data.cbSignature), true);
  // 0x10: u32
  if (data?.cbQuote !== undefined) view.setUint32(16, Number(data.cbQuote), true);
  // 0x14: u32
  if (data?.cbPcrs !== undefined) view.setUint32(20, Number(data.cbPcrs), true);
  return buf;
}

export class NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Version(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get pcrAlg(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbSignature(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cbQuote(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get cbPcrs(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: u32
  set Magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Version(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set pcrAlg(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbSignature(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cbQuote(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set cbPcrs(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCryptAlgorithmName (size: 24)
 */
export interface NCryptAlgorithmName {
  /** Windows.Win32.Foundation.PWSTR */
  pszName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.NCRYPT_ALGORITHM_NAME_CLASS */
  dwClass: NCRYPT_ALGORITHM_NAME_CLASS;
  /** Windows.Win32.Security.Cryptography.NCRYPT_OPERATION */
  dwAlgOperations: NCRYPT_OPERATION;
  /** u32 */
  dwFlags: number;
}

export const sizeofNCryptAlgorithmName = 24;

export function allocNCryptAlgorithmName(data?: Partial<NCryptAlgorithmName>): Uint8Array {
  const buf = new Uint8Array(sizeofNCryptAlgorithmName);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.dwClass !== undefined) view.setUint32(8, Number(data.dwClass), true);
  // 0x0c: u32
  if (data?.dwAlgOperations !== undefined) view.setUint32(12, Number(data.dwAlgOperations), true);
  // 0x10: u32
  if (data?.dwFlags !== undefined) view.setUint32(16, Number(data.dwFlags), true);
  // 0x14: pad4
  return buf;
}

export class NCryptAlgorithmNameView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwClass(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwAlgOperations(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get dwFlags(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: buffer
  set pszName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set dwClass(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwAlgOperations(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set dwFlags(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.NCryptKeyName (size: 24)
 */
export interface NCryptKeyName {
  /** Windows.Win32.Foundation.PWSTR */
  pszName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pszAlgid: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CERT_KEY_SPEC */
  dwLegacyKeySpec: CERT_KEY_SPEC;
  /** u32 */
  dwFlags: number;
}

export const sizeofNCryptKeyName = 24;

export function allocNCryptKeyName(data?: Partial<NCryptKeyName>): Uint8Array {
  const buf = new Uint8Array(sizeofNCryptKeyName);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pszAlgid !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pszAlgid);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.dwLegacyKeySpec !== undefined) view.setUint32(16, Number(data.dwLegacyKeySpec), true);
  // 0x14: u32
  if (data?.dwFlags !== undefined) view.setUint32(20, Number(data.dwFlags), true);
  return buf;
}

export class NCryptKeyNameView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pszAlgid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwLegacyKeySpec(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwFlags(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: buffer
  set pszName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pszAlgid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set dwLegacyKeySpec(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwFlags(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCryptProviderName (size: 16)
 */
export interface NCryptProviderName {
  /** Windows.Win32.Foundation.PWSTR */
  pszName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pszComment: string | null | Uint8Array | Uint16Array;
}

export const sizeofNCryptProviderName = 16;

export function allocNCryptProviderName(data?: Partial<NCryptProviderName>): Uint8Array {
  const buf = new Uint8Array(sizeofNCryptProviderName);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pszComment !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pszComment);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class NCryptProviderNameView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pszComment(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pszComment(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_UI_POLICY (size: 32)
 */
export interface NCRYPT_UI_POLICY {
  /** u32 */
  dwVersion: number;
  /** u32 */
  dwFlags: number;
  /** Windows.Win32.Foundation.PWSTR */
  pszCreationTitle: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pszFriendlyName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pszDescription: string | null | Uint8Array | Uint16Array;
}

export const sizeofNCRYPT_UI_POLICY = 32;

export function allocNCRYPT_UI_POLICY(data?: Partial<NCRYPT_UI_POLICY>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_UI_POLICY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: u32
  if (data?.dwFlags !== undefined) view.setUint32(4, Number(data.dwFlags), true);
  // 0x08: buffer
  if (data?.pszCreationTitle !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pszCreationTitle);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pszFriendlyName !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pszFriendlyName);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: buffer
  if (data?.pszDescription !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.pszDescription);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  return buf;
}

export class NCRYPT_UI_POLICYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: buffer
  get pszCreationTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pszFriendlyName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get pszDescription(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: buffer
  set pszCreationTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pszFriendlyName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: buffer
  set pszDescription(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_KEY_ACCESS_POLICY_BLOB (size: 16)
 */
export interface NCRYPT_KEY_ACCESS_POLICY_BLOB {
  /** u32 */
  dwVersion: number;
  /** u32 */
  dwPolicyFlags: number;
  /** u32 */
  cbUserSid: number;
  /** u32 */
  cbApplicationSid: number;
}

export const sizeofNCRYPT_KEY_ACCESS_POLICY_BLOB = 16;

export function allocNCRYPT_KEY_ACCESS_POLICY_BLOB(data?: Partial<NCRYPT_KEY_ACCESS_POLICY_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_KEY_ACCESS_POLICY_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: u32
  if (data?.dwPolicyFlags !== undefined) view.setUint32(4, Number(data.dwPolicyFlags), true);
  // 0x08: u32
  if (data?.cbUserSid !== undefined) view.setUint32(8, Number(data.cbUserSid), true);
  // 0x0c: u32
  if (data?.cbApplicationSid !== undefined) view.setUint32(12, Number(data.cbApplicationSid), true);
  return buf;
}

export class NCRYPT_KEY_ACCESS_POLICY_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwPolicyFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbUserSid(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbApplicationSid(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwPolicyFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbUserSid(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbApplicationSid(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_SUPPORTED_LENGTHS (size: 16)
 */
export interface NCRYPT_SUPPORTED_LENGTHS {
  /** u32 */
  dwMinLength: number;
  /** u32 */
  dwMaxLength: number;
  /** u32 */
  dwIncrement: number;
  /** u32 */
  dwDefaultLength: number;
}

export const sizeofNCRYPT_SUPPORTED_LENGTHS = 16;

export function allocNCRYPT_SUPPORTED_LENGTHS(data?: Partial<NCRYPT_SUPPORTED_LENGTHS>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_SUPPORTED_LENGTHS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMinLength !== undefined) view.setUint32(0, Number(data.dwMinLength), true);
  // 0x04: u32
  if (data?.dwMaxLength !== undefined) view.setUint32(4, Number(data.dwMaxLength), true);
  // 0x08: u32
  if (data?.dwIncrement !== undefined) view.setUint32(8, Number(data.dwIncrement), true);
  // 0x0c: u32
  if (data?.dwDefaultLength !== undefined) view.setUint32(12, Number(data.dwDefaultLength), true);
  return buf;
}

export class NCRYPT_SUPPORTED_LENGTHSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMinLength(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMaxLength(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwIncrement(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwDefaultLength(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: u32
  set dwMinLength(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMaxLength(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwIncrement(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwDefaultLength(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO (size: 32)
 */
export interface NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO {
  /** u32 */
  dwVersion: number;
  /** i32 */
  iExpiration: number;
  /** array */
  pabNonce: Deno.PointerValue;
  /** array */
  pabPolicyRef: Deno.PointerValue;
  /** array */
  pabHMAC: Deno.PointerValue;
}

export const sizeofNCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = 32;

export function allocNCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO(data?: Partial<NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: i32
  if (data?.iExpiration !== undefined) view.setInt32(4, Number(data.iExpiration), true);
  // 0x08: pointer
  if (data?.pabNonce !== undefined) view.setBigUint64(8, data.pabNonce === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pabNonce))), true);
  // 0x10: pointer
  if (data?.pabPolicyRef !== undefined) view.setBigUint64(16, data.pabPolicyRef === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pabPolicyRef))), true);
  // 0x18: pointer
  if (data?.pabHMAC !== undefined) view.setBigUint64(24, data.pabHMAC === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pabHMAC))), true);
  return buf;
}

export class NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get iExpiration(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: pointer
  get pabNonce(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pabPolicyRef(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pabHMAC(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set iExpiration(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: pointer
  set pabNonce(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pabPolicyRef(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pabHMAC(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_PCP_TPM_FW_VERSION_INFO (size: 8)
 */
export interface NCRYPT_PCP_TPM_FW_VERSION_INFO {
  /** u16 */
  major1: number;
  /** u16 */
  major2: number;
  /** u16 */
  minor1: number;
  /** u16 */
  minor2: number;
}

export const sizeofNCRYPT_PCP_TPM_FW_VERSION_INFO = 8;

export function allocNCRYPT_PCP_TPM_FW_VERSION_INFO(data?: Partial<NCRYPT_PCP_TPM_FW_VERSION_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_PCP_TPM_FW_VERSION_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u16
  if (data?.major1 !== undefined) view.setUint16(0, Number(data.major1), true);
  // 0x02: u16
  if (data?.major2 !== undefined) view.setUint16(2, Number(data.major2), true);
  // 0x04: u16
  if (data?.minor1 !== undefined) view.setUint16(4, Number(data.minor1), true);
  // 0x06: u16
  if (data?.minor2 !== undefined) view.setUint16(6, Number(data.minor2), true);
  return buf;
}

export class NCRYPT_PCP_TPM_FW_VERSION_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u16
  get major1(): number {
    return this.view.getUint16(0, true);
  }

  // 0x02: u16
  get major2(): number {
    return this.view.getUint16(2, true);
  }

  // 0x04: u16
  get minor1(): number {
    return this.view.getUint16(4, true);
  }

  // 0x06: u16
  get minor2(): number {
    return this.view.getUint16(6, true);
  }

  // 0x00: u16
  set major1(value: number) {
    this.view.setUint16(0, value, true);
  }

  // 0x02: u16
  set major2(value: number) {
    this.view.setUint16(2, value, true);
  }

  // 0x04: u16
  set minor1(value: number) {
    this.view.setUint16(4, value, true);
  }

  // 0x06: u16
  set minor2(value: number) {
    this.view.setUint16(6, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_PCP_RAW_POLICYDIGEST_INFO (size: 8)
 */
export interface NCRYPT_PCP_RAW_POLICYDIGEST_INFO {
  /** u32 */
  dwVersion: number;
  /** u32 */
  cbDigest: number;
}

export const sizeofNCRYPT_PCP_RAW_POLICYDIGEST_INFO = 8;

export function allocNCRYPT_PCP_RAW_POLICYDIGEST_INFO(data?: Partial<NCRYPT_PCP_RAW_POLICYDIGEST_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_PCP_RAW_POLICYDIGEST_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: u32
  if (data?.cbDigest !== undefined) view.setUint32(4, Number(data.cbDigest), true);
  return buf;
}

export class NCRYPT_PCP_RAW_POLICYDIGEST_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbDigest(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbDigest(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_KEY_BLOB_HEADER (size: 16)
 */
export interface NCRYPT_KEY_BLOB_HEADER {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMagic: number;
  /** u32 */
  cbAlgName: number;
  /** u32 */
  cbKeyData: number;
}

export const sizeofNCRYPT_KEY_BLOB_HEADER = 16;

export function allocNCRYPT_KEY_BLOB_HEADER(data?: Partial<NCRYPT_KEY_BLOB_HEADER>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_KEY_BLOB_HEADER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMagic !== undefined) view.setUint32(4, Number(data.dwMagic), true);
  // 0x08: u32
  if (data?.cbAlgName !== undefined) view.setUint32(8, Number(data.cbAlgName), true);
  // 0x0c: u32
  if (data?.cbKeyData !== undefined) view.setUint32(12, Number(data.cbKeyData), true);
  return buf;
}

export class NCRYPT_KEY_BLOB_HEADERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMagic(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbAlgName(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbKeyData(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMagic(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbAlgName(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbKeyData(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER (size: 24)
 */
export interface NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER {
  /** u32 */
  magic: number;
  /** u32 */
  cbHeader: number;
  /** u32 */
  cbPublic: number;
  /** u32 */
  cbPrivate: number;
  /** u32 */
  cbName: number;
}

export const sizeofNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = 24;

export function allocNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER(data?: Partial<NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.magic !== undefined) view.setUint32(0, Number(data.magic), true);
  // 0x04: u32
  if (data?.cbHeader !== undefined) view.setUint32(4, Number(data.cbHeader), true);
  // 0x08: u32
  if (data?.cbPublic !== undefined) view.setUint32(8, Number(data.cbPublic), true);
  // 0x0c: u32
  if (data?.cbPrivate !== undefined) view.setUint32(12, Number(data.cbPrivate), true);
  // 0x10: u32
  if (data?.cbName !== undefined) view.setUint32(16, Number(data.cbName), true);
  // 0x14: pad4
  return buf;
}

export class NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get magic(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbHeader(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cbPublic(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get cbPrivate(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cbName(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set magic(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbHeader(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cbPublic(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set cbPrivate(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cbName(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB (size: 24)
 */
export interface CRYPT_BIT_BLOB {
  /** u32 */
  cbData: number;
  /** ptr */
  pbData: Deno.PointerValue | Uint8Array;
  /** u32 */
  cUnusedBits: number;
}

export const sizeofCRYPT_BIT_BLOB = 24;

export function allocCRYPT_BIT_BLOB(data?: Partial<CRYPT_BIT_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_BIT_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbData !== undefined) view.setUint32(0, Number(data.cbData), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbData !== undefined) view.setBigUint64(8, data.pbData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbData))), true);
  // 0x10: u32
  if (data?.cUnusedBits !== undefined) view.setUint32(16, Number(data.cUnusedBits), true);
  // 0x14: pad4
  return buf;
}

export class CRYPT_BIT_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbData(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cUnusedBits(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set cbData(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cUnusedBits(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER (size: 16)
 */
export interface CRYPT_ALGORITHM_IDENTIFIER {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Parameters: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_ALGORITHM_IDENTIFIER = 16;

export function allocCRYPT_ALGORITHM_IDENTIFIER(data?: Partial<CRYPT_ALGORITHM_IDENTIFIER>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ALGORITHM_IDENTIFIER);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.Parameters !== undefined) view.setBigUint64(8, data.Parameters === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Parameters))), true);
  return buf;
}

export class CRYPT_ALGORITHM_IDENTIFIERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Parameters(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set Parameters(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_OBJID_TABLE (size: 16)
 */
export interface CRYPT_OBJID_TABLE {
  /** u32 */
  dwAlgId: number;
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
}

export const sizeofCRYPT_OBJID_TABLE = 16;

export function allocCRYPT_OBJID_TABLE(data?: Partial<CRYPT_OBJID_TABLE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_OBJID_TABLE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwAlgId !== undefined) view.setUint32(0, Number(data.dwAlgId), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CRYPT_OBJID_TABLEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwAlgId(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwAlgId(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_HASH_INFO (size: 16)
 */
export interface CRYPT_HASH_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Hash: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_HASH_INFO = 16;

export function allocCRYPT_HASH_INFO(data?: Partial<CRYPT_HASH_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_HASH_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(0, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x08: pointer
  if (data?.Hash !== undefined) view.setBigUint64(8, data.Hash === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Hash))), true);
  return buf;
}

export class CRYPT_HASH_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Hash(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set Hash(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_EXTENSION (size: 24)
 */
export interface CERT_EXTENSION {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fCritical: boolean;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Value: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_EXTENSION = 24;

export function allocCERT_EXTENSION(data?: Partial<CERT_EXTENSION>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_EXTENSION);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: i32
  if (data?.fCritical !== undefined) view.setInt32(8, Number(data.fCritical), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Value !== undefined) view.setBigUint64(16, data.Value === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Value))), true);
  return buf;
}

export class CERT_EXTENSIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: i32
  get fCritical(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Value(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: i32
  set fCritical(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Value(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTE_TYPE_VALUE (size: 16)
 */
export interface CRYPT_ATTRIBUTE_TYPE_VALUE {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Value: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_ATTRIBUTE_TYPE_VALUE = 16;

export function allocCRYPT_ATTRIBUTE_TYPE_VALUE(data?: Partial<CRYPT_ATTRIBUTE_TYPE_VALUE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ATTRIBUTE_TYPE_VALUE);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.Value !== undefined) view.setBigUint64(8, data.Value === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Value))), true);
  return buf;
}

export class CRYPT_ATTRIBUTE_TYPE_VALUEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Value(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set Value(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTE (size: 24)
 */
export interface CRYPT_ATTRIBUTE {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** u32 */
  cValue: number;
  /** ptr */
  rgValue: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_ATTRIBUTE = 24;

export function allocCRYPT_ATTRIBUTE(data?: Partial<CRYPT_ATTRIBUTE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ATTRIBUTE);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cValue !== undefined) view.setUint32(8, Number(data.cValue), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgValue !== undefined) view.setBigUint64(16, data.rgValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgValue))), true);
  return buf;
}

export class CRYPT_ATTRIBUTEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cValue(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cValue(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTES (size: 16)
 */
export interface CRYPT_ATTRIBUTES {
  /** u32 */
  cAttr: number;
  /** ptr */
  rgAttr: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_ATTRIBUTES = 16;

export function allocCRYPT_ATTRIBUTES(data?: Partial<CRYPT_ATTRIBUTES>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ATTRIBUTES);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cAttr !== undefined) view.setUint32(0, Number(data.cAttr), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgAttr !== undefined) view.setBigUint64(8, data.rgAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAttr))), true);
  return buf;
}

export class CRYPT_ATTRIBUTESView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cAttr(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cAttr(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_RDN_ATTR (size: 24)
 */
export interface CERT_RDN_ATTR {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CERT_RDN_ATTR_VALUE_TYPE */
  dwValueType: CERT_RDN_ATTR_VALUE_TYPE;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Value: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_RDN_ATTR = 24;

export function allocCERT_RDN_ATTR(data?: Partial<CERT_RDN_ATTR>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_RDN_ATTR);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.dwValueType !== undefined) view.setUint32(8, Number(data.dwValueType), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Value !== undefined) view.setBigUint64(16, data.Value === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Value))), true);
  return buf;
}

export class CERT_RDN_ATTRView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwValueType(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Value(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set dwValueType(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Value(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_RDN (size: 16)
 */
export interface CERT_RDN {
  /** u32 */
  cRDNAttr: number;
  /** ptr */
  rgRDNAttr: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_RDN = 16;

export function allocCERT_RDN(data?: Partial<CERT_RDN>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_RDN);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cRDNAttr !== undefined) view.setUint32(0, Number(data.cRDNAttr), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgRDNAttr !== undefined) view.setBigUint64(8, data.rgRDNAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgRDNAttr))), true);
  return buf;
}

export class CERT_RDNView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cRDNAttr(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgRDNAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cRDNAttr(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgRDNAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_NAME_INFO (size: 16)
 */
export interface CERT_NAME_INFO {
  /** u32 */
  cRDN: number;
  /** ptr */
  rgRDN: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_NAME_INFO = 16;

export function allocCERT_NAME_INFO(data?: Partial<CERT_NAME_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_NAME_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cRDN !== undefined) view.setUint32(0, Number(data.cRDN), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgRDN !== undefined) view.setBigUint64(8, data.rgRDN === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgRDN))), true);
  return buf;
}

export class CERT_NAME_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cRDN(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgRDN(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cRDN(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgRDN(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_NAME_VALUE (size: 16)
 */
export interface CERT_NAME_VALUE {
  /** u32 */
  dwValueType: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Value: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_NAME_VALUE = 16;

export function allocCERT_NAME_VALUE(data?: Partial<CERT_NAME_VALUE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_NAME_VALUE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwValueType !== undefined) view.setUint32(0, Number(data.dwValueType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Value !== undefined) view.setBigUint64(8, data.Value === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Value))), true);
  return buf;
}

export class CERT_NAME_VALUEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwValueType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Value(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwValueType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Value(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_PUBLIC_KEY_INFO (size: 16)
 */
export interface CERT_PUBLIC_KEY_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  Algorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  PublicKey: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_PUBLIC_KEY_INFO = 16;

export function allocCERT_PUBLIC_KEY_INFO(data?: Partial<CERT_PUBLIC_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_PUBLIC_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Algorithm !== undefined) view.setBigUint64(0, data.Algorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Algorithm))), true);
  // 0x08: pointer
  if (data?.PublicKey !== undefined) view.setBigUint64(8, data.PublicKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PublicKey))), true);
  return buf;
}

export class CERT_PUBLIC_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Algorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get PublicKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Algorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set PublicKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ECC_PRIVATE_KEY_INFO (size: 32)
 */
export interface CRYPT_ECC_PRIVATE_KEY_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  PrivateKey: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PSTR */
  szCurveOid: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  PublicKey: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_ECC_PRIVATE_KEY_INFO = 32;

export function allocCRYPT_ECC_PRIVATE_KEY_INFO(data?: Partial<CRYPT_ECC_PRIVATE_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ECC_PRIVATE_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.PrivateKey !== undefined) view.setBigUint64(8, data.PrivateKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PrivateKey))), true);
  // 0x10: buffer
  if (data?.szCurveOid !== undefined) {
    (buf as any)._f16 = util.pstrToFfi(data.szCurveOid);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: pointer
  if (data?.PublicKey !== undefined) view.setBigUint64(24, data.PublicKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PublicKey))), true);
  return buf;
}

export class CRYPT_ECC_PRIVATE_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get PrivateKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get szCurveOid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get PublicKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set PrivateKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set szCurveOid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: pointer
  set PublicKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PRIVATE_KEY_INFO (size: 32)
 */
export interface CRYPT_PRIVATE_KEY_INFO {
  /** u32 */
  Version: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  Algorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  PrivateKey: Uint8Array | Deno.PointerValue;
  /** ptr */
  pAttributes: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PRIVATE_KEY_INFO = 32;

export function allocCRYPT_PRIVATE_KEY_INFO(data?: Partial<CRYPT_PRIVATE_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PRIVATE_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Version !== undefined) view.setUint32(0, Number(data.Version), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Algorithm !== undefined) view.setBigUint64(8, data.Algorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Algorithm))), true);
  // 0x10: pointer
  if (data?.PrivateKey !== undefined) view.setBigUint64(16, data.PrivateKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PrivateKey))), true);
  // 0x18: pointer
  if (data?.pAttributes !== undefined) view.setBigUint64(24, data.pAttributes === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pAttributes))), true);
  return buf;
}

export class CRYPT_PRIVATE_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Version(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Algorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get PrivateKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pAttributes(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set Version(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Algorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set PrivateKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pAttributes(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ENCRYPTED_PRIVATE_KEY_INFO (size: 16)
 */
export interface CRYPT_ENCRYPTED_PRIVATE_KEY_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  EncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedPrivateKey: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_ENCRYPTED_PRIVATE_KEY_INFO = 16;

export function allocCRYPT_ENCRYPTED_PRIVATE_KEY_INFO(data?: Partial<CRYPT_ENCRYPTED_PRIVATE_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ENCRYPTED_PRIVATE_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.EncryptionAlgorithm !== undefined) view.setBigUint64(0, data.EncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptionAlgorithm))), true);
  // 0x08: pointer
  if (data?.EncryptedPrivateKey !== undefined) view.setBigUint64(8, data.EncryptedPrivateKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedPrivateKey))), true);
  return buf;
}

export class CRYPT_ENCRYPTED_PRIVATE_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get EncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get EncryptedPrivateKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set EncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set EncryptedPrivateKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PKCS8_IMPORT_PARAMS (size: 40)
 */
export interface CRYPT_PKCS8_IMPORT_PARAMS {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  PrivateKey: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PCRYPT_RESOLVE_HCRYPTPROV_FUNC */
  pResolvehCryptProvFunc: Uint8Array | Deno.PointerValue;
  /** ptr */
  pVoidResolveFunc: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.PCRYPT_DECRYPT_PRIVATE_KEY_FUNC */
  pDecryptPrivateKeyFunc: Uint8Array | Deno.PointerValue;
  /** ptr */
  pVoidDecryptFunc: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PKCS8_IMPORT_PARAMS = 40;

export function allocCRYPT_PKCS8_IMPORT_PARAMS(data?: Partial<CRYPT_PKCS8_IMPORT_PARAMS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PKCS8_IMPORT_PARAMS);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.PrivateKey !== undefined) view.setBigUint64(0, data.PrivateKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PrivateKey))), true);
  // 0x08: pointer
  if (data?.pResolvehCryptProvFunc !== undefined) view.setBigUint64(8, data.pResolvehCryptProvFunc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pResolvehCryptProvFunc))), true);
  // 0x10: pointer
  if (data?.pVoidResolveFunc !== undefined) view.setBigUint64(16, data.pVoidResolveFunc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pVoidResolveFunc))), true);
  // 0x18: pointer
  if (data?.pDecryptPrivateKeyFunc !== undefined) view.setBigUint64(24, data.pDecryptPrivateKeyFunc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pDecryptPrivateKeyFunc))), true);
  // 0x20: pointer
  if (data?.pVoidDecryptFunc !== undefined) view.setBigUint64(32, data.pVoidDecryptFunc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pVoidDecryptFunc))), true);
  return buf;
}

export class CRYPT_PKCS8_IMPORT_PARAMSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get PrivateKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pResolvehCryptProvFunc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pVoidResolveFunc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pDecryptPrivateKeyFunc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pVoidDecryptFunc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set PrivateKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pResolvehCryptProvFunc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pVoidResolveFunc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pDecryptPrivateKeyFunc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pVoidDecryptFunc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PKCS8_EXPORT_PARAMS (size: 40)
 */
export interface CRYPT_PKCS8_EXPORT_PARAMS {
  /** usize */
  hCryptProv: Deno.PointerValue;
  /** u32 */
  dwKeySpec: number;
  /** Windows.Win32.Foundation.PSTR */
  pszPrivateKeyObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC */
  pEncryptPrivateKeyFunc: Uint8Array | Deno.PointerValue;
  /** ptr */
  pVoidEncryptFunc: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_PKCS8_EXPORT_PARAMS = 40;

export function allocCRYPT_PKCS8_EXPORT_PARAMS(data?: Partial<CRYPT_PKCS8_EXPORT_PARAMS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PKCS8_EXPORT_PARAMS);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.hCryptProv !== undefined) view.setBigUint64(0, BigInt(data.hCryptProv), true);
  // 0x08: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(8, Number(data.dwKeySpec), true);
  // 0x0c: pad4
  // 0x10: buffer
  if (data?.pszPrivateKeyObjId !== undefined) {
    (buf as any)._f16 = util.pstrToFfi(data.pszPrivateKeyObjId);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: pointer
  if (data?.pEncryptPrivateKeyFunc !== undefined) view.setBigUint64(24, data.pEncryptPrivateKeyFunc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pEncryptPrivateKeyFunc))), true);
  // 0x20: pointer
  if (data?.pVoidEncryptFunc !== undefined) view.setBigUint64(32, data.pVoidEncryptFunc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pVoidEncryptFunc))), true);
  return buf;
}

export class CRYPT_PKCS8_EXPORT_PARAMSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: usize
  get hCryptProv(): Deno.PointerValue {
    return Number(this.view.getBigUint64(0, true));
  }

  // 0x08: u32
  get dwKeySpec(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: buffer
  get pszPrivateKeyObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pEncryptPrivateKeyFunc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pVoidEncryptFunc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: usize
  set hCryptProv(value: Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(value), true);
  }

  // 0x08: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: buffer
  set pszPrivateKeyObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: pointer
  set pEncryptPrivateKeyFunc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pVoidEncryptFunc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Foundation.FILETIME (size: 8)
 */
export interface FILETIME {
  /** u32 */
  dwLowDateTime: number;
  /** u32 */
  dwHighDateTime: number;
}

export const sizeofFILETIME = 8;

export function allocFILETIME(data?: Partial<FILETIME>): Uint8Array {
  const buf = new Uint8Array(sizeofFILETIME);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwLowDateTime !== undefined) view.setUint32(0, Number(data.dwLowDateTime), true);
  // 0x04: u32
  if (data?.dwHighDateTime !== undefined) view.setUint32(4, Number(data.dwHighDateTime), true);
  return buf;
}

export class FILETIMEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwLowDateTime(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwHighDateTime(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwLowDateTime(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwHighDateTime(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_INFO (size: 96)
 */
export interface CERT_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SerialNumber: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  SignatureAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Issuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  NotBefore: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  NotAfter: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Subject: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_PUBLIC_KEY_INFO */
  SubjectPublicKeyInfo: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  IssuerUniqueId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  SubjectUniqueId: Uint8Array | Deno.PointerValue;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_INFO = 96;

export function allocCERT_INFO(data?: Partial<CERT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SerialNumber !== undefined) view.setBigUint64(8, data.SerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SerialNumber))), true);
  // 0x10: pointer
  if (data?.SignatureAlgorithm !== undefined) view.setBigUint64(16, data.SignatureAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignatureAlgorithm))), true);
  // 0x18: pointer
  if (data?.Issuer !== undefined) view.setBigUint64(24, data.Issuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Issuer))), true);
  // 0x20: pointer
  if (data?.NotBefore !== undefined) view.setBigUint64(32, data.NotBefore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NotBefore))), true);
  // 0x28: pointer
  if (data?.NotAfter !== undefined) view.setBigUint64(40, data.NotAfter === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NotAfter))), true);
  // 0x30: pointer
  if (data?.Subject !== undefined) view.setBigUint64(48, data.Subject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Subject))), true);
  // 0x38: pointer
  if (data?.SubjectPublicKeyInfo !== undefined) view.setBigUint64(56, data.SubjectPublicKeyInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectPublicKeyInfo))), true);
  // 0x40: pointer
  if (data?.IssuerUniqueId !== undefined) view.setBigUint64(64, data.IssuerUniqueId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IssuerUniqueId))), true);
  // 0x48: pointer
  if (data?.SubjectUniqueId !== undefined) view.setBigUint64(72, data.SubjectUniqueId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectUniqueId))), true);
  // 0x50: u32
  if (data?.cExtension !== undefined) view.setUint32(80, Number(data.cExtension), true);
  // 0x54: pad4
  // 0x58: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(88, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CERT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get SignatureAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get Issuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get NotBefore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get NotAfter(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get Subject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get SubjectPublicKeyInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: pointer
  get IssuerUniqueId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: pointer
  get SubjectUniqueId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: u32
  get cExtension(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set SignatureAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set Issuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set NotBefore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set NotAfter(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set Subject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set SubjectPublicKeyInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: pointer
  set IssuerUniqueId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: pointer
  set SubjectUniqueId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x50: u32
  set cExtension(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_ENTRY (size: 32)
 */
export interface CRL_ENTRY {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SerialNumber: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  RevocationDate: Uint8Array | Deno.PointerValue;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCRL_ENTRY = 32;

export function allocCRL_ENTRY(data?: Partial<CRL_ENTRY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_ENTRY);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.SerialNumber !== undefined) view.setBigUint64(0, data.SerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SerialNumber))), true);
  // 0x08: pointer
  if (data?.RevocationDate !== undefined) view.setBigUint64(8, data.RevocationDate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RevocationDate))), true);
  // 0x10: u32
  if (data?.cExtension !== undefined) view.setUint32(16, Number(data.cExtension), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(24, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CRL_ENTRYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get SerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get RevocationDate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cExtension(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set SerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set RevocationDate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cExtension(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_INFO (size: 72)
 */
export interface CRL_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  SignatureAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Issuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  ThisUpdate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  NextUpdate: Uint8Array | Deno.PointerValue;
  /** u32 */
  cCRLEntry: number;
  /** ptr */
  rgCRLEntry: Deno.PointerValue | Uint8Array;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCRL_INFO = 72;

export function allocCRL_INFO(data?: Partial<CRL_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SignatureAlgorithm !== undefined) view.setBigUint64(8, data.SignatureAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignatureAlgorithm))), true);
  // 0x10: pointer
  if (data?.Issuer !== undefined) view.setBigUint64(16, data.Issuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Issuer))), true);
  // 0x18: pointer
  if (data?.ThisUpdate !== undefined) view.setBigUint64(24, data.ThisUpdate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ThisUpdate))), true);
  // 0x20: pointer
  if (data?.NextUpdate !== undefined) view.setBigUint64(32, data.NextUpdate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NextUpdate))), true);
  // 0x28: u32
  if (data?.cCRLEntry !== undefined) view.setUint32(40, Number(data.cCRLEntry), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.rgCRLEntry !== undefined) view.setBigUint64(48, data.rgCRLEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCRLEntry))), true);
  // 0x38: u32
  if (data?.cExtension !== undefined) view.setUint32(56, Number(data.cExtension), true);
  // 0x3c: pad4
  // 0x40: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(64, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CRL_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SignatureAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Issuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get ThisUpdate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get NextUpdate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get cCRLEntry(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get rgCRLEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: u32
  get cExtension(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SignatureAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Issuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set ThisUpdate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set NextUpdate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: u32
  set cCRLEntry(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set rgCRLEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: u32
  set cExtension(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_OR_CRL_BLOB (size: 16)
 */
export interface CERT_OR_CRL_BLOB {
  /** u32 */
  dwChoice: number;
  /** u32 */
  cbEncoded: number;
  /** ptr */
  pbEncoded: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_OR_CRL_BLOB = 16;

export function allocCERT_OR_CRL_BLOB(data?: Partial<CERT_OR_CRL_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_OR_CRL_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwChoice !== undefined) view.setUint32(0, Number(data.dwChoice), true);
  // 0x04: u32
  if (data?.cbEncoded !== undefined) view.setUint32(4, Number(data.cbEncoded), true);
  // 0x08: pointer
  if (data?.pbEncoded !== undefined) view.setBigUint64(8, data.pbEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbEncoded))), true);
  return buf;
}

export class CERT_OR_CRL_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbEncoded(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pbEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbEncoded(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pbEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_OR_CRL_BUNDLE (size: 16)
 */
export interface CERT_OR_CRL_BUNDLE {
  /** u32 */
  cItem: number;
  /** ptr */
  rgItem: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_OR_CRL_BUNDLE = 16;

export function allocCERT_OR_CRL_BUNDLE(data?: Partial<CERT_OR_CRL_BUNDLE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_OR_CRL_BUNDLE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cItem !== undefined) view.setUint32(0, Number(data.cItem), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgItem !== undefined) view.setBigUint64(8, data.rgItem === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgItem))), true);
  return buf;
}

export class CERT_OR_CRL_BUNDLEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cItem(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgItem(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cItem(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgItem(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_REQUEST_INFO (size: 40)
 */
export interface CERT_REQUEST_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Subject: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_PUBLIC_KEY_INFO */
  SubjectPublicKeyInfo: Uint8Array | Deno.PointerValue;
  /** u32 */
  cAttribute: number;
  /** ptr */
  rgAttribute: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_REQUEST_INFO = 40;

export function allocCERT_REQUEST_INFO(data?: Partial<CERT_REQUEST_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REQUEST_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Subject !== undefined) view.setBigUint64(8, data.Subject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Subject))), true);
  // 0x10: pointer
  if (data?.SubjectPublicKeyInfo !== undefined) view.setBigUint64(16, data.SubjectPublicKeyInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectPublicKeyInfo))), true);
  // 0x18: u32
  if (data?.cAttribute !== undefined) view.setUint32(24, Number(data.cAttribute), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgAttribute !== undefined) view.setBigUint64(32, data.rgAttribute === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAttribute))), true);
  return buf;
}

export class CERT_REQUEST_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Subject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get SubjectPublicKeyInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cAttribute(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgAttribute(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Subject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set SubjectPublicKeyInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set cAttribute(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgAttribute(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_KEYGEN_REQUEST_INFO (size: 24)
 */
export interface CERT_KEYGEN_REQUEST_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CERT_PUBLIC_KEY_INFO */
  SubjectPublicKeyInfo: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pwszChallengeString: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_KEYGEN_REQUEST_INFO = 24;

export function allocCERT_KEYGEN_REQUEST_INFO(data?: Partial<CERT_KEYGEN_REQUEST_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_KEYGEN_REQUEST_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SubjectPublicKeyInfo !== undefined) view.setBigUint64(8, data.SubjectPublicKeyInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectPublicKeyInfo))), true);
  // 0x10: buffer
  if (data?.pwszChallengeString !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszChallengeString);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class CERT_KEYGEN_REQUEST_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SubjectPublicKeyInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszChallengeString(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SubjectPublicKeyInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set pwszChallengeString(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SIGNED_CONTENT_INFO (size: 24)
 */
export interface CERT_SIGNED_CONTENT_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ToBeSigned: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  SignatureAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  Signature: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_SIGNED_CONTENT_INFO = 24;

export function allocCERT_SIGNED_CONTENT_INFO(data?: Partial<CERT_SIGNED_CONTENT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SIGNED_CONTENT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ToBeSigned !== undefined) view.setBigUint64(0, data.ToBeSigned === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ToBeSigned))), true);
  // 0x08: pointer
  if (data?.SignatureAlgorithm !== undefined) view.setBigUint64(8, data.SignatureAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignatureAlgorithm))), true);
  // 0x10: pointer
  if (data?.Signature !== undefined) view.setBigUint64(16, data.Signature === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Signature))), true);
  return buf;
}

export class CERT_SIGNED_CONTENT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ToBeSigned(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get SignatureAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Signature(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set ToBeSigned(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set SignatureAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Signature(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_USAGE (size: 16)
 */
export interface CTL_USAGE {
  /** u32 */
  cUsageIdentifier: number;
  /** ptr */
  rgpszUsageIdentifier: Deno.PointerValue | Uint8Array;
}

export const sizeofCTL_USAGE = 16;

export function allocCTL_USAGE(data?: Partial<CTL_USAGE>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_USAGE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cUsageIdentifier !== undefined) view.setUint32(0, Number(data.cUsageIdentifier), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszUsageIdentifier !== undefined) view.setBigUint64(8, data.rgpszUsageIdentifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszUsageIdentifier))), true);
  return buf;
}

export class CTL_USAGEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cUsageIdentifier(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszUsageIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cUsageIdentifier(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszUsageIdentifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_ENTRY (size: 24)
 */
export interface CTL_ENTRY {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SubjectIdentifier: Uint8Array | Deno.PointerValue;
  /** u32 */
  cAttribute: number;
  /** ptr */
  rgAttribute: Deno.PointerValue | Uint8Array;
}

export const sizeofCTL_ENTRY = 24;

export function allocCTL_ENTRY(data?: Partial<CTL_ENTRY>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_ENTRY);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.SubjectIdentifier !== undefined) view.setBigUint64(0, data.SubjectIdentifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectIdentifier))), true);
  // 0x08: u32
  if (data?.cAttribute !== undefined) view.setUint32(8, Number(data.cAttribute), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgAttribute !== undefined) view.setBigUint64(16, data.rgAttribute === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAttribute))), true);
  return buf;
}

export class CTL_ENTRYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get SubjectIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cAttribute(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgAttribute(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set SubjectIdentifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set cAttribute(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgAttribute(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_INFO (size: 88)
 */
export interface CTL_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CTL_USAGE */
  SubjectUsage: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ListIdentifier: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SequenceNumber: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  ThisUpdate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  NextUpdate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  SubjectAlgorithm: Uint8Array | Deno.PointerValue;
  /** u32 */
  cCTLEntry: number;
  /** ptr */
  rgCTLEntry: Deno.PointerValue | Uint8Array;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCTL_INFO = 88;

export function allocCTL_INFO(data?: Partial<CTL_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SubjectUsage !== undefined) view.setBigUint64(8, data.SubjectUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectUsage))), true);
  // 0x10: pointer
  if (data?.ListIdentifier !== undefined) view.setBigUint64(16, data.ListIdentifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ListIdentifier))), true);
  // 0x18: pointer
  if (data?.SequenceNumber !== undefined) view.setBigUint64(24, data.SequenceNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SequenceNumber))), true);
  // 0x20: pointer
  if (data?.ThisUpdate !== undefined) view.setBigUint64(32, data.ThisUpdate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ThisUpdate))), true);
  // 0x28: pointer
  if (data?.NextUpdate !== undefined) view.setBigUint64(40, data.NextUpdate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NextUpdate))), true);
  // 0x30: pointer
  if (data?.SubjectAlgorithm !== undefined) view.setBigUint64(48, data.SubjectAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectAlgorithm))), true);
  // 0x38: u32
  if (data?.cCTLEntry !== undefined) view.setUint32(56, Number(data.cCTLEntry), true);
  // 0x3c: pad4
  // 0x40: pointer
  if (data?.rgCTLEntry !== undefined) view.setBigUint64(64, data.rgCTLEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCTLEntry))), true);
  // 0x48: u32
  if (data?.cExtension !== undefined) view.setUint32(72, Number(data.cExtension), true);
  // 0x4c: pad4
  // 0x50: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(80, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CTL_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SubjectUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get ListIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get SequenceNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get ThisUpdate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get NextUpdate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get SubjectAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: u32
  get cCTLEntry(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  get rgCTLEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: u32
  get cExtension(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SubjectUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set ListIdentifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set SequenceNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set ThisUpdate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set NextUpdate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set SubjectAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: u32
  set cCTLEntry(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  set rgCTLEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: u32
  set cExtension(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_TIME_STAMP_REQUEST_INFO (size: 40)
 */
export interface CRYPT_TIME_STAMP_REQUEST_INFO {
  /** Windows.Win32.Foundation.PSTR */
  pszTimeStampAlgorithm: string | null | Uint8Array;
  /** Windows.Win32.Foundation.PSTR */
  pszContentType: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Content: Uint8Array | Deno.PointerValue;
  /** u32 */
  cAttribute: number;
  /** ptr */
  rgAttribute: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_TIME_STAMP_REQUEST_INFO = 40;

export function allocCRYPT_TIME_STAMP_REQUEST_INFO(data?: Partial<CRYPT_TIME_STAMP_REQUEST_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_TIME_STAMP_REQUEST_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszTimeStampAlgorithm !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszTimeStampAlgorithm);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pszContentType !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszContentType);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.Content !== undefined) view.setBigUint64(16, data.Content === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Content))), true);
  // 0x18: u32
  if (data?.cAttribute !== undefined) view.setUint32(24, Number(data.cAttribute), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgAttribute !== undefined) view.setBigUint64(32, data.rgAttribute === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAttribute))), true);
  return buf;
}

export class CRYPT_TIME_STAMP_REQUEST_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszTimeStampAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pszContentType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Content(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cAttribute(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgAttribute(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszTimeStampAlgorithm(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pszContentType(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set Content(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set cAttribute(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgAttribute(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ENROLLMENT_NAME_VALUE_PAIR (size: 16)
 */
export interface CRYPT_ENROLLMENT_NAME_VALUE_PAIR {
  /** Windows.Win32.Foundation.PWSTR */
  pwszName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszValue: string | null | Uint8Array | Uint16Array;
}

export const sizeofCRYPT_ENROLLMENT_NAME_VALUE_PAIR = 16;

export function allocCRYPT_ENROLLMENT_NAME_VALUE_PAIR(data?: Partial<CRYPT_ENROLLMENT_NAME_VALUE_PAIR>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ENROLLMENT_NAME_VALUE_PAIR);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pwszName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pwszName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pwszValue !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszValue);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CRYPT_ENROLLMENT_NAME_VALUE_PAIRView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pwszName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pwszValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pwszName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pwszValue(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CSP_PROVIDER (size: 24)
 */
export interface CRYPT_CSP_PROVIDER {
  /** u32 */
  dwKeySpec: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszProviderName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  Signature: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_CSP_PROVIDER = 24;

export function allocCRYPT_CSP_PROVIDER(data?: Partial<CRYPT_CSP_PROVIDER>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CSP_PROVIDER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(0, Number(data.dwKeySpec), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pwszProviderName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszProviderName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.Signature !== undefined) view.setBigUint64(16, data.Signature === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Signature))), true);
  return buf;
}

export class CRYPT_CSP_PROVIDERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwKeySpec(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pwszProviderName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Signature(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pwszProviderName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set Signature(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ENCODE_PARA (size: 24)
 */
export interface CRYPT_ENCODE_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_ALLOC */
  pfnAlloc: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_FREE */
  pfnFree: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_ENCODE_PARA = 24;

export function allocCRYPT_ENCODE_PARA(data?: Partial<CRYPT_ENCODE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ENCODE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pfnAlloc !== undefined) view.setBigUint64(8, data.pfnAlloc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnAlloc))), true);
  // 0x10: pointer
  if (data?.pfnFree !== undefined) view.setBigUint64(16, data.pfnFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFree))), true);
  return buf;
}

export class CRYPT_ENCODE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pfnAlloc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pfnFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pfnAlloc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pfnFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_DECODE_PARA (size: 24)
 */
export interface CRYPT_DECODE_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_ALLOC */
  pfnAlloc: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_FREE */
  pfnFree: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_DECODE_PARA = 24;

export function allocCRYPT_DECODE_PARA(data?: Partial<CRYPT_DECODE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_DECODE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pfnAlloc !== undefined) view.setBigUint64(8, data.pfnAlloc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnAlloc))), true);
  // 0x10: pointer
  if (data?.pfnFree !== undefined) view.setBigUint64(16, data.pfnFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFree))), true);
  return buf;
}

export class CRYPT_DECODE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pfnAlloc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pfnFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pfnAlloc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pfnFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_EXTENSIONS (size: 16)
 */
export interface CERT_EXTENSIONS {
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_EXTENSIONS = 16;

export function allocCERT_EXTENSIONS(data?: Partial<CERT_EXTENSIONS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_EXTENSIONS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cExtension !== undefined) view.setUint32(0, Number(data.cExtension), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(8, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CERT_EXTENSIONSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cExtension(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cExtension(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_AUTHORITY_KEY_ID_INFO (size: 24)
 */
export interface CERT_AUTHORITY_KEY_ID_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  KeyId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  CertIssuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  CertSerialNumber: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_AUTHORITY_KEY_ID_INFO = 24;

export function allocCERT_AUTHORITY_KEY_ID_INFO(data?: Partial<CERT_AUTHORITY_KEY_ID_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_AUTHORITY_KEY_ID_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.KeyId !== undefined) view.setBigUint64(0, data.KeyId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyId))), true);
  // 0x08: pointer
  if (data?.CertIssuer !== undefined) view.setBigUint64(8, data.CertIssuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CertIssuer))), true);
  // 0x10: pointer
  if (data?.CertSerialNumber !== undefined) view.setBigUint64(16, data.CertSerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CertSerialNumber))), true);
  return buf;
}

export class CERT_AUTHORITY_KEY_ID_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get KeyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get CertIssuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get CertSerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set KeyId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set CertIssuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set CertSerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_PRIVATE_KEY_VALIDITY (size: 16)
 */
export interface CERT_PRIVATE_KEY_VALIDITY {
  /** Windows.Win32.Foundation.FILETIME */
  NotBefore: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  NotAfter: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_PRIVATE_KEY_VALIDITY = 16;

export function allocCERT_PRIVATE_KEY_VALIDITY(data?: Partial<CERT_PRIVATE_KEY_VALIDITY>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_PRIVATE_KEY_VALIDITY);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.NotBefore !== undefined) view.setBigUint64(0, data.NotBefore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NotBefore))), true);
  // 0x08: pointer
  if (data?.NotAfter !== undefined) view.setBigUint64(8, data.NotAfter === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NotAfter))), true);
  return buf;
}

export class CERT_PRIVATE_KEY_VALIDITYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get NotBefore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get NotAfter(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set NotBefore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set NotAfter(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_KEY_ATTRIBUTES_INFO (size: 24)
 */
export interface CERT_KEY_ATTRIBUTES_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  KeyId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  IntendedKeyUsage: Uint8Array | Deno.PointerValue;
  /** ptr */
  pPrivateKeyUsagePeriod: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_KEY_ATTRIBUTES_INFO = 24;

export function allocCERT_KEY_ATTRIBUTES_INFO(data?: Partial<CERT_KEY_ATTRIBUTES_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_KEY_ATTRIBUTES_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.KeyId !== undefined) view.setBigUint64(0, data.KeyId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyId))), true);
  // 0x08: pointer
  if (data?.IntendedKeyUsage !== undefined) view.setBigUint64(8, data.IntendedKeyUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IntendedKeyUsage))), true);
  // 0x10: pointer
  if (data?.pPrivateKeyUsagePeriod !== undefined) view.setBigUint64(16, data.pPrivateKeyUsagePeriod === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pPrivateKeyUsagePeriod))), true);
  return buf;
}

export class CERT_KEY_ATTRIBUTES_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get KeyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get IntendedKeyUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pPrivateKeyUsagePeriod(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set KeyId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set IntendedKeyUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pPrivateKeyUsagePeriod(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_ID (size: 16)
 */
export interface CERT_POLICY_ID {
  /** u32 */
  cCertPolicyElementId: number;
  /** ptr */
  rgpszCertPolicyElementId: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_POLICY_ID = 16;

export function allocCERT_POLICY_ID(data?: Partial<CERT_POLICY_ID>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_ID);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cCertPolicyElementId !== undefined) view.setUint32(0, Number(data.cCertPolicyElementId), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszCertPolicyElementId !== undefined) view.setBigUint64(8, data.rgpszCertPolicyElementId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszCertPolicyElementId))), true);
  return buf;
}

export class CERT_POLICY_IDView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cCertPolicyElementId(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszCertPolicyElementId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cCertPolicyElementId(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszCertPolicyElementId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_KEY_USAGE_RESTRICTION_INFO (size: 24)
 */
export interface CERT_KEY_USAGE_RESTRICTION_INFO {
  /** u32 */
  cCertPolicyId: number;
  /** ptr */
  rgCertPolicyId: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  RestrictedKeyUsage: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_KEY_USAGE_RESTRICTION_INFO = 24;

export function allocCERT_KEY_USAGE_RESTRICTION_INFO(data?: Partial<CERT_KEY_USAGE_RESTRICTION_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_KEY_USAGE_RESTRICTION_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cCertPolicyId !== undefined) view.setUint32(0, Number(data.cCertPolicyId), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgCertPolicyId !== undefined) view.setBigUint64(8, data.rgCertPolicyId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCertPolicyId))), true);
  // 0x10: pointer
  if (data?.RestrictedKeyUsage !== undefined) view.setBigUint64(16, data.RestrictedKeyUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RestrictedKeyUsage))), true);
  return buf;
}

export class CERT_KEY_USAGE_RESTRICTION_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cCertPolicyId(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgCertPolicyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get RestrictedKeyUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cCertPolicyId(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgCertPolicyId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set RestrictedKeyUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_OTHER_NAME (size: 16)
 */
export interface CERT_OTHER_NAME {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Value: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_OTHER_NAME = 16;

export function allocCERT_OTHER_NAME(data?: Partial<CERT_OTHER_NAME>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_OTHER_NAME);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.Value !== undefined) view.setBigUint64(8, data.Value === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Value))), true);
  return buf;
}

export class CERT_OTHER_NAMEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Value(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set Value(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * _Anonymous_e__Struct (size: 16)
 */
export interface _Anonymous_e__Struct {
  /** u64 */
  Alignment: Deno.PointerValue;
  /** u64 */
  Region: Deno.PointerValue;
}

export const sizeof_Anonymous_e__Struct = 16;

export function alloc_Anonymous_e__Struct(data?: Partial<_Anonymous_e__Struct>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous_e__Struct);
  const view = new DataView(buf.buffer);
  // 0x00: u64
  if (data?.Alignment !== undefined) view.setBigUint64(0, BigInt(data.Alignment), true);
  // 0x08: u64
  if (data?.Region !== undefined) view.setBigUint64(8, BigInt(data.Region), true);
  return buf;
}

export class _Anonymous_e__StructView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u64
  get Alignment(): Deno.PointerValue {
    return Number(this.view.getBigUint64(0, true));
  }

  // 0x08: u64
  get Region(): Deno.PointerValue {
    return Number(this.view.getBigUint64(8, true));
  }

  // 0x00: u64
  set Alignment(value: Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(value), true);
  }

  // 0x08: u64
  set Region(value: Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(value), true);
  }
}

/**
 * _Anonymous_e__Union (size: 16)
 */
export interface _Anonymous_e__Union {
  /** _Anonymous_e__Struct */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** array */
  X: Deno.PointerValue;
}

export const sizeof_Anonymous_e__Union = 16;

export function alloc_Anonymous_e__Union(data?: Partial<_Anonymous_e__Union>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous_e__Union);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(0, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x08: pointer
  if (data?.X !== undefined) view.setBigUint64(8, data.X === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.X))), true);
  return buf;
}

export class _Anonymous_e__UnionView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get X(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set X(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_ALT_NAME_ENTRY (size: 16)
 */
export interface CERT_ALT_NAME_ENTRY {
  /** u32 */
  dwAltNameChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_ALT_NAME_ENTRY = 16;

export function allocCERT_ALT_NAME_ENTRY(data?: Partial<CERT_ALT_NAME_ENTRY>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_ALT_NAME_ENTRY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwAltNameChoice !== undefined) view.setUint32(0, Number(data.dwAltNameChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CERT_ALT_NAME_ENTRYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwAltNameChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwAltNameChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_ALT_NAME_INFO (size: 16)
 */
export interface CERT_ALT_NAME_INFO {
  /** u32 */
  cAltEntry: number;
  /** ptr */
  rgAltEntry: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_ALT_NAME_INFO = 16;

export function allocCERT_ALT_NAME_INFO(data?: Partial<CERT_ALT_NAME_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_ALT_NAME_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cAltEntry !== undefined) view.setUint32(0, Number(data.cAltEntry), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgAltEntry !== undefined) view.setBigUint64(8, data.rgAltEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAltEntry))), true);
  return buf;
}

export class CERT_ALT_NAME_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cAltEntry(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgAltEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cAltEntry(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgAltEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_BASIC_CONSTRAINTS_INFO (size: 32)
 */
export interface CERT_BASIC_CONSTRAINTS_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  SubjectType: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.BOOL */
  fPathLenConstraint: boolean;
  /** u32 */
  dwPathLenConstraint: number;
  /** u32 */
  cSubtreesConstraint: number;
  /** ptr */
  rgSubtreesConstraint: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_BASIC_CONSTRAINTS_INFO = 32;

export function allocCERT_BASIC_CONSTRAINTS_INFO(data?: Partial<CERT_BASIC_CONSTRAINTS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_BASIC_CONSTRAINTS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.SubjectType !== undefined) view.setBigUint64(0, data.SubjectType === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectType))), true);
  // 0x08: i32
  if (data?.fPathLenConstraint !== undefined) view.setInt32(8, Number(data.fPathLenConstraint), true);
  // 0x0c: u32
  if (data?.dwPathLenConstraint !== undefined) view.setUint32(12, Number(data.dwPathLenConstraint), true);
  // 0x10: u32
  if (data?.cSubtreesConstraint !== undefined) view.setUint32(16, Number(data.cSubtreesConstraint), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgSubtreesConstraint !== undefined) view.setBigUint64(24, data.rgSubtreesConstraint === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgSubtreesConstraint))), true);
  return buf;
}

export class CERT_BASIC_CONSTRAINTS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get SubjectType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: i32
  get fPathLenConstraint(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: u32
  get dwPathLenConstraint(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get cSubtreesConstraint(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgSubtreesConstraint(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set SubjectType(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: i32
  set fPathLenConstraint(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: u32
  set dwPathLenConstraint(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set cSubtreesConstraint(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgSubtreesConstraint(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_BASIC_CONSTRAINTS2_INFO (size: 16)
 */
export interface CERT_BASIC_CONSTRAINTS2_INFO {
  /** Windows.Win32.Foundation.BOOL */
  fCA: boolean;
  /** Windows.Win32.Foundation.BOOL */
  fPathLenConstraint: boolean;
  /** u32 */
  dwPathLenConstraint: number;
}

export const sizeofCERT_BASIC_CONSTRAINTS2_INFO = 16;

export function allocCERT_BASIC_CONSTRAINTS2_INFO(data?: Partial<CERT_BASIC_CONSTRAINTS2_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_BASIC_CONSTRAINTS2_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.fCA !== undefined) view.setInt32(0, Number(data.fCA), true);
  // 0x04: i32
  if (data?.fPathLenConstraint !== undefined) view.setInt32(4, Number(data.fPathLenConstraint), true);
  // 0x08: u32
  if (data?.dwPathLenConstraint !== undefined) view.setUint32(8, Number(data.dwPathLenConstraint), true);
  // 0x0c: pad4
  return buf;
}

export class CERT_BASIC_CONSTRAINTS2_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get fCA(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: i32
  get fPathLenConstraint(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: u32
  get dwPathLenConstraint(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: i32
  set fCA(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: i32
  set fPathLenConstraint(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: u32
  set dwPathLenConstraint(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_QUALIFIER_INFO (size: 16)
 */
export interface CERT_POLICY_QUALIFIER_INFO {
  /** Windows.Win32.Foundation.PSTR */
  pszPolicyQualifierId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Qualifier: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_POLICY_QUALIFIER_INFO = 16;

export function allocCERT_POLICY_QUALIFIER_INFO(data?: Partial<CERT_POLICY_QUALIFIER_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_QUALIFIER_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszPolicyQualifierId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszPolicyQualifierId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.Qualifier !== undefined) view.setBigUint64(8, data.Qualifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Qualifier))), true);
  return buf;
}

export class CERT_POLICY_QUALIFIER_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszPolicyQualifierId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Qualifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszPolicyQualifierId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set Qualifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_INFO (size: 24)
 */
export interface CERT_POLICY_INFO {
  /** Windows.Win32.Foundation.PSTR */
  pszPolicyIdentifier: string | null | Uint8Array;
  /** u32 */
  cPolicyQualifier: number;
  /** ptr */
  rgPolicyQualifier: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_POLICY_INFO = 24;

export function allocCERT_POLICY_INFO(data?: Partial<CERT_POLICY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszPolicyIdentifier !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszPolicyIdentifier);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cPolicyQualifier !== undefined) view.setUint32(8, Number(data.cPolicyQualifier), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgPolicyQualifier !== undefined) view.setBigUint64(16, data.rgPolicyQualifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgPolicyQualifier))), true);
  return buf;
}

export class CERT_POLICY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszPolicyIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cPolicyQualifier(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgPolicyQualifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszPolicyIdentifier(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cPolicyQualifier(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgPolicyQualifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICIES_INFO (size: 16)
 */
export interface CERT_POLICIES_INFO {
  /** u32 */
  cPolicyInfo: number;
  /** ptr */
  rgPolicyInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_POLICIES_INFO = 16;

export function allocCERT_POLICIES_INFO(data?: Partial<CERT_POLICIES_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICIES_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cPolicyInfo !== undefined) view.setUint32(0, Number(data.cPolicyInfo), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgPolicyInfo !== undefined) view.setBigUint64(8, data.rgPolicyInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgPolicyInfo))), true);
  return buf;
}

export class CERT_POLICIES_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cPolicyInfo(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgPolicyInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cPolicyInfo(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgPolicyInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_QUALIFIER_NOTICE_REFERENCE (size: 24)
 */
export interface CERT_POLICY_QUALIFIER_NOTICE_REFERENCE {
  /** Windows.Win32.Foundation.PSTR */
  pszOrganization: string | null | Uint8Array;
  /** u32 */
  cNoticeNumbers: number;
  /** ptr */
  rgNoticeNumbers: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = 24;

export function allocCERT_POLICY_QUALIFIER_NOTICE_REFERENCE(data?: Partial<CERT_POLICY_QUALIFIER_NOTICE_REFERENCE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_QUALIFIER_NOTICE_REFERENCE);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszOrganization !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszOrganization);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cNoticeNumbers !== undefined) view.setUint32(8, Number(data.cNoticeNumbers), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgNoticeNumbers !== undefined) view.setBigUint64(16, data.rgNoticeNumbers === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgNoticeNumbers))), true);
  return buf;
}

export class CERT_POLICY_QUALIFIER_NOTICE_REFERENCEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszOrganization(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cNoticeNumbers(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgNoticeNumbers(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszOrganization(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cNoticeNumbers(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgNoticeNumbers(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_QUALIFIER_USER_NOTICE (size: 16)
 */
export interface CERT_POLICY_QUALIFIER_USER_NOTICE {
  /** ptr */
  pNoticeReference: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pszDisplayText: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_POLICY_QUALIFIER_USER_NOTICE = 16;

export function allocCERT_POLICY_QUALIFIER_USER_NOTICE(data?: Partial<CERT_POLICY_QUALIFIER_USER_NOTICE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_QUALIFIER_USER_NOTICE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pNoticeReference !== undefined) view.setBigUint64(0, data.pNoticeReference === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pNoticeReference))), true);
  // 0x08: buffer
  if (data?.pszDisplayText !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pszDisplayText);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CERT_POLICY_QUALIFIER_USER_NOTICEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pNoticeReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pszDisplayText(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pNoticeReference(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: buffer
  set pszDisplayText(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CPS_URLS (size: 24)
 */
export interface CPS_URLS {
  /** Windows.Win32.Foundation.PWSTR */
  pszURL: string | null | Uint8Array | Uint16Array;
  /** ptr */
  pAlgorithm: Deno.PointerValue | Uint8Array;
  /** ptr */
  pDigest: Deno.PointerValue | Uint8Array;
}

export const sizeofCPS_URLS = 24;

export function allocCPS_URLS(data?: Partial<CPS_URLS>): Uint8Array {
  const buf = new Uint8Array(sizeofCPS_URLS);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszURL !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszURL);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.pAlgorithm !== undefined) view.setBigUint64(8, data.pAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pAlgorithm))), true);
  // 0x10: pointer
  if (data?.pDigest !== undefined) view.setBigUint64(16, data.pDigest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pDigest))), true);
  return buf;
}

export class CPS_URLSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszURL(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pDigest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszURL(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set pAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pDigest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY95_QUALIFIER1 (size: 40)
 */
export interface CERT_POLICY95_QUALIFIER1 {
  /** Windows.Win32.Foundation.PWSTR */
  pszPracticesReference: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PSTR */
  pszNoticeIdentifier: string | null | Uint8Array;
  /** Windows.Win32.Foundation.PSTR */
  pszNSINoticeIdentifier: string | null | Uint8Array;
  /** u32 */
  cCPSURLs: number;
  /** ptr */
  rgCPSURLs: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_POLICY95_QUALIFIER1 = 40;

export function allocCERT_POLICY95_QUALIFIER1(data?: Partial<CERT_POLICY95_QUALIFIER1>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY95_QUALIFIER1);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszPracticesReference !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pszPracticesReference);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pszNoticeIdentifier !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszNoticeIdentifier);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pszNSINoticeIdentifier !== undefined) {
    (buf as any)._f16 = util.pstrToFfi(data.pszNSINoticeIdentifier);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: u32
  if (data?.cCPSURLs !== undefined) view.setUint32(24, Number(data.cCPSURLs), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgCPSURLs !== undefined) view.setBigUint64(32, data.rgCPSURLs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCPSURLs))), true);
  return buf;
}

export class CERT_POLICY95_QUALIFIER1View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszPracticesReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pszNoticeIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pszNSINoticeIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cCPSURLs(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgCPSURLs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszPracticesReference(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pszNoticeIdentifier(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pszNSINoticeIdentifier(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: u32
  set cCPSURLs(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgCPSURLs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_MAPPING (size: 16)
 */
export interface CERT_POLICY_MAPPING {
  /** Windows.Win32.Foundation.PSTR */
  pszIssuerDomainPolicy: string | null | Uint8Array;
  /** Windows.Win32.Foundation.PSTR */
  pszSubjectDomainPolicy: string | null | Uint8Array;
}

export const sizeofCERT_POLICY_MAPPING = 16;

export function allocCERT_POLICY_MAPPING(data?: Partial<CERT_POLICY_MAPPING>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_MAPPING);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszIssuerDomainPolicy !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszIssuerDomainPolicy);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pszSubjectDomainPolicy !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszSubjectDomainPolicy);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CERT_POLICY_MAPPINGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszIssuerDomainPolicy(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pszSubjectDomainPolicy(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszIssuerDomainPolicy(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pszSubjectDomainPolicy(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_MAPPINGS_INFO (size: 16)
 */
export interface CERT_POLICY_MAPPINGS_INFO {
  /** u32 */
  cPolicyMapping: number;
  /** ptr */
  rgPolicyMapping: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_POLICY_MAPPINGS_INFO = 16;

export function allocCERT_POLICY_MAPPINGS_INFO(data?: Partial<CERT_POLICY_MAPPINGS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_MAPPINGS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cPolicyMapping !== undefined) view.setUint32(0, Number(data.cPolicyMapping), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgPolicyMapping !== undefined) view.setBigUint64(8, data.rgPolicyMapping === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgPolicyMapping))), true);
  return buf;
}

export class CERT_POLICY_MAPPINGS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cPolicyMapping(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgPolicyMapping(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cPolicyMapping(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgPolicyMapping(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_POLICY_CONSTRAINTS_INFO (size: 16)
 */
export interface CERT_POLICY_CONSTRAINTS_INFO {
  /** Windows.Win32.Foundation.BOOL */
  fRequireExplicitPolicy: boolean;
  /** u32 */
  dwRequireExplicitPolicySkipCerts: number;
  /** Windows.Win32.Foundation.BOOL */
  fInhibitPolicyMapping: boolean;
  /** u32 */
  dwInhibitPolicyMappingSkipCerts: number;
}

export const sizeofCERT_POLICY_CONSTRAINTS_INFO = 16;

export function allocCERT_POLICY_CONSTRAINTS_INFO(data?: Partial<CERT_POLICY_CONSTRAINTS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_POLICY_CONSTRAINTS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.fRequireExplicitPolicy !== undefined) view.setInt32(0, Number(data.fRequireExplicitPolicy), true);
  // 0x04: u32
  if (data?.dwRequireExplicitPolicySkipCerts !== undefined) view.setUint32(4, Number(data.dwRequireExplicitPolicySkipCerts), true);
  // 0x08: i32
  if (data?.fInhibitPolicyMapping !== undefined) view.setInt32(8, Number(data.fInhibitPolicyMapping), true);
  // 0x0c: u32
  if (data?.dwInhibitPolicyMappingSkipCerts !== undefined) view.setUint32(12, Number(data.dwInhibitPolicyMappingSkipCerts), true);
  return buf;
}

export class CERT_POLICY_CONSTRAINTS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get fRequireExplicitPolicy(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: u32
  get dwRequireExplicitPolicySkipCerts(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get fInhibitPolicyMapping(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: u32
  get dwInhibitPolicyMappingSkipCerts(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: i32
  set fRequireExplicitPolicy(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: u32
  set dwRequireExplicitPolicySkipCerts(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set fInhibitPolicyMapping(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: u32
  set dwInhibitPolicyMappingSkipCerts(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY (size: 24)
 */
export interface CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** u32 */
  cValue: number;
  /** ptr */
  rgValue: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = 24;

export function allocCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY(data?: Partial<CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cValue !== undefined) view.setUint32(8, Number(data.cValue), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgValue !== undefined) view.setBigUint64(16, data.rgValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgValue))), true);
  return buf;
}

export class CRYPT_CONTENT_INFO_SEQUENCE_OF_ANYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cValue(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cValue(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CONTENT_INFO (size: 16)
 */
export interface CRYPT_CONTENT_INFO {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Content: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_CONTENT_INFO = 16;

export function allocCRYPT_CONTENT_INFO(data?: Partial<CRYPT_CONTENT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CONTENT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.Content !== undefined) view.setBigUint64(8, data.Content === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Content))), true);
  return buf;
}

export class CRYPT_CONTENT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Content(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set Content(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_SEQUENCE_OF_ANY (size: 16)
 */
export interface CRYPT_SEQUENCE_OF_ANY {
  /** u32 */
  cValue: number;
  /** ptr */
  rgValue: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_SEQUENCE_OF_ANY = 16;

export function allocCRYPT_SEQUENCE_OF_ANY(data?: Partial<CRYPT_SEQUENCE_OF_ANY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_SEQUENCE_OF_ANY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cValue !== undefined) view.setUint32(0, Number(data.cValue), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgValue !== undefined) view.setBigUint64(8, data.rgValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgValue))), true);
  return buf;
}

export class CRYPT_SEQUENCE_OF_ANYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cValue(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cValue(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_AUTHORITY_KEY_ID2_INFO (size: 24)
 */
export interface CERT_AUTHORITY_KEY_ID2_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  KeyId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_ALT_NAME_INFO */
  AuthorityCertIssuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  AuthorityCertSerialNumber: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_AUTHORITY_KEY_ID2_INFO = 24;

export function allocCERT_AUTHORITY_KEY_ID2_INFO(data?: Partial<CERT_AUTHORITY_KEY_ID2_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_AUTHORITY_KEY_ID2_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.KeyId !== undefined) view.setBigUint64(0, data.KeyId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyId))), true);
  // 0x08: pointer
  if (data?.AuthorityCertIssuer !== undefined) view.setBigUint64(8, data.AuthorityCertIssuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.AuthorityCertIssuer))), true);
  // 0x10: pointer
  if (data?.AuthorityCertSerialNumber !== undefined) view.setBigUint64(16, data.AuthorityCertSerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.AuthorityCertSerialNumber))), true);
  return buf;
}

export class CERT_AUTHORITY_KEY_ID2_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get KeyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get AuthorityCertIssuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get AuthorityCertSerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set KeyId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set AuthorityCertIssuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set AuthorityCertSerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_ACCESS_DESCRIPTION (size: 16)
 */
export interface CERT_ACCESS_DESCRIPTION {
  /** Windows.Win32.Foundation.PSTR */
  pszAccessMethod: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CERT_ALT_NAME_ENTRY */
  AccessLocation: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_ACCESS_DESCRIPTION = 16;

export function allocCERT_ACCESS_DESCRIPTION(data?: Partial<CERT_ACCESS_DESCRIPTION>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_ACCESS_DESCRIPTION);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszAccessMethod !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszAccessMethod);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.AccessLocation !== undefined) view.setBigUint64(8, data.AccessLocation === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.AccessLocation))), true);
  return buf;
}

export class CERT_ACCESS_DESCRIPTIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszAccessMethod(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get AccessLocation(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszAccessMethod(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set AccessLocation(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_AUTHORITY_INFO_ACCESS (size: 16)
 */
export interface CERT_AUTHORITY_INFO_ACCESS {
  /** u32 */
  cAccDescr: number;
  /** ptr */
  rgAccDescr: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_AUTHORITY_INFO_ACCESS = 16;

export function allocCERT_AUTHORITY_INFO_ACCESS(data?: Partial<CERT_AUTHORITY_INFO_ACCESS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_AUTHORITY_INFO_ACCESS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cAccDescr !== undefined) view.setUint32(0, Number(data.cAccDescr), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgAccDescr !== undefined) view.setBigUint64(8, data.rgAccDescr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAccDescr))), true);
  return buf;
}

export class CERT_AUTHORITY_INFO_ACCESSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cAccDescr(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgAccDescr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cAccDescr(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgAccDescr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_DIST_POINT_NAME (size: 16)
 */
export interface CRL_DIST_POINT_NAME {
  /** u32 */
  dwDistPointNameChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCRL_DIST_POINT_NAME = 16;

export function allocCRL_DIST_POINT_NAME(data?: Partial<CRL_DIST_POINT_NAME>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_DIST_POINT_NAME);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwDistPointNameChoice !== undefined) view.setUint32(0, Number(data.dwDistPointNameChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CRL_DIST_POINT_NAMEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwDistPointNameChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwDistPointNameChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_DIST_POINT (size: 24)
 */
export interface CRL_DIST_POINT {
  /** Windows.Win32.Security.Cryptography.CRL_DIST_POINT_NAME */
  DistPointName: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  ReasonFlags: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_ALT_NAME_INFO */
  CRLIssuer: Uint8Array | Deno.PointerValue;
}

export const sizeofCRL_DIST_POINT = 24;

export function allocCRL_DIST_POINT(data?: Partial<CRL_DIST_POINT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_DIST_POINT);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.DistPointName !== undefined) view.setBigUint64(0, data.DistPointName === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DistPointName))), true);
  // 0x08: pointer
  if (data?.ReasonFlags !== undefined) view.setBigUint64(8, data.ReasonFlags === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ReasonFlags))), true);
  // 0x10: pointer
  if (data?.CRLIssuer !== undefined) view.setBigUint64(16, data.CRLIssuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CRLIssuer))), true);
  return buf;
}

export class CRL_DIST_POINTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get DistPointName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get ReasonFlags(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get CRLIssuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set DistPointName(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set ReasonFlags(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set CRLIssuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_DIST_POINTS_INFO (size: 16)
 */
export interface CRL_DIST_POINTS_INFO {
  /** u32 */
  cDistPoint: number;
  /** ptr */
  rgDistPoint: Deno.PointerValue | Uint8Array;
}

export const sizeofCRL_DIST_POINTS_INFO = 16;

export function allocCRL_DIST_POINTS_INFO(data?: Partial<CRL_DIST_POINTS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_DIST_POINTS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cDistPoint !== undefined) view.setUint32(0, Number(data.cDistPoint), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgDistPoint !== undefined) view.setBigUint64(8, data.rgDistPoint === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgDistPoint))), true);
  return buf;
}

export class CRL_DIST_POINTS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cDistPoint(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgDistPoint(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cDistPoint(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgDistPoint(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CROSS_CERT_DIST_POINTS_INFO (size: 16)
 */
export interface CROSS_CERT_DIST_POINTS_INFO {
  /** u32 */
  dwSyncDeltaTime: number;
  /** u32 */
  cDistPoint: number;
  /** ptr */
  rgDistPoint: Deno.PointerValue | Uint8Array;
}

export const sizeofCROSS_CERT_DIST_POINTS_INFO = 16;

export function allocCROSS_CERT_DIST_POINTS_INFO(data?: Partial<CROSS_CERT_DIST_POINTS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCROSS_CERT_DIST_POINTS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSyncDeltaTime !== undefined) view.setUint32(0, Number(data.dwSyncDeltaTime), true);
  // 0x04: u32
  if (data?.cDistPoint !== undefined) view.setUint32(4, Number(data.cDistPoint), true);
  // 0x08: pointer
  if (data?.rgDistPoint !== undefined) view.setBigUint64(8, data.rgDistPoint === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgDistPoint))), true);
  return buf;
}

export class CROSS_CERT_DIST_POINTS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSyncDeltaTime(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cDistPoint(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgDistPoint(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSyncDeltaTime(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cDistPoint(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgDistPoint(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_PAIR (size: 16)
 */
export interface CERT_PAIR {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Forward: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Reverse: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_PAIR = 16;

export function allocCERT_PAIR(data?: Partial<CERT_PAIR>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_PAIR);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Forward !== undefined) view.setBigUint64(0, data.Forward === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Forward))), true);
  // 0x08: pointer
  if (data?.Reverse !== undefined) view.setBigUint64(8, data.Reverse === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Reverse))), true);
  return buf;
}

export class CERT_PAIRView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Forward(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Reverse(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Forward(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set Reverse(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_ISSUING_DIST_POINT (size: 32)
 */
export interface CRL_ISSUING_DIST_POINT {
  /** Windows.Win32.Security.Cryptography.CRL_DIST_POINT_NAME */
  DistPointName: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.BOOL */
  fOnlyContainsUserCerts: boolean;
  /** Windows.Win32.Foundation.BOOL */
  fOnlyContainsCACerts: boolean;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  OnlySomeReasonFlags: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.BOOL */
  fIndirectCRL: boolean;
}

export const sizeofCRL_ISSUING_DIST_POINT = 32;

export function allocCRL_ISSUING_DIST_POINT(data?: Partial<CRL_ISSUING_DIST_POINT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_ISSUING_DIST_POINT);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.DistPointName !== undefined) view.setBigUint64(0, data.DistPointName === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DistPointName))), true);
  // 0x08: i32
  if (data?.fOnlyContainsUserCerts !== undefined) view.setInt32(8, Number(data.fOnlyContainsUserCerts), true);
  // 0x0c: i32
  if (data?.fOnlyContainsCACerts !== undefined) view.setInt32(12, Number(data.fOnlyContainsCACerts), true);
  // 0x10: pointer
  if (data?.OnlySomeReasonFlags !== undefined) view.setBigUint64(16, data.OnlySomeReasonFlags === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.OnlySomeReasonFlags))), true);
  // 0x18: i32
  if (data?.fIndirectCRL !== undefined) view.setInt32(24, Number(data.fIndirectCRL), true);
  // 0x1c: pad4
  return buf;
}

export class CRL_ISSUING_DIST_POINTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get DistPointName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: i32
  get fOnlyContainsUserCerts(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: i32
  get fOnlyContainsCACerts(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: pointer
  get OnlySomeReasonFlags(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: i32
  get fIndirectCRL(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: pad4

  // 0x00: pointer
  set DistPointName(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: i32
  set fOnlyContainsUserCerts(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: i32
  set fOnlyContainsCACerts(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: pointer
  set OnlySomeReasonFlags(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: i32
  set fIndirectCRL(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_GENERAL_SUBTREE (size: 24)
 */
export interface CERT_GENERAL_SUBTREE {
  /** Windows.Win32.Security.Cryptography.CERT_ALT_NAME_ENTRY */
  Base: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwMinimum: number;
  /** Windows.Win32.Foundation.BOOL */
  fMaximum: boolean;
  /** u32 */
  dwMaximum: number;
}

export const sizeofCERT_GENERAL_SUBTREE = 24;

export function allocCERT_GENERAL_SUBTREE(data?: Partial<CERT_GENERAL_SUBTREE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_GENERAL_SUBTREE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Base !== undefined) view.setBigUint64(0, data.Base === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Base))), true);
  // 0x08: u32
  if (data?.dwMinimum !== undefined) view.setUint32(8, Number(data.dwMinimum), true);
  // 0x0c: i32
  if (data?.fMaximum !== undefined) view.setInt32(12, Number(data.fMaximum), true);
  // 0x10: u32
  if (data?.dwMaximum !== undefined) view.setUint32(16, Number(data.dwMaximum), true);
  // 0x14: pad4
  return buf;
}

export class CERT_GENERAL_SUBTREEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Base(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwMinimum(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: i32
  get fMaximum(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: u32
  get dwMaximum(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set Base(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set dwMinimum(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: i32
  set fMaximum(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: u32
  set dwMaximum(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_NAME_CONSTRAINTS_INFO (size: 32)
 */
export interface CERT_NAME_CONSTRAINTS_INFO {
  /** u32 */
  cPermittedSubtree: number;
  /** ptr */
  rgPermittedSubtree: Deno.PointerValue | Uint8Array;
  /** u32 */
  cExcludedSubtree: number;
  /** ptr */
  rgExcludedSubtree: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_NAME_CONSTRAINTS_INFO = 32;

export function allocCERT_NAME_CONSTRAINTS_INFO(data?: Partial<CERT_NAME_CONSTRAINTS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_NAME_CONSTRAINTS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cPermittedSubtree !== undefined) view.setUint32(0, Number(data.cPermittedSubtree), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgPermittedSubtree !== undefined) view.setBigUint64(8, data.rgPermittedSubtree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgPermittedSubtree))), true);
  // 0x10: u32
  if (data?.cExcludedSubtree !== undefined) view.setUint32(16, Number(data.cExcludedSubtree), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgExcludedSubtree !== undefined) view.setBigUint64(24, data.rgExcludedSubtree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExcludedSubtree))), true);
  return buf;
}

export class CERT_NAME_CONSTRAINTS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cPermittedSubtree(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgPermittedSubtree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cExcludedSubtree(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgExcludedSubtree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cPermittedSubtree(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgPermittedSubtree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cExcludedSubtree(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgExcludedSubtree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_DSS_PARAMETERS (size: 24)
 */
export interface CERT_DSS_PARAMETERS {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  p: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  q: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  g: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_DSS_PARAMETERS = 24;

export function allocCERT_DSS_PARAMETERS(data?: Partial<CERT_DSS_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_DSS_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.p !== undefined) view.setBigUint64(0, data.p === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.p))), true);
  // 0x08: pointer
  if (data?.q !== undefined) view.setBigUint64(8, data.q === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.q))), true);
  // 0x10: pointer
  if (data?.g !== undefined) view.setBigUint64(16, data.g === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.g))), true);
  return buf;
}

export class CERT_DSS_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get p(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get q(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get g(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set p(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set q(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set g(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_DH_PARAMETERS (size: 16)
 */
export interface CERT_DH_PARAMETERS {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  p: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  g: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_DH_PARAMETERS = 16;

export function allocCERT_DH_PARAMETERS(data?: Partial<CERT_DH_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_DH_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.p !== undefined) view.setBigUint64(0, data.p === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.p))), true);
  // 0x08: pointer
  if (data?.g !== undefined) view.setBigUint64(8, data.g === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.g))), true);
  return buf;
}

export class CERT_DH_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get p(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get g(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set p(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set g(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_ECC_SIGNATURE (size: 16)
 */
export interface CERT_ECC_SIGNATURE {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  r: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  s: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_ECC_SIGNATURE = 16;

export function allocCERT_ECC_SIGNATURE(data?: Partial<CERT_ECC_SIGNATURE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_ECC_SIGNATURE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.r !== undefined) view.setBigUint64(0, data.r === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.r))), true);
  // 0x08: pointer
  if (data?.s !== undefined) view.setBigUint64(8, data.s === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.s))), true);
  return buf;
}

export class CERT_ECC_SIGNATUREView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get r(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get s(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set r(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set s(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_X942_DH_VALIDATION_PARAMS (size: 16)
 */
export interface CERT_X942_DH_VALIDATION_PARAMS {
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  seed: Uint8Array | Deno.PointerValue;
  /** u32 */
  pgenCounter: number;
}

export const sizeofCERT_X942_DH_VALIDATION_PARAMS = 16;

export function allocCERT_X942_DH_VALIDATION_PARAMS(data?: Partial<CERT_X942_DH_VALIDATION_PARAMS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_X942_DH_VALIDATION_PARAMS);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.seed !== undefined) view.setBigUint64(0, data.seed === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.seed))), true);
  // 0x08: u32
  if (data?.pgenCounter !== undefined) view.setUint32(8, Number(data.pgenCounter), true);
  // 0x0c: pad4
  return buf;
}

export class CERT_X942_DH_VALIDATION_PARAMSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get seed(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get pgenCounter(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: pointer
  set seed(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set pgenCounter(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_X942_DH_PARAMETERS (size: 40)
 */
export interface CERT_X942_DH_PARAMETERS {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  p: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  g: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  q: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  j: Uint8Array | Deno.PointerValue;
  /** ptr */
  pValidationParams: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_X942_DH_PARAMETERS = 40;

export function allocCERT_X942_DH_PARAMETERS(data?: Partial<CERT_X942_DH_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_X942_DH_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.p !== undefined) view.setBigUint64(0, data.p === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.p))), true);
  // 0x08: pointer
  if (data?.g !== undefined) view.setBigUint64(8, data.g === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.g))), true);
  // 0x10: pointer
  if (data?.q !== undefined) view.setBigUint64(16, data.q === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.q))), true);
  // 0x18: pointer
  if (data?.j !== undefined) view.setBigUint64(24, data.j === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.j))), true);
  // 0x20: pointer
  if (data?.pValidationParams !== undefined) view.setBigUint64(32, data.pValidationParams === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pValidationParams))), true);
  return buf;
}

export class CERT_X942_DH_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get p(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get g(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get q(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get j(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pValidationParams(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set p(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set g(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set q(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set j(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pValidationParams(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_X942_OTHER_INFO (size: 32)
 */
export interface CRYPT_X942_OTHER_INFO {
  /** Windows.Win32.Foundation.PSTR */
  pszContentEncryptionObjId: string | null | Uint8Array;
  /** array */
  rgbCounter: Deno.PointerValue;
  /** array */
  rgbKeyLength: Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  PubInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_X942_OTHER_INFO = 32;

export function allocCRYPT_X942_OTHER_INFO(data?: Partial<CRYPT_X942_OTHER_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_X942_OTHER_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszContentEncryptionObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszContentEncryptionObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.rgbCounter !== undefined) view.setBigUint64(8, data.rgbCounter === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgbCounter))), true);
  // 0x10: pointer
  if (data?.rgbKeyLength !== undefined) view.setBigUint64(16, data.rgbKeyLength === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgbKeyLength))), true);
  // 0x18: pointer
  if (data?.PubInfo !== undefined) view.setBigUint64(24, data.PubInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PubInfo))), true);
  return buf;
}

export class CRYPT_X942_OTHER_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszContentEncryptionObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get rgbCounter(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get rgbKeyLength(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get PubInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszContentEncryptionObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set rgbCounter(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set rgbKeyLength(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set PubInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ECC_CMS_SHARED_INFO (size: 24)
 */
export interface CRYPT_ECC_CMS_SHARED_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  Algorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EntityUInfo: Uint8Array | Deno.PointerValue;
  /** array */
  rgbSuppPubInfo: Deno.PointerValue;
}

export const sizeofCRYPT_ECC_CMS_SHARED_INFO = 24;

export function allocCRYPT_ECC_CMS_SHARED_INFO(data?: Partial<CRYPT_ECC_CMS_SHARED_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ECC_CMS_SHARED_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Algorithm !== undefined) view.setBigUint64(0, data.Algorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Algorithm))), true);
  // 0x08: pointer
  if (data?.EntityUInfo !== undefined) view.setBigUint64(8, data.EntityUInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EntityUInfo))), true);
  // 0x10: pointer
  if (data?.rgbSuppPubInfo !== undefined) view.setBigUint64(16, data.rgbSuppPubInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgbSuppPubInfo))), true);
  return buf;
}

export class CRYPT_ECC_CMS_SHARED_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Algorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get EntityUInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get rgbSuppPubInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Algorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set EntityUInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set rgbSuppPubInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_RC2_CBC_PARAMETERS (size: 16)
 */
export interface CRYPT_RC2_CBC_PARAMETERS {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Foundation.BOOL */
  fIV: boolean;
  /** array */
  rgbIV: Deno.PointerValue;
}

export const sizeofCRYPT_RC2_CBC_PARAMETERS = 16;

export function allocCRYPT_RC2_CBC_PARAMETERS(data?: Partial<CRYPT_RC2_CBC_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_RC2_CBC_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: i32
  if (data?.fIV !== undefined) view.setInt32(4, Number(data.fIV), true);
  // 0x08: pointer
  if (data?.rgbIV !== undefined) view.setBigUint64(8, data.rgbIV === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgbIV))), true);
  return buf;
}

export class CRYPT_RC2_CBC_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get fIV(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: pointer
  get rgbIV(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set fIV(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: pointer
  set rgbIV(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_SMIME_CAPABILITY (size: 16)
 */
export interface CRYPT_SMIME_CAPABILITY {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Parameters: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_SMIME_CAPABILITY = 16;

export function allocCRYPT_SMIME_CAPABILITY(data?: Partial<CRYPT_SMIME_CAPABILITY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_SMIME_CAPABILITY);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.Parameters !== undefined) view.setBigUint64(8, data.Parameters === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Parameters))), true);
  return buf;
}

export class CRYPT_SMIME_CAPABILITYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Parameters(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set Parameters(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_SMIME_CAPABILITIES (size: 16)
 */
export interface CRYPT_SMIME_CAPABILITIES {
  /** u32 */
  cCapability: number;
  /** ptr */
  rgCapability: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_SMIME_CAPABILITIES = 16;

export function allocCRYPT_SMIME_CAPABILITIES(data?: Partial<CRYPT_SMIME_CAPABILITIES>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_SMIME_CAPABILITIES);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cCapability !== undefined) view.setUint32(0, Number(data.cCapability), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgCapability !== undefined) view.setBigUint64(8, data.rgCapability === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCapability))), true);
  return buf;
}

export class CRYPT_SMIME_CAPABILITIESView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cCapability(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgCapability(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cCapability(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgCapability(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_QC_STATEMENT (size: 16)
 */
export interface CERT_QC_STATEMENT {
  /** Windows.Win32.Foundation.PSTR */
  pszStatementId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  StatementInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_QC_STATEMENT = 16;

export function allocCERT_QC_STATEMENT(data?: Partial<CERT_QC_STATEMENT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_QC_STATEMENT);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszStatementId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszStatementId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.StatementInfo !== undefined) view.setBigUint64(8, data.StatementInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.StatementInfo))), true);
  return buf;
}

export class CERT_QC_STATEMENTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszStatementId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get StatementInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszStatementId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set StatementInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_QC_STATEMENTS_EXT_INFO (size: 16)
 */
export interface CERT_QC_STATEMENTS_EXT_INFO {
  /** u32 */
  cStatement: number;
  /** ptr */
  rgStatement: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_QC_STATEMENTS_EXT_INFO = 16;

export function allocCERT_QC_STATEMENTS_EXT_INFO(data?: Partial<CERT_QC_STATEMENTS_EXT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_QC_STATEMENTS_EXT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cStatement !== undefined) view.setUint32(0, Number(data.cStatement), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgStatement !== undefined) view.setBigUint64(8, data.rgStatement === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgStatement))), true);
  return buf;
}

export class CERT_QC_STATEMENTS_EXT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cStatement(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgStatement(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cStatement(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgStatement(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_MASK_GEN_ALGORITHM (size: 16)
 */
export interface CRYPT_MASK_GEN_ALGORITHM {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_MASK_GEN_ALGORITHM = 16;

export function allocCRYPT_MASK_GEN_ALGORITHM(data?: Partial<CRYPT_MASK_GEN_ALGORITHM>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_MASK_GEN_ALGORITHM);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(8, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  return buf;
}

export class CRYPT_MASK_GEN_ALGORITHMView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_RSA_SSA_PSS_PARAMETERS (size: 24)
 */
export interface CRYPT_RSA_SSA_PSS_PARAMETERS {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_MASK_GEN_ALGORITHM */
  MaskGenAlgorithm: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwSaltLength: number;
  /** u32 */
  dwTrailerField: number;
}

export const sizeofCRYPT_RSA_SSA_PSS_PARAMETERS = 24;

export function allocCRYPT_RSA_SSA_PSS_PARAMETERS(data?: Partial<CRYPT_RSA_SSA_PSS_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_RSA_SSA_PSS_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(0, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x08: pointer
  if (data?.MaskGenAlgorithm !== undefined) view.setBigUint64(8, data.MaskGenAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.MaskGenAlgorithm))), true);
  // 0x10: u32
  if (data?.dwSaltLength !== undefined) view.setUint32(16, Number(data.dwSaltLength), true);
  // 0x14: u32
  if (data?.dwTrailerField !== undefined) view.setUint32(20, Number(data.dwTrailerField), true);
  return buf;
}

export class CRYPT_RSA_SSA_PSS_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get MaskGenAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwSaltLength(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwTrailerField(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set MaskGenAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwSaltLength(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwTrailerField(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PSOURCE_ALGORITHM (size: 16)
 */
export interface CRYPT_PSOURCE_ALGORITHM {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncodingParameters: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_PSOURCE_ALGORITHM = 16;

export function allocCRYPT_PSOURCE_ALGORITHM(data?: Partial<CRYPT_PSOURCE_ALGORITHM>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PSOURCE_ALGORITHM);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.EncodingParameters !== undefined) view.setBigUint64(8, data.EncodingParameters === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncodingParameters))), true);
  return buf;
}

export class CRYPT_PSOURCE_ALGORITHMView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get EncodingParameters(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set EncodingParameters(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_RSAES_OAEP_PARAMETERS (size: 24)
 */
export interface CRYPT_RSAES_OAEP_PARAMETERS {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_MASK_GEN_ALGORITHM */
  MaskGenAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_PSOURCE_ALGORITHM */
  PSourceAlgorithm: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_RSAES_OAEP_PARAMETERS = 24;

export function allocCRYPT_RSAES_OAEP_PARAMETERS(data?: Partial<CRYPT_RSAES_OAEP_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_RSAES_OAEP_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(0, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x08: pointer
  if (data?.MaskGenAlgorithm !== undefined) view.setBigUint64(8, data.MaskGenAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.MaskGenAlgorithm))), true);
  // 0x10: pointer
  if (data?.PSourceAlgorithm !== undefined) view.setBigUint64(16, data.PSourceAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PSourceAlgorithm))), true);
  return buf;
}

export class CRYPT_RSAES_OAEP_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get MaskGenAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get PSourceAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set MaskGenAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set PSourceAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_TAGGED_ATTRIBUTE (size: 16)
 */
export interface CMC_TAGGED_ATTRIBUTE {
  /** u32 */
  dwBodyPartID: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTE */
  Attribute: Uint8Array | Deno.PointerValue;
}

export const sizeofCMC_TAGGED_ATTRIBUTE = 16;

export function allocCMC_TAGGED_ATTRIBUTE(data?: Partial<CMC_TAGGED_ATTRIBUTE>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_TAGGED_ATTRIBUTE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwBodyPartID !== undefined) view.setUint32(0, Number(data.dwBodyPartID), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Attribute !== undefined) view.setBigUint64(8, data.Attribute === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Attribute))), true);
  return buf;
}

export class CMC_TAGGED_ATTRIBUTEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwBodyPartID(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Attribute(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwBodyPartID(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Attribute(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_TAGGED_CERT_REQUEST (size: 16)
 */
export interface CMC_TAGGED_CERT_REQUEST {
  /** u32 */
  dwBodyPartID: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SignedCertRequest: Uint8Array | Deno.PointerValue;
}

export const sizeofCMC_TAGGED_CERT_REQUEST = 16;

export function allocCMC_TAGGED_CERT_REQUEST(data?: Partial<CMC_TAGGED_CERT_REQUEST>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_TAGGED_CERT_REQUEST);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwBodyPartID !== undefined) view.setUint32(0, Number(data.dwBodyPartID), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SignedCertRequest !== undefined) view.setBigUint64(8, data.SignedCertRequest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignedCertRequest))), true);
  return buf;
}

export class CMC_TAGGED_CERT_REQUESTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwBodyPartID(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SignedCertRequest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwBodyPartID(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SignedCertRequest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_TAGGED_REQUEST (size: 16)
 */
export interface CMC_TAGGED_REQUEST {
  /** u32 */
  dwTaggedRequestChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCMC_TAGGED_REQUEST = 16;

export function allocCMC_TAGGED_REQUEST(data?: Partial<CMC_TAGGED_REQUEST>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_TAGGED_REQUEST);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwTaggedRequestChoice !== undefined) view.setUint32(0, Number(data.dwTaggedRequestChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CMC_TAGGED_REQUESTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwTaggedRequestChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwTaggedRequestChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_TAGGED_CONTENT_INFO (size: 16)
 */
export interface CMC_TAGGED_CONTENT_INFO {
  /** u32 */
  dwBodyPartID: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncodedContentInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCMC_TAGGED_CONTENT_INFO = 16;

export function allocCMC_TAGGED_CONTENT_INFO(data?: Partial<CMC_TAGGED_CONTENT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_TAGGED_CONTENT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwBodyPartID !== undefined) view.setUint32(0, Number(data.dwBodyPartID), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.EncodedContentInfo !== undefined) view.setBigUint64(8, data.EncodedContentInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncodedContentInfo))), true);
  return buf;
}

export class CMC_TAGGED_CONTENT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwBodyPartID(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get EncodedContentInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwBodyPartID(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set EncodedContentInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_TAGGED_OTHER_MSG (size: 24)
 */
export interface CMC_TAGGED_OTHER_MSG {
  /** u32 */
  dwBodyPartID: number;
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Value: Uint8Array | Deno.PointerValue;
}

export const sizeofCMC_TAGGED_OTHER_MSG = 24;

export function allocCMC_TAGGED_OTHER_MSG(data?: Partial<CMC_TAGGED_OTHER_MSG>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_TAGGED_OTHER_MSG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwBodyPartID !== undefined) view.setUint32(0, Number(data.dwBodyPartID), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.Value !== undefined) view.setBigUint64(16, data.Value === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Value))), true);
  return buf;
}

export class CMC_TAGGED_OTHER_MSGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwBodyPartID(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Value(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwBodyPartID(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set Value(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_DATA_INFO (size: 64)
 */
export interface CMC_DATA_INFO {
  /** u32 */
  cTaggedAttribute: number;
  /** ptr */
  rgTaggedAttribute: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTaggedRequest: number;
  /** ptr */
  rgTaggedRequest: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTaggedContentInfo: number;
  /** ptr */
  rgTaggedContentInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTaggedOtherMsg: number;
  /** ptr */
  rgTaggedOtherMsg: Deno.PointerValue | Uint8Array;
}

export const sizeofCMC_DATA_INFO = 64;

export function allocCMC_DATA_INFO(data?: Partial<CMC_DATA_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_DATA_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cTaggedAttribute !== undefined) view.setUint32(0, Number(data.cTaggedAttribute), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgTaggedAttribute !== undefined) view.setBigUint64(8, data.rgTaggedAttribute === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTaggedAttribute))), true);
  // 0x10: u32
  if (data?.cTaggedRequest !== undefined) view.setUint32(16, Number(data.cTaggedRequest), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgTaggedRequest !== undefined) view.setBigUint64(24, data.rgTaggedRequest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTaggedRequest))), true);
  // 0x20: u32
  if (data?.cTaggedContentInfo !== undefined) view.setUint32(32, Number(data.cTaggedContentInfo), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgTaggedContentInfo !== undefined) view.setBigUint64(40, data.rgTaggedContentInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTaggedContentInfo))), true);
  // 0x30: u32
  if (data?.cTaggedOtherMsg !== undefined) view.setUint32(48, Number(data.cTaggedOtherMsg), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.rgTaggedOtherMsg !== undefined) view.setBigUint64(56, data.rgTaggedOtherMsg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTaggedOtherMsg))), true);
  return buf;
}

export class CMC_DATA_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cTaggedAttribute(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgTaggedAttribute(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cTaggedRequest(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgTaggedRequest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cTaggedContentInfo(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgTaggedContentInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cTaggedOtherMsg(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get rgTaggedOtherMsg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cTaggedAttribute(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgTaggedAttribute(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cTaggedRequest(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgTaggedRequest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cTaggedContentInfo(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgTaggedContentInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cTaggedOtherMsg(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set rgTaggedOtherMsg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_RESPONSE_INFO (size: 48)
 */
export interface CMC_RESPONSE_INFO {
  /** u32 */
  cTaggedAttribute: number;
  /** ptr */
  rgTaggedAttribute: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTaggedContentInfo: number;
  /** ptr */
  rgTaggedContentInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTaggedOtherMsg: number;
  /** ptr */
  rgTaggedOtherMsg: Deno.PointerValue | Uint8Array;
}

export const sizeofCMC_RESPONSE_INFO = 48;

export function allocCMC_RESPONSE_INFO(data?: Partial<CMC_RESPONSE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_RESPONSE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cTaggedAttribute !== undefined) view.setUint32(0, Number(data.cTaggedAttribute), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgTaggedAttribute !== undefined) view.setBigUint64(8, data.rgTaggedAttribute === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTaggedAttribute))), true);
  // 0x10: u32
  if (data?.cTaggedContentInfo !== undefined) view.setUint32(16, Number(data.cTaggedContentInfo), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgTaggedContentInfo !== undefined) view.setBigUint64(24, data.rgTaggedContentInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTaggedContentInfo))), true);
  // 0x20: u32
  if (data?.cTaggedOtherMsg !== undefined) view.setUint32(32, Number(data.cTaggedOtherMsg), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgTaggedOtherMsg !== undefined) view.setBigUint64(40, data.rgTaggedOtherMsg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTaggedOtherMsg))), true);
  return buf;
}

export class CMC_RESPONSE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cTaggedAttribute(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgTaggedAttribute(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cTaggedContentInfo(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgTaggedContentInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cTaggedOtherMsg(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgTaggedOtherMsg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cTaggedAttribute(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgTaggedAttribute(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cTaggedContentInfo(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgTaggedContentInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cTaggedOtherMsg(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgTaggedOtherMsg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_PEND_INFO (size: 16)
 */
export interface CMC_PEND_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  PendToken: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  PendTime: Uint8Array | Deno.PointerValue;
}

export const sizeofCMC_PEND_INFO = 16;

export function allocCMC_PEND_INFO(data?: Partial<CMC_PEND_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_PEND_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.PendToken !== undefined) view.setBigUint64(0, data.PendToken === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PendToken))), true);
  // 0x08: pointer
  if (data?.PendTime !== undefined) view.setBigUint64(8, data.PendTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PendTime))), true);
  return buf;
}

export class CMC_PEND_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get PendToken(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get PendTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set PendToken(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set PendTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_STATUS_INFO (size: 40)
 */
export interface CMC_STATUS_INFO {
  /** u32 */
  dwStatus: number;
  /** u32 */
  cBodyList: number;
  /** ptr */
  rgdwBodyList: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszStatusString: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwOtherInfoChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCMC_STATUS_INFO = 40;

export function allocCMC_STATUS_INFO(data?: Partial<CMC_STATUS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_STATUS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwStatus !== undefined) view.setUint32(0, Number(data.dwStatus), true);
  // 0x04: u32
  if (data?.cBodyList !== undefined) view.setUint32(4, Number(data.cBodyList), true);
  // 0x08: pointer
  if (data?.rgdwBodyList !== undefined) view.setBigUint64(8, data.rgdwBodyList === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgdwBodyList))), true);
  // 0x10: buffer
  if (data?.pwszStatusString !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszStatusString);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: u32
  if (data?.dwOtherInfoChoice !== undefined) view.setUint32(24, Number(data.dwOtherInfoChoice), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(32, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CMC_STATUS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwStatus(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cBodyList(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgdwBodyList(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszStatusString(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwOtherInfoChoice(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwStatus(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cBodyList(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgdwBodyList(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set pwszStatusString(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: u32
  set dwOtherInfoChoice(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_ADD_EXTENSIONS_INFO (size: 32)
 */
export interface CMC_ADD_EXTENSIONS_INFO {
  /** u32 */
  dwCmcDataReference: number;
  /** u32 */
  cCertReference: number;
  /** ptr */
  rgdwCertReference: Deno.PointerValue | Uint8Array;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCMC_ADD_EXTENSIONS_INFO = 32;

export function allocCMC_ADD_EXTENSIONS_INFO(data?: Partial<CMC_ADD_EXTENSIONS_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_ADD_EXTENSIONS_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwCmcDataReference !== undefined) view.setUint32(0, Number(data.dwCmcDataReference), true);
  // 0x04: u32
  if (data?.cCertReference !== undefined) view.setUint32(4, Number(data.cCertReference), true);
  // 0x08: pointer
  if (data?.rgdwCertReference !== undefined) view.setBigUint64(8, data.rgdwCertReference === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgdwCertReference))), true);
  // 0x10: u32
  if (data?.cExtension !== undefined) view.setUint32(16, Number(data.cExtension), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(24, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CMC_ADD_EXTENSIONS_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwCmcDataReference(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cCertReference(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgdwCertReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cExtension(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwCmcDataReference(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cCertReference(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgdwCertReference(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cExtension(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMC_ADD_ATTRIBUTES_INFO (size: 32)
 */
export interface CMC_ADD_ATTRIBUTES_INFO {
  /** u32 */
  dwCmcDataReference: number;
  /** u32 */
  cCertReference: number;
  /** ptr */
  rgdwCertReference: Deno.PointerValue | Uint8Array;
  /** u32 */
  cAttribute: number;
  /** ptr */
  rgAttribute: Deno.PointerValue | Uint8Array;
}

export const sizeofCMC_ADD_ATTRIBUTES_INFO = 32;

export function allocCMC_ADD_ATTRIBUTES_INFO(data?: Partial<CMC_ADD_ATTRIBUTES_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMC_ADD_ATTRIBUTES_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwCmcDataReference !== undefined) view.setUint32(0, Number(data.dwCmcDataReference), true);
  // 0x04: u32
  if (data?.cCertReference !== undefined) view.setUint32(4, Number(data.cCertReference), true);
  // 0x08: pointer
  if (data?.rgdwCertReference !== undefined) view.setBigUint64(8, data.rgdwCertReference === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgdwCertReference))), true);
  // 0x10: u32
  if (data?.cAttribute !== undefined) view.setUint32(16, Number(data.cAttribute), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgAttribute !== undefined) view.setBigUint64(24, data.rgAttribute === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAttribute))), true);
  return buf;
}

export class CMC_ADD_ATTRIBUTES_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwCmcDataReference(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cCertReference(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgdwCertReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cAttribute(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgAttribute(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwCmcDataReference(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cCertReference(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgdwCertReference(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cAttribute(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgAttribute(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_TEMPLATE_EXT (size: 24)
 */
export interface CERT_TEMPLATE_EXT {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** u32 */
  dwMajorVersion: number;
  /** Windows.Win32.Foundation.BOOL */
  fMinorVersion: boolean;
  /** u32 */
  dwMinorVersion: number;
}

export const sizeofCERT_TEMPLATE_EXT = 24;

export function allocCERT_TEMPLATE_EXT(data?: Partial<CERT_TEMPLATE_EXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_TEMPLATE_EXT);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.dwMajorVersion !== undefined) view.setUint32(8, Number(data.dwMajorVersion), true);
  // 0x0c: i32
  if (data?.fMinorVersion !== undefined) view.setInt32(12, Number(data.fMinorVersion), true);
  // 0x10: u32
  if (data?.dwMinorVersion !== undefined) view.setUint32(16, Number(data.dwMinorVersion), true);
  // 0x14: pad4
  return buf;
}

export class CERT_TEMPLATE_EXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwMajorVersion(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: i32
  get fMinorVersion(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: u32
  get dwMinorVersion(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set dwMajorVersion(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: i32
  set fMinorVersion(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: u32
  set dwMinorVersion(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_HASHED_URL (size: 24)
 */
export interface CERT_HASHED_URL {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Hash: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pwszUrl: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_HASHED_URL = 24;

export function allocCERT_HASHED_URL(data?: Partial<CERT_HASHED_URL>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_HASHED_URL);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(0, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x08: pointer
  if (data?.Hash !== undefined) view.setBigUint64(8, data.Hash === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Hash))), true);
  // 0x10: buffer
  if (data?.pwszUrl !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszUrl);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class CERT_HASHED_URLView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Hash(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set Hash(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set pwszUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_DETAILS (size: 24)
 */
export interface CERT_LOGOTYPE_DETAILS {
  /** Windows.Win32.Foundation.PWSTR */
  pwszMimeType: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cHashedUrl: number;
  /** ptr */
  rgHashedUrl: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_LOGOTYPE_DETAILS = 24;

export function allocCERT_LOGOTYPE_DETAILS(data?: Partial<CERT_LOGOTYPE_DETAILS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_DETAILS);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pwszMimeType !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pwszMimeType);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.cHashedUrl !== undefined) view.setUint32(8, Number(data.cHashedUrl), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgHashedUrl !== undefined) view.setBigUint64(16, data.rgHashedUrl === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgHashedUrl))), true);
  return buf;
}

export class CERT_LOGOTYPE_DETAILSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pwszMimeType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cHashedUrl(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgHashedUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pwszMimeType(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set cHashedUrl(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgHashedUrl(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_REFERENCE (size: 16)
 */
export interface CERT_LOGOTYPE_REFERENCE {
  /** u32 */
  cHashedUrl: number;
  /** ptr */
  rgHashedUrl: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_LOGOTYPE_REFERENCE = 16;

export function allocCERT_LOGOTYPE_REFERENCE(data?: Partial<CERT_LOGOTYPE_REFERENCE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_REFERENCE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cHashedUrl !== undefined) view.setUint32(0, Number(data.cHashedUrl), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgHashedUrl !== undefined) view.setBigUint64(8, data.rgHashedUrl === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgHashedUrl))), true);
  return buf;
}

export class CERT_LOGOTYPE_REFERENCEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cHashedUrl(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgHashedUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cHashedUrl(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgHashedUrl(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_IMAGE_INFO (size: 40)
 */
export interface CERT_LOGOTYPE_IMAGE_INFO {
  /** Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_IMAGE_INFO_TYPE */
  dwLogotypeImageInfoChoice: CERT_LOGOTYPE_IMAGE_INFO_TYPE;
  /** u32 */
  dwFileSize: number;
  /** u32 */
  dwXSize: number;
  /** u32 */
  dwYSize: number;
  /** Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_CHOICE */
  dwLogotypeImageResolutionChoice: CERT_LOGOTYPE_CHOICE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pwszLanguage: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_LOGOTYPE_IMAGE_INFO = 40;

export function allocCERT_LOGOTYPE_IMAGE_INFO(data?: Partial<CERT_LOGOTYPE_IMAGE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_IMAGE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwLogotypeImageInfoChoice !== undefined) view.setUint32(0, Number(data.dwLogotypeImageInfoChoice), true);
  // 0x04: u32
  if (data?.dwFileSize !== undefined) view.setUint32(4, Number(data.dwFileSize), true);
  // 0x08: u32
  if (data?.dwXSize !== undefined) view.setUint32(8, Number(data.dwXSize), true);
  // 0x0c: u32
  if (data?.dwYSize !== undefined) view.setUint32(12, Number(data.dwYSize), true);
  // 0x10: u32
  if (data?.dwLogotypeImageResolutionChoice !== undefined) view.setUint32(16, Number(data.dwLogotypeImageResolutionChoice), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(24, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x20: buffer
  if (data?.pwszLanguage !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.pwszLanguage);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  return buf;
}

export class CERT_LOGOTYPE_IMAGE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwLogotypeImageInfoChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwFileSize(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwXSize(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwYSize(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get dwLogotypeImageResolutionChoice(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pwszLanguage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwLogotypeImageInfoChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwFileSize(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwXSize(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwYSize(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set dwLogotypeImageResolutionChoice(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: buffer
  set pwszLanguage(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_IMAGE (size: 16)
 */
export interface CERT_LOGOTYPE_IMAGE {
  /** Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_DETAILS */
  LogotypeDetails: Uint8Array | Deno.PointerValue;
  /** ptr */
  pLogotypeImageInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_LOGOTYPE_IMAGE = 16;

export function allocCERT_LOGOTYPE_IMAGE(data?: Partial<CERT_LOGOTYPE_IMAGE>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_IMAGE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.LogotypeDetails !== undefined) view.setBigUint64(0, data.LogotypeDetails === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.LogotypeDetails))), true);
  // 0x08: pointer
  if (data?.pLogotypeImageInfo !== undefined) view.setBigUint64(8, data.pLogotypeImageInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pLogotypeImageInfo))), true);
  return buf;
}

export class CERT_LOGOTYPE_IMAGEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get LogotypeDetails(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pLogotypeImageInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set LogotypeDetails(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pLogotypeImageInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_AUDIO_INFO (size: 24)
 */
export interface CERT_LOGOTYPE_AUDIO_INFO {
  /** u32 */
  dwFileSize: number;
  /** u32 */
  dwPlayTime: number;
  /** u32 */
  dwChannels: number;
  /** u32 */
  dwSampleRate: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszLanguage: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_LOGOTYPE_AUDIO_INFO = 24;

export function allocCERT_LOGOTYPE_AUDIO_INFO(data?: Partial<CERT_LOGOTYPE_AUDIO_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_AUDIO_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwFileSize !== undefined) view.setUint32(0, Number(data.dwFileSize), true);
  // 0x04: u32
  if (data?.dwPlayTime !== undefined) view.setUint32(4, Number(data.dwPlayTime), true);
  // 0x08: u32
  if (data?.dwChannels !== undefined) view.setUint32(8, Number(data.dwChannels), true);
  // 0x0c: u32
  if (data?.dwSampleRate !== undefined) view.setUint32(12, Number(data.dwSampleRate), true);
  // 0x10: buffer
  if (data?.pwszLanguage !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszLanguage);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class CERT_LOGOTYPE_AUDIO_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwFileSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwPlayTime(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwChannels(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwSampleRate(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: buffer
  get pwszLanguage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwFileSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwPlayTime(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwChannels(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwSampleRate(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: buffer
  set pwszLanguage(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_AUDIO (size: 16)
 */
export interface CERT_LOGOTYPE_AUDIO {
  /** Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_DETAILS */
  LogotypeDetails: Uint8Array | Deno.PointerValue;
  /** ptr */
  pLogotypeAudioInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_LOGOTYPE_AUDIO = 16;

export function allocCERT_LOGOTYPE_AUDIO(data?: Partial<CERT_LOGOTYPE_AUDIO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_AUDIO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.LogotypeDetails !== undefined) view.setBigUint64(0, data.LogotypeDetails === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.LogotypeDetails))), true);
  // 0x08: pointer
  if (data?.pLogotypeAudioInfo !== undefined) view.setBigUint64(8, data.pLogotypeAudioInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pLogotypeAudioInfo))), true);
  return buf;
}

export class CERT_LOGOTYPE_AUDIOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get LogotypeDetails(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pLogotypeAudioInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set LogotypeDetails(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pLogotypeAudioInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_DATA (size: 32)
 */
export interface CERT_LOGOTYPE_DATA {
  /** u32 */
  cLogotypeImage: number;
  /** ptr */
  rgLogotypeImage: Deno.PointerValue | Uint8Array;
  /** u32 */
  cLogotypeAudio: number;
  /** ptr */
  rgLogotypeAudio: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_LOGOTYPE_DATA = 32;

export function allocCERT_LOGOTYPE_DATA(data?: Partial<CERT_LOGOTYPE_DATA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_DATA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cLogotypeImage !== undefined) view.setUint32(0, Number(data.cLogotypeImage), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgLogotypeImage !== undefined) view.setBigUint64(8, data.rgLogotypeImage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgLogotypeImage))), true);
  // 0x10: u32
  if (data?.cLogotypeAudio !== undefined) view.setUint32(16, Number(data.cLogotypeAudio), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgLogotypeAudio !== undefined) view.setBigUint64(24, data.rgLogotypeAudio === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgLogotypeAudio))), true);
  return buf;
}

export class CERT_LOGOTYPE_DATAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cLogotypeImage(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgLogotypeImage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cLogotypeAudio(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgLogotypeAudio(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cLogotypeImage(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgLogotypeImage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cLogotypeAudio(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgLogotypeAudio(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_INFO (size: 16)
 */
export interface CERT_LOGOTYPE_INFO {
  /** Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_OPTION */
  dwLogotypeInfoChoice: CERT_LOGOTYPE_OPTION;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_LOGOTYPE_INFO = 16;

export function allocCERT_LOGOTYPE_INFO(data?: Partial<CERT_LOGOTYPE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwLogotypeInfoChoice !== undefined) view.setUint32(0, Number(data.dwLogotypeInfoChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CERT_LOGOTYPE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwLogotypeInfoChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwLogotypeInfoChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_OTHER_LOGOTYPE_INFO (size: 16)
 */
export interface CERT_OTHER_LOGOTYPE_INFO {
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_INFO */
  LogotypeInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_OTHER_LOGOTYPE_INFO = 16;

export function allocCERT_OTHER_LOGOTYPE_INFO(data?: Partial<CERT_OTHER_LOGOTYPE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_OTHER_LOGOTYPE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.LogotypeInfo !== undefined) view.setBigUint64(8, data.LogotypeInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.LogotypeInfo))), true);
  return buf;
}

export class CERT_OTHER_LOGOTYPE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get LogotypeInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set LogotypeInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LOGOTYPE_EXT_INFO (size: 48)
 */
export interface CERT_LOGOTYPE_EXT_INFO {
  /** u32 */
  cCommunityLogo: number;
  /** ptr */
  rgCommunityLogo: Deno.PointerValue | Uint8Array;
  /** ptr */
  pIssuerLogo: Deno.PointerValue | Uint8Array;
  /** ptr */
  pSubjectLogo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cOtherLogo: number;
  /** ptr */
  rgOtherLogo: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_LOGOTYPE_EXT_INFO = 48;

export function allocCERT_LOGOTYPE_EXT_INFO(data?: Partial<CERT_LOGOTYPE_EXT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LOGOTYPE_EXT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cCommunityLogo !== undefined) view.setUint32(0, Number(data.cCommunityLogo), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgCommunityLogo !== undefined) view.setBigUint64(8, data.rgCommunityLogo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCommunityLogo))), true);
  // 0x10: pointer
  if (data?.pIssuerLogo !== undefined) view.setBigUint64(16, data.pIssuerLogo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pIssuerLogo))), true);
  // 0x18: pointer
  if (data?.pSubjectLogo !== undefined) view.setBigUint64(24, data.pSubjectLogo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pSubjectLogo))), true);
  // 0x20: u32
  if (data?.cOtherLogo !== undefined) view.setUint32(32, Number(data.cOtherLogo), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgOtherLogo !== undefined) view.setBigUint64(40, data.rgOtherLogo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgOtherLogo))), true);
  return buf;
}

export class CERT_LOGOTYPE_EXT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cCommunityLogo(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgCommunityLogo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pIssuerLogo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pSubjectLogo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cOtherLogo(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgOtherLogo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cCommunityLogo(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgCommunityLogo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pIssuerLogo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pSubjectLogo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cOtherLogo(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgOtherLogo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_BIOMETRIC_DATA (size: 24)
 */
export interface CERT_BIOMETRIC_DATA {
  /** Windows.Win32.Security.Cryptography.CERT_BIOMETRIC_DATA_TYPE */
  dwTypeOfBiometricDataChoice: CERT_BIOMETRIC_DATA_TYPE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_HASHED_URL */
  HashedUrl: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_BIOMETRIC_DATA = 24;

export function allocCERT_BIOMETRIC_DATA(data?: Partial<CERT_BIOMETRIC_DATA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_BIOMETRIC_DATA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwTypeOfBiometricDataChoice !== undefined) view.setUint32(0, Number(data.dwTypeOfBiometricDataChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: pointer
  if (data?.HashedUrl !== undefined) view.setBigUint64(16, data.HashedUrl === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashedUrl))), true);
  return buf;
}

export class CERT_BIOMETRIC_DATAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwTypeOfBiometricDataChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get HashedUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwTypeOfBiometricDataChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set HashedUrl(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_BIOMETRIC_EXT_INFO (size: 16)
 */
export interface CERT_BIOMETRIC_EXT_INFO {
  /** u32 */
  cBiometricData: number;
  /** ptr */
  rgBiometricData: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_BIOMETRIC_EXT_INFO = 16;

export function allocCERT_BIOMETRIC_EXT_INFO(data?: Partial<CERT_BIOMETRIC_EXT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_BIOMETRIC_EXT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cBiometricData !== undefined) view.setUint32(0, Number(data.cBiometricData), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgBiometricData !== undefined) view.setBigUint64(8, data.rgBiometricData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgBiometricData))), true);
  return buf;
}

export class CERT_BIOMETRIC_EXT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cBiometricData(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgBiometricData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cBiometricData(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgBiometricData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_SIGNATURE_INFO (size: 32)
 */
export interface OCSP_SIGNATURE_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  SignatureAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  Signature: Uint8Array | Deno.PointerValue;
  /** u32 */
  cCertEncoded: number;
  /** ptr */
  rgCertEncoded: Deno.PointerValue | Uint8Array;
}

export const sizeofOCSP_SIGNATURE_INFO = 32;

export function allocOCSP_SIGNATURE_INFO(data?: Partial<OCSP_SIGNATURE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_SIGNATURE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.SignatureAlgorithm !== undefined) view.setBigUint64(0, data.SignatureAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignatureAlgorithm))), true);
  // 0x08: pointer
  if (data?.Signature !== undefined) view.setBigUint64(8, data.Signature === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Signature))), true);
  // 0x10: u32
  if (data?.cCertEncoded !== undefined) view.setUint32(16, Number(data.cCertEncoded), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgCertEncoded !== undefined) view.setBigUint64(24, data.rgCertEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCertEncoded))), true);
  return buf;
}

export class OCSP_SIGNATURE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get SignatureAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Signature(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cCertEncoded(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgCertEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set SignatureAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set Signature(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cCertEncoded(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgCertEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_SIGNED_REQUEST_INFO (size: 16)
 */
export interface OCSP_SIGNED_REQUEST_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ToBeSigned: Uint8Array | Deno.PointerValue;
  /** ptr */
  pOptionalSignatureInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofOCSP_SIGNED_REQUEST_INFO = 16;

export function allocOCSP_SIGNED_REQUEST_INFO(data?: Partial<OCSP_SIGNED_REQUEST_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_SIGNED_REQUEST_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ToBeSigned !== undefined) view.setBigUint64(0, data.ToBeSigned === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ToBeSigned))), true);
  // 0x08: pointer
  if (data?.pOptionalSignatureInfo !== undefined) view.setBigUint64(8, data.pOptionalSignatureInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pOptionalSignatureInfo))), true);
  return buf;
}

export class OCSP_SIGNED_REQUEST_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ToBeSigned(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pOptionalSignatureInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set ToBeSigned(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pOptionalSignatureInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_CERT_ID (size: 32)
 */
export interface OCSP_CERT_ID {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  IssuerNameHash: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  IssuerKeyHash: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SerialNumber: Uint8Array | Deno.PointerValue;
}

export const sizeofOCSP_CERT_ID = 32;

export function allocOCSP_CERT_ID(data?: Partial<OCSP_CERT_ID>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_CERT_ID);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(0, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x08: pointer
  if (data?.IssuerNameHash !== undefined) view.setBigUint64(8, data.IssuerNameHash === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IssuerNameHash))), true);
  // 0x10: pointer
  if (data?.IssuerKeyHash !== undefined) view.setBigUint64(16, data.IssuerKeyHash === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IssuerKeyHash))), true);
  // 0x18: pointer
  if (data?.SerialNumber !== undefined) view.setBigUint64(24, data.SerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SerialNumber))), true);
  return buf;
}

export class OCSP_CERT_IDView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get IssuerNameHash(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get IssuerKeyHash(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get SerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set IssuerNameHash(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set IssuerKeyHash(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set SerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_REQUEST_ENTRY (size: 24)
 */
export interface OCSP_REQUEST_ENTRY {
  /** Windows.Win32.Security.Cryptography.OCSP_CERT_ID */
  CertId: Uint8Array | Deno.PointerValue;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofOCSP_REQUEST_ENTRY = 24;

export function allocOCSP_REQUEST_ENTRY(data?: Partial<OCSP_REQUEST_ENTRY>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_REQUEST_ENTRY);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.CertId !== undefined) view.setBigUint64(0, data.CertId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CertId))), true);
  // 0x08: u32
  if (data?.cExtension !== undefined) view.setUint32(8, Number(data.cExtension), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(16, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class OCSP_REQUEST_ENTRYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get CertId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cExtension(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set CertId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set cExtension(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_REQUEST_INFO (size: 48)
 */
export interface OCSP_REQUEST_INFO {
  /** u32 */
  dwVersion: number;
  /** ptr */
  pRequestorName: Deno.PointerValue | Uint8Array;
  /** u32 */
  cRequestEntry: number;
  /** ptr */
  rgRequestEntry: Deno.PointerValue | Uint8Array;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofOCSP_REQUEST_INFO = 48;

export function allocOCSP_REQUEST_INFO(data?: Partial<OCSP_REQUEST_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_REQUEST_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pRequestorName !== undefined) view.setBigUint64(8, data.pRequestorName === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pRequestorName))), true);
  // 0x10: u32
  if (data?.cRequestEntry !== undefined) view.setUint32(16, Number(data.cRequestEntry), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgRequestEntry !== undefined) view.setBigUint64(24, data.rgRequestEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgRequestEntry))), true);
  // 0x20: u32
  if (data?.cExtension !== undefined) view.setUint32(32, Number(data.cExtension), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(40, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class OCSP_REQUEST_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pRequestorName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cRequestEntry(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgRequestEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cExtension(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pRequestorName(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cRequestEntry(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgRequestEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cExtension(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_RESPONSE_INFO (size: 24)
 */
export interface OCSP_RESPONSE_INFO {
  /** u32 */
  dwStatus: number;
  /** Windows.Win32.Foundation.PSTR */
  pszObjId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Value: Uint8Array | Deno.PointerValue;
}

export const sizeofOCSP_RESPONSE_INFO = 24;

export function allocOCSP_RESPONSE_INFO(data?: Partial<OCSP_RESPONSE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_RESPONSE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwStatus !== undefined) view.setUint32(0, Number(data.dwStatus), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszObjId !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszObjId);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.Value !== undefined) view.setBigUint64(16, data.Value === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Value))), true);
  return buf;
}

export class OCSP_RESPONSE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwStatus(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszObjId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Value(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwStatus(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszObjId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set Value(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_BASIC_SIGNED_RESPONSE_INFO (size: 16)
 */
export interface OCSP_BASIC_SIGNED_RESPONSE_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ToBeSigned: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.OCSP_SIGNATURE_INFO */
  SignatureInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofOCSP_BASIC_SIGNED_RESPONSE_INFO = 16;

export function allocOCSP_BASIC_SIGNED_RESPONSE_INFO(data?: Partial<OCSP_BASIC_SIGNED_RESPONSE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_BASIC_SIGNED_RESPONSE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.ToBeSigned !== undefined) view.setBigUint64(0, data.ToBeSigned === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ToBeSigned))), true);
  // 0x08: pointer
  if (data?.SignatureInfo !== undefined) view.setBigUint64(8, data.SignatureInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignatureInfo))), true);
  return buf;
}

export class OCSP_BASIC_SIGNED_RESPONSE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get ToBeSigned(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get SignatureInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set ToBeSigned(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set SignatureInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_BASIC_REVOKED_INFO (size: 16)
 */
export interface OCSP_BASIC_REVOKED_INFO {
  /** Windows.Win32.Foundation.FILETIME */
  RevocationDate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_REVOCATION_STATUS_REASON */
  dwCrlReasonCode: CERT_REVOCATION_STATUS_REASON;
}

export const sizeofOCSP_BASIC_REVOKED_INFO = 16;

export function allocOCSP_BASIC_REVOKED_INFO(data?: Partial<OCSP_BASIC_REVOKED_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_BASIC_REVOKED_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.RevocationDate !== undefined) view.setBigUint64(0, data.RevocationDate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RevocationDate))), true);
  // 0x08: u32
  if (data?.dwCrlReasonCode !== undefined) view.setUint32(8, Number(data.dwCrlReasonCode), true);
  // 0x0c: pad4
  return buf;
}

export class OCSP_BASIC_REVOKED_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get RevocationDate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwCrlReasonCode(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: pointer
  set RevocationDate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set dwCrlReasonCode(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_BASIC_RESPONSE_ENTRY (size: 56)
 */
export interface OCSP_BASIC_RESPONSE_ENTRY {
  /** Windows.Win32.Security.Cryptography.OCSP_CERT_ID */
  CertId: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwCertStatus: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  ThisUpdate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  NextUpdate: Uint8Array | Deno.PointerValue;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofOCSP_BASIC_RESPONSE_ENTRY = 56;

export function allocOCSP_BASIC_RESPONSE_ENTRY(data?: Partial<OCSP_BASIC_RESPONSE_ENTRY>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_BASIC_RESPONSE_ENTRY);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.CertId !== undefined) view.setBigUint64(0, data.CertId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CertId))), true);
  // 0x08: u32
  if (data?.dwCertStatus !== undefined) view.setUint32(8, Number(data.dwCertStatus), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(16, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x18: pointer
  if (data?.ThisUpdate !== undefined) view.setBigUint64(24, data.ThisUpdate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ThisUpdate))), true);
  // 0x20: pointer
  if (data?.NextUpdate !== undefined) view.setBigUint64(32, data.NextUpdate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NextUpdate))), true);
  // 0x28: u32
  if (data?.cExtension !== undefined) view.setUint32(40, Number(data.cExtension), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(48, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class OCSP_BASIC_RESPONSE_ENTRYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get CertId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwCertStatus(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get ThisUpdate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get NextUpdate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get cExtension(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set CertId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set dwCertStatus(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set ThisUpdate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set NextUpdate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: u32
  set cExtension(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.OCSP_BASIC_RESPONSE_INFO (size: 56)
 */
export interface OCSP_BASIC_RESPONSE_INFO {
  /** u32 */
  dwVersion: number;
  /** u32 */
  dwResponderIdChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  ProducedAt: Uint8Array | Deno.PointerValue;
  /** u32 */
  cResponseEntry: number;
  /** ptr */
  rgResponseEntry: Deno.PointerValue | Uint8Array;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofOCSP_BASIC_RESPONSE_INFO = 56;

export function allocOCSP_BASIC_RESPONSE_INFO(data?: Partial<OCSP_BASIC_RESPONSE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofOCSP_BASIC_RESPONSE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: u32
  if (data?.dwResponderIdChoice !== undefined) view.setUint32(4, Number(data.dwResponderIdChoice), true);
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: pointer
  if (data?.ProducedAt !== undefined) view.setBigUint64(16, data.ProducedAt === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ProducedAt))), true);
  // 0x18: u32
  if (data?.cResponseEntry !== undefined) view.setUint32(24, Number(data.cResponseEntry), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgResponseEntry !== undefined) view.setBigUint64(32, data.rgResponseEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgResponseEntry))), true);
  // 0x28: u32
  if (data?.cExtension !== undefined) view.setUint32(40, Number(data.cExtension), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(48, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class OCSP_BASIC_RESPONSE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwResponderIdChoice(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get ProducedAt(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cResponseEntry(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgResponseEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get cExtension(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwResponderIdChoice(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set ProducedAt(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set cResponseEntry(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgResponseEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: u32
  set cExtension(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SUPPORTED_ALGORITHM_INFO (size: 24)
 */
export interface CERT_SUPPORTED_ALGORITHM_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  Algorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  IntendedKeyUsage: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_POLICIES_INFO */
  IntendedCertPolicies: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_SUPPORTED_ALGORITHM_INFO = 24;

export function allocCERT_SUPPORTED_ALGORITHM_INFO(data?: Partial<CERT_SUPPORTED_ALGORITHM_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SUPPORTED_ALGORITHM_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Algorithm !== undefined) view.setBigUint64(0, data.Algorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Algorithm))), true);
  // 0x08: pointer
  if (data?.IntendedKeyUsage !== undefined) view.setBigUint64(8, data.IntendedKeyUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IntendedKeyUsage))), true);
  // 0x10: pointer
  if (data?.IntendedCertPolicies !== undefined) view.setBigUint64(16, data.IntendedCertPolicies === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.IntendedCertPolicies))), true);
  return buf;
}

export class CERT_SUPPORTED_ALGORITHM_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Algorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get IntendedKeyUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get IntendedCertPolicies(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Algorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set IntendedKeyUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set IntendedCertPolicies(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_TPM_SPECIFICATION_INFO (size: 16)
 */
export interface CERT_TPM_SPECIFICATION_INFO {
  /** Windows.Win32.Foundation.PWSTR */
  pwszFamily: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwLevel: number;
  /** u32 */
  dwRevision: number;
}

export const sizeofCERT_TPM_SPECIFICATION_INFO = 16;

export function allocCERT_TPM_SPECIFICATION_INFO(data?: Partial<CERT_TPM_SPECIFICATION_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_TPM_SPECIFICATION_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pwszFamily !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pwszFamily);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.dwLevel !== undefined) view.setUint32(8, Number(data.dwLevel), true);
  // 0x0c: u32
  if (data?.dwRevision !== undefined) view.setUint32(12, Number(data.dwRevision), true);
  return buf;
}

export class CERT_TPM_SPECIFICATION_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pwszFamily(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwLevel(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwRevision(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: buffer
  set pwszFamily(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set dwLevel(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwRevision(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_OID_FUNC_ENTRY (size: 16)
 */
export interface CRYPT_OID_FUNC_ENTRY {
  /** Windows.Win32.Foundation.PSTR */
  pszOID: string | null | Uint8Array;
  /** ptr */
  pvFuncAddr: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_OID_FUNC_ENTRY = 16;

export function allocCRYPT_OID_FUNC_ENTRY(data?: Partial<CRYPT_OID_FUNC_ENTRY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_OID_FUNC_ENTRY);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszOID !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszOID);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.pvFuncAddr !== undefined) view.setBigUint64(8, data.pvFuncAddr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvFuncAddr))), true);
  return buf;
}

export class CRYPT_OID_FUNC_ENTRYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszOID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pvFuncAddr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszOID(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set pvFuncAddr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_OID_INFO (size: 48)
 */
export interface CRYPT_OID_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PSTR */
  pszOID: string | null | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwGroupId: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ExtraInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_OID_INFO = 48;

export function allocCRYPT_OID_INFO(data?: Partial<CRYPT_OID_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_OID_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszOID !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszOID);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pwszName !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszName);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: u32
  if (data?.dwGroupId !== undefined) view.setUint32(24, Number(data.dwGroupId), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(32, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x28: pointer
  if (data?.ExtraInfo !== undefined) view.setBigUint64(40, data.ExtraInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ExtraInfo))), true);
  return buf;
}

export class CRYPT_OID_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszOID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwGroupId(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get ExtraInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszOID(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pwszName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: u32
  set dwGroupId(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set ExtraInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_STRONG_SIGN_SERIALIZED_INFO (size: 24)
 */
export interface CERT_STRONG_SIGN_SERIALIZED_INFO {
  /** Windows.Win32.Security.Cryptography.CERT_STRONG_SIGN_FLAGS */
  dwFlags: CERT_STRONG_SIGN_FLAGS;
  /** Windows.Win32.Foundation.PWSTR */
  pwszCNGSignHashAlgids: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszCNGPubKeyMinBitLengths: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_STRONG_SIGN_SERIALIZED_INFO = 24;

export function allocCERT_STRONG_SIGN_SERIALIZED_INFO(data?: Partial<CERT_STRONG_SIGN_SERIALIZED_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_STRONG_SIGN_SERIALIZED_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwFlags !== undefined) view.setUint32(0, Number(data.dwFlags), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pwszCNGSignHashAlgids !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszCNGSignHashAlgids);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pwszCNGPubKeyMinBitLengths !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszCNGPubKeyMinBitLengths);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class CERT_STRONG_SIGN_SERIALIZED_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwFlags(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pwszCNGSignHashAlgids(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszCNGPubKeyMinBitLengths(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwFlags(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pwszCNGSignHashAlgids(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pwszCNGPubKeyMinBitLengths(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_STRONG_SIGN_PARA (size: 16)
 */
export interface CERT_STRONG_SIGN_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwInfoChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_STRONG_SIGN_PARA = 16;

export function allocCERT_STRONG_SIGN_PARA(data?: Partial<CERT_STRONG_SIGN_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_STRONG_SIGN_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwInfoChoice !== undefined) view.setUint32(4, Number(data.dwInfoChoice), true);
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CERT_STRONG_SIGN_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwInfoChoice(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwInfoChoice(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_ISSUER_SERIAL_NUMBER (size: 16)
 */
export interface CERT_ISSUER_SERIAL_NUMBER {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Issuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SerialNumber: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_ISSUER_SERIAL_NUMBER = 16;

export function allocCERT_ISSUER_SERIAL_NUMBER(data?: Partial<CERT_ISSUER_SERIAL_NUMBER>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_ISSUER_SERIAL_NUMBER);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Issuer !== undefined) view.setBigUint64(0, data.Issuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Issuer))), true);
  // 0x08: pointer
  if (data?.SerialNumber !== undefined) view.setBigUint64(8, data.SerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SerialNumber))), true);
  return buf;
}

export class CERT_ISSUER_SERIAL_NUMBERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Issuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get SerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Issuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set SerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_ID (size: 16)
 */
export interface CERT_ID {
  /** Windows.Win32.Security.Cryptography.CERT_ID_OPTION */
  dwIdChoice: CERT_ID_OPTION;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_ID = 16;

export function allocCERT_ID(data?: Partial<CERT_ID>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_ID);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwIdChoice !== undefined) view.setUint32(0, Number(data.dwIdChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CERT_IDView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwIdChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwIdChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_SIGNER_ENCODE_INFO (size: 80)
 */
export interface CMSG_SIGNER_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** ptr */
  pCertInfo: Deno.PointerValue | Uint8Array;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwKeySpec: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvHashAuxInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cAuthAttr: number;
  /** ptr */
  rgAuthAttr: Deno.PointerValue | Uint8Array;
  /** u32 */
  cUnauthAttr: number;
  /** ptr */
  rgUnauthAttr: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_SIGNER_ENCODE_INFO = 80;

export function allocCMSG_SIGNER_ENCODE_INFO(data?: Partial<CMSG_SIGNER_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_SIGNER_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pCertInfo !== undefined) view.setBigUint64(8, data.pCertInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertInfo))), true);
  // 0x10: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(16, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x18: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(24, Number(data.dwKeySpec), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(32, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x28: pointer
  if (data?.pvHashAuxInfo !== undefined) view.setBigUint64(40, data.pvHashAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvHashAuxInfo))), true);
  // 0x30: u32
  if (data?.cAuthAttr !== undefined) view.setUint32(48, Number(data.cAuthAttr), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.rgAuthAttr !== undefined) view.setBigUint64(56, data.rgAuthAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAuthAttr))), true);
  // 0x40: u32
  if (data?.cUnauthAttr !== undefined) view.setUint32(64, Number(data.cUnauthAttr), true);
  // 0x44: pad4
  // 0x48: pointer
  if (data?.rgUnauthAttr !== undefined) view.setBigUint64(72, data.rgUnauthAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgUnauthAttr))), true);
  return buf;
}

export class CMSG_SIGNER_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pCertInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwKeySpec(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pvHashAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cAuthAttr(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get rgAuthAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: u32
  get cUnauthAttr(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  get rgUnauthAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pCertInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pvHashAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cAuthAttr(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set rgAuthAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: u32
  set cUnauthAttr(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  set rgUnauthAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_SIGNED_ENCODE_INFO (size: 48)
 */
export interface CMSG_SIGNED_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  cSigners: number;
  /** ptr */
  rgSigners: Deno.PointerValue | Uint8Array;
  /** u32 */
  cCertEncoded: number;
  /** ptr */
  rgCertEncoded: Deno.PointerValue | Uint8Array;
  /** u32 */
  cCrlEncoded: number;
  /** ptr */
  rgCrlEncoded: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_SIGNED_ENCODE_INFO = 48;

export function allocCMSG_SIGNED_ENCODE_INFO(data?: Partial<CMSG_SIGNED_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_SIGNED_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.cSigners !== undefined) view.setUint32(4, Number(data.cSigners), true);
  // 0x08: pointer
  if (data?.rgSigners !== undefined) view.setBigUint64(8, data.rgSigners === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgSigners))), true);
  // 0x10: u32
  if (data?.cCertEncoded !== undefined) view.setUint32(16, Number(data.cCertEncoded), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgCertEncoded !== undefined) view.setBigUint64(24, data.rgCertEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCertEncoded))), true);
  // 0x20: u32
  if (data?.cCrlEncoded !== undefined) view.setUint32(32, Number(data.cCrlEncoded), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgCrlEncoded !== undefined) view.setBigUint64(40, data.rgCrlEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCrlEncoded))), true);
  return buf;
}

export class CMSG_SIGNED_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cSigners(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgSigners(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cCertEncoded(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgCertEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cCrlEncoded(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgCrlEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cSigners(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgSigners(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cCertEncoded(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgCertEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cCrlEncoded(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgCrlEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_ENVELOPED_ENCODE_INFO (size: 48)
 */
export interface CMSG_ENVELOPED_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  ContentEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvEncryptionAuxInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cRecipients: number;
  /** ptr */
  rgpRecipients: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_ENVELOPED_ENCODE_INFO = 48;

export function allocCMSG_ENVELOPED_ENCODE_INFO(data?: Partial<CMSG_ENVELOPED_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_ENVELOPED_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x10: pointer
  if (data?.ContentEncryptionAlgorithm !== undefined) view.setBigUint64(16, data.ContentEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ContentEncryptionAlgorithm))), true);
  // 0x18: pointer
  if (data?.pvEncryptionAuxInfo !== undefined) view.setBigUint64(24, data.pvEncryptionAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvEncryptionAuxInfo))), true);
  // 0x20: u32
  if (data?.cRecipients !== undefined) view.setUint32(32, Number(data.cRecipients), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgpRecipients !== undefined) view.setBigUint64(40, data.rgpRecipients === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpRecipients))), true);
  return buf;
}

export class CMSG_ENVELOPED_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get ContentEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvEncryptionAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cRecipients(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgpRecipients(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set ContentEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvEncryptionAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cRecipients(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgpRecipients(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO (size: 48)
 */
export interface CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvKeyEncryptionAuxInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  RecipientPublicKey: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_ID */
  RecipientId: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = 48;

export function allocCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO(data?: Partial<CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.pvKeyEncryptionAuxInfo !== undefined) view.setBigUint64(16, data.pvKeyEncryptionAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvKeyEncryptionAuxInfo))), true);
  // 0x18: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(24, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x20: pointer
  if (data?.RecipientPublicKey !== undefined) view.setBigUint64(32, data.RecipientPublicKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RecipientPublicKey))), true);
  // 0x28: pointer
  if (data?.RecipientId !== undefined) view.setBigUint64(40, data.RecipientId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RecipientId))), true);
  return buf;
}

export class CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvKeyEncryptionAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get RecipientPublicKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get RecipientId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pvKeyEncryptionAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set RecipientPublicKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set RecipientId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO (size: 40)
 */
export interface CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  RecipientPublicKey: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_ID */
  RecipientId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  Date: Uint8Array | Deno.PointerValue;
  /** ptr */
  pOtherAttr: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = 40;

export function allocCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO(data?: Partial<CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.RecipientPublicKey !== undefined) view.setBigUint64(8, data.RecipientPublicKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RecipientPublicKey))), true);
  // 0x10: pointer
  if (data?.RecipientId !== undefined) view.setBigUint64(16, data.RecipientId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RecipientId))), true);
  // 0x18: pointer
  if (data?.Date !== undefined) view.setBigUint64(24, data.Date === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Date))), true);
  // 0x20: pointer
  if (data?.pOtherAttr !== undefined) view.setBigUint64(32, data.pOtherAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pOtherAttr))), true);
  return buf;
}

export class CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get RecipientPublicKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get RecipientId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get Date(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pOtherAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set RecipientPublicKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set RecipientId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set Date(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pOtherAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO (size: 88)
 */
export interface CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvKeyEncryptionAuxInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyWrapAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvKeyWrapAuxInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwKeySpec: number;
  /** Windows.Win32.Security.Cryptography.CMSG_KEY_AGREE_OPTION */
  dwKeyChoice: CMSG_KEY_AGREE_OPTION;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  UserKeyingMaterial: Uint8Array | Deno.PointerValue;
  /** u32 */
  cRecipientEncryptedKeys: number;
  /** ptr */
  rgpRecipientEncryptedKeys: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = 88;

export function allocCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO(data?: Partial<CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.pvKeyEncryptionAuxInfo !== undefined) view.setBigUint64(16, data.pvKeyEncryptionAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvKeyEncryptionAuxInfo))), true);
  // 0x18: pointer
  if (data?.KeyWrapAlgorithm !== undefined) view.setBigUint64(24, data.KeyWrapAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyWrapAlgorithm))), true);
  // 0x20: pointer
  if (data?.pvKeyWrapAuxInfo !== undefined) view.setBigUint64(32, data.pvKeyWrapAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvKeyWrapAuxInfo))), true);
  // 0x28: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(40, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x30: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(48, Number(data.dwKeySpec), true);
  // 0x34: u32
  if (data?.dwKeyChoice !== undefined) view.setUint32(52, Number(data.dwKeyChoice), true);
  // 0x38: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(56, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x40: pointer
  if (data?.UserKeyingMaterial !== undefined) view.setBigUint64(64, data.UserKeyingMaterial === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.UserKeyingMaterial))), true);
  // 0x48: u32
  if (data?.cRecipientEncryptedKeys !== undefined) view.setUint32(72, Number(data.cRecipientEncryptedKeys), true);
  // 0x4c: pad4
  // 0x50: pointer
  if (data?.rgpRecipientEncryptedKeys !== undefined) view.setBigUint64(80, data.rgpRecipientEncryptedKeys === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpRecipientEncryptedKeys))), true);
  return buf;
}

export class CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvKeyEncryptionAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get KeyWrapAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pvKeyWrapAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get dwKeySpec(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: u32
  get dwKeyChoice(): number {
    return this.view.getUint32(52, true);
  }

  // 0x38: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: pointer
  get UserKeyingMaterial(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: u32
  get cRecipientEncryptedKeys(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  get rgpRecipientEncryptedKeys(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pvKeyEncryptionAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set KeyWrapAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pvKeyWrapAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: u32
  set dwKeyChoice(value: number) {
    this.view.setUint32(52, value, true);
  }

  // 0x38: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: pointer
  set UserKeyingMaterial(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: u32
  set cRecipientEncryptedKeys(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  set rgpRecipientEncryptedKeys(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO (size: 72)
 */
export interface CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvKeyEncryptionAuxInfo: Deno.PointerValue | Uint8Array;
  /** usize */
  hCryptProv: Deno.PointerValue;
  /** u32 */
  dwKeyChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  KeyId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  Date: Uint8Array | Deno.PointerValue;
  /** ptr */
  pOtherAttr: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = 72;

export function allocCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO(data?: Partial<CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.pvKeyEncryptionAuxInfo !== undefined) view.setBigUint64(16, data.pvKeyEncryptionAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvKeyEncryptionAuxInfo))), true);
  // 0x18: usize
  if (data?.hCryptProv !== undefined) view.setBigUint64(24, BigInt(data.hCryptProv), true);
  // 0x20: u32
  if (data?.dwKeyChoice !== undefined) view.setUint32(32, Number(data.dwKeyChoice), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(40, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x30: pointer
  if (data?.KeyId !== undefined) view.setBigUint64(48, data.KeyId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyId))), true);
  // 0x38: pointer
  if (data?.Date !== undefined) view.setBigUint64(56, data.Date === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Date))), true);
  // 0x40: pointer
  if (data?.pOtherAttr !== undefined) view.setBigUint64(64, data.pOtherAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pOtherAttr))), true);
  return buf;
}

export class CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvKeyEncryptionAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: usize
  get hCryptProv(): Deno.PointerValue {
    return Number(this.view.getBigUint64(24, true));
  }

  // 0x20: u32
  get dwKeyChoice(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get KeyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get Date(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: pointer
  get pOtherAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pvKeyEncryptionAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: usize
  set hCryptProv(value: Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(value), true);
  }

  // 0x20: u32
  set dwKeyChoice(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set KeyId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set Date(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: pointer
  set pOtherAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_RECIPIENT_ENCODE_INFO (size: 16)
 */
export interface CMSG_RECIPIENT_ENCODE_INFO {
  /** u32 */
  dwRecipientChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_RECIPIENT_ENCODE_INFO = 16;

export function allocCMSG_RECIPIENT_ENCODE_INFO(data?: Partial<CMSG_RECIPIENT_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_RECIPIENT_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwRecipientChoice !== undefined) view.setUint32(0, Number(data.dwRecipientChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CMSG_RECIPIENT_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwRecipientChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwRecipientChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_RC2_AUX_INFO (size: 8)
 */
export interface CMSG_RC2_AUX_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwBitLen: number;
}

export const sizeofCMSG_RC2_AUX_INFO = 8;

export function allocCMSG_RC2_AUX_INFO(data?: Partial<CMSG_RC2_AUX_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_RC2_AUX_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwBitLen !== undefined) view.setUint32(4, Number(data.dwBitLen), true);
  return buf;
}

export class CMSG_RC2_AUX_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwBitLen(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwBitLen(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_SP3_COMPATIBLE_AUX_INFO (size: 8)
 */
export interface CMSG_SP3_COMPATIBLE_AUX_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwFlags: number;
}

export const sizeofCMSG_SP3_COMPATIBLE_AUX_INFO = 8;

export function allocCMSG_SP3_COMPATIBLE_AUX_INFO(data?: Partial<CMSG_SP3_COMPATIBLE_AUX_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_SP3_COMPATIBLE_AUX_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwFlags !== undefined) view.setUint32(4, Number(data.dwFlags), true);
  return buf;
}

export class CMSG_SP3_COMPATIBLE_AUX_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwFlags(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_RC4_AUX_INFO (size: 8)
 */
export interface CMSG_RC4_AUX_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwBitLen: number;
}

export const sizeofCMSG_RC4_AUX_INFO = 8;

export function allocCMSG_RC4_AUX_INFO(data?: Partial<CMSG_RC4_AUX_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_RC4_AUX_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwBitLen !== undefined) view.setUint32(4, Number(data.dwBitLen), true);
  return buf;
}

export class CMSG_RC4_AUX_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwBitLen(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwBitLen(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO (size: 24)
 */
export interface CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CMSG_SIGNED_ENCODE_INFO */
  SignedInfo: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CMSG_ENVELOPED_ENCODE_INFO */
  EnvelopedInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = 24;

export function allocCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO(data?: Partial<CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SignedInfo !== undefined) view.setBigUint64(8, data.SignedInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignedInfo))), true);
  // 0x10: pointer
  if (data?.EnvelopedInfo !== undefined) view.setBigUint64(16, data.EnvelopedInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EnvelopedInfo))), true);
  return buf;
}

export class CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SignedInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get EnvelopedInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SignedInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set EnvelopedInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_HASHED_ENCODE_INFO (size: 32)
 */
export interface CMSG_HASHED_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvHashAuxInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_HASHED_ENCODE_INFO = 32;

export function allocCMSG_HASHED_ENCODE_INFO(data?: Partial<CMSG_HASHED_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_HASHED_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x10: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(16, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x18: pointer
  if (data?.pvHashAuxInfo !== undefined) view.setBigUint64(24, data.pvHashAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvHashAuxInfo))), true);
  return buf;
}

export class CMSG_HASHED_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvHashAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvHashAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_ENCRYPTED_ENCODE_INFO (size: 24)
 */
export interface CMSG_ENCRYPTED_ENCODE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  ContentEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvEncryptionAuxInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_ENCRYPTED_ENCODE_INFO = 24;

export function allocCMSG_ENCRYPTED_ENCODE_INFO(data?: Partial<CMSG_ENCRYPTED_ENCODE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_ENCRYPTED_ENCODE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.ContentEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.ContentEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ContentEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.pvEncryptionAuxInfo !== undefined) view.setBigUint64(16, data.pvEncryptionAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvEncryptionAuxInfo))), true);
  return buf;
}

export class CMSG_ENCRYPTED_ENCODE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get ContentEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvEncryptionAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set ContentEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pvEncryptionAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_STREAM_INFO (size: 24)
 */
export interface CMSG_STREAM_INFO {
  /** u32 */
  cbContent: number;
  /** Windows.Win32.Security.Cryptography.PFN_CMSG_STREAM_OUTPUT */
  pfnStreamOutput: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvArg: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_STREAM_INFO = 24;

export function allocCMSG_STREAM_INFO(data?: Partial<CMSG_STREAM_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_STREAM_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbContent !== undefined) view.setUint32(0, Number(data.cbContent), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pfnStreamOutput !== undefined) view.setBigUint64(8, data.pfnStreamOutput === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnStreamOutput))), true);
  // 0x10: pointer
  if (data?.pvArg !== undefined) view.setBigUint64(16, data.pvArg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvArg))), true);
  return buf;
}

export class CMSG_STREAM_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbContent(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pfnStreamOutput(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvArg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbContent(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pfnStreamOutput(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pvArg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_SIGNER_INFO (size: 64)
 */
export interface CMSG_SIGNER_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Issuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SerialNumber: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedHash: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTES */
  AuthAttrs: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTES */
  UnauthAttrs: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_SIGNER_INFO = 64;

export function allocCMSG_SIGNER_INFO(data?: Partial<CMSG_SIGNER_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_SIGNER_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Issuer !== undefined) view.setBigUint64(8, data.Issuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Issuer))), true);
  // 0x10: pointer
  if (data?.SerialNumber !== undefined) view.setBigUint64(16, data.SerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SerialNumber))), true);
  // 0x18: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(24, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x20: pointer
  if (data?.HashEncryptionAlgorithm !== undefined) view.setBigUint64(32, data.HashEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashEncryptionAlgorithm))), true);
  // 0x28: pointer
  if (data?.EncryptedHash !== undefined) view.setBigUint64(40, data.EncryptedHash === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedHash))), true);
  // 0x30: pointer
  if (data?.AuthAttrs !== undefined) view.setBigUint64(48, data.AuthAttrs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.AuthAttrs))), true);
  // 0x38: pointer
  if (data?.UnauthAttrs !== undefined) view.setBigUint64(56, data.UnauthAttrs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.UnauthAttrs))), true);
  return buf;
}

export class CMSG_SIGNER_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Issuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get SerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get HashEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get EncryptedHash(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get AuthAttrs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get UnauthAttrs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Issuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set SerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set HashEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set EncryptedHash(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set AuthAttrs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set UnauthAttrs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CMS_SIGNER_INFO (size: 56)
 */
export interface CMSG_CMS_SIGNER_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CERT_ID */
  SignerId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedHash: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTES */
  AuthAttrs: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTES */
  UnauthAttrs: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_CMS_SIGNER_INFO = 56;

export function allocCMSG_CMS_SIGNER_INFO(data?: Partial<CMSG_CMS_SIGNER_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CMS_SIGNER_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SignerId !== undefined) view.setBigUint64(8, data.SignerId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignerId))), true);
  // 0x10: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(16, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x18: pointer
  if (data?.HashEncryptionAlgorithm !== undefined) view.setBigUint64(24, data.HashEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashEncryptionAlgorithm))), true);
  // 0x20: pointer
  if (data?.EncryptedHash !== undefined) view.setBigUint64(32, data.EncryptedHash === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedHash))), true);
  // 0x28: pointer
  if (data?.AuthAttrs !== undefined) view.setBigUint64(40, data.AuthAttrs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.AuthAttrs))), true);
  // 0x30: pointer
  if (data?.UnauthAttrs !== undefined) view.setBigUint64(48, data.UnauthAttrs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.UnauthAttrs))), true);
  return buf;
}

export class CMSG_CMS_SIGNER_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SignerId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get HashEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get EncryptedHash(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get AuthAttrs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get UnauthAttrs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SignerId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set HashEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set EncryptedHash(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set AuthAttrs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set UnauthAttrs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_KEY_TRANS_RECIPIENT_INFO (size: 32)
 */
export interface CMSG_KEY_TRANS_RECIPIENT_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CERT_ID */
  RecipientId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedKey: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_KEY_TRANS_RECIPIENT_INFO = 32;

export function allocCMSG_KEY_TRANS_RECIPIENT_INFO(data?: Partial<CMSG_KEY_TRANS_RECIPIENT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_KEY_TRANS_RECIPIENT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.RecipientId !== undefined) view.setBigUint64(8, data.RecipientId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RecipientId))), true);
  // 0x10: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(16, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x18: pointer
  if (data?.EncryptedKey !== undefined) view.setBigUint64(24, data.EncryptedKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedKey))), true);
  return buf;
}

export class CMSG_KEY_TRANS_RECIPIENT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get RecipientId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get EncryptedKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set RecipientId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set EncryptedKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_RECIPIENT_ENCRYPTED_KEY_INFO (size: 32)
 */
export interface CMSG_RECIPIENT_ENCRYPTED_KEY_INFO {
  /** Windows.Win32.Security.Cryptography.CERT_ID */
  RecipientId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedKey: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  Date: Uint8Array | Deno.PointerValue;
  /** ptr */
  pOtherAttr: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = 32;

export function allocCMSG_RECIPIENT_ENCRYPTED_KEY_INFO(data?: Partial<CMSG_RECIPIENT_ENCRYPTED_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_RECIPIENT_ENCRYPTED_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.RecipientId !== undefined) view.setBigUint64(0, data.RecipientId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RecipientId))), true);
  // 0x08: pointer
  if (data?.EncryptedKey !== undefined) view.setBigUint64(8, data.EncryptedKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedKey))), true);
  // 0x10: pointer
  if (data?.Date !== undefined) view.setBigUint64(16, data.Date === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Date))), true);
  // 0x18: pointer
  if (data?.pOtherAttr !== undefined) view.setBigUint64(24, data.pOtherAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pOtherAttr))), true);
  return buf;
}

export class CMSG_RECIPIENT_ENCRYPTED_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get RecipientId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get EncryptedKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Date(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pOtherAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set RecipientId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set EncryptedKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Date(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pOtherAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_KEY_AGREE_RECIPIENT_INFO (size: 48)
 */
export interface CMSG_KEY_AGREE_RECIPIENT_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CMSG_KEY_AGREE_ORIGINATOR */
  dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  UserKeyingMaterial: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** u32 */
  cRecipientEncryptedKeys: number;
  /** ptr */
  rgpRecipientEncryptedKeys: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_KEY_AGREE_RECIPIENT_INFO = 48;

export function allocCMSG_KEY_AGREE_RECIPIENT_INFO(data?: Partial<CMSG_KEY_AGREE_RECIPIENT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_KEY_AGREE_RECIPIENT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: u32
  if (data?.dwOriginatorChoice !== undefined) view.setUint32(4, Number(data.dwOriginatorChoice), true);
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: pointer
  if (data?.UserKeyingMaterial !== undefined) view.setBigUint64(16, data.UserKeyingMaterial === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.UserKeyingMaterial))), true);
  // 0x18: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(24, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x20: u32
  if (data?.cRecipientEncryptedKeys !== undefined) view.setUint32(32, Number(data.cRecipientEncryptedKeys), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgpRecipientEncryptedKeys !== undefined) view.setBigUint64(40, data.rgpRecipientEncryptedKeys === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpRecipientEncryptedKeys))), true);
  return buf;
}

export class CMSG_KEY_AGREE_RECIPIENT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwOriginatorChoice(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get UserKeyingMaterial(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cRecipientEncryptedKeys(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgpRecipientEncryptedKeys(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwOriginatorChoice(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set UserKeyingMaterial(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cRecipientEncryptedKeys(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgpRecipientEncryptedKeys(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_MAIL_LIST_RECIPIENT_INFO (size: 48)
 */
export interface CMSG_MAIL_LIST_RECIPIENT_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  KeyId: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedKey: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  Date: Uint8Array | Deno.PointerValue;
  /** ptr */
  pOtherAttr: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_MAIL_LIST_RECIPIENT_INFO = 48;

export function allocCMSG_MAIL_LIST_RECIPIENT_INFO(data?: Partial<CMSG_MAIL_LIST_RECIPIENT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_MAIL_LIST_RECIPIENT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.KeyId !== undefined) view.setBigUint64(8, data.KeyId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyId))), true);
  // 0x10: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(16, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x18: pointer
  if (data?.EncryptedKey !== undefined) view.setBigUint64(24, data.EncryptedKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedKey))), true);
  // 0x20: pointer
  if (data?.Date !== undefined) view.setBigUint64(32, data.Date === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Date))), true);
  // 0x28: pointer
  if (data?.pOtherAttr !== undefined) view.setBigUint64(40, data.pOtherAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pOtherAttr))), true);
  return buf;
}

export class CMSG_MAIL_LIST_RECIPIENT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get KeyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get EncryptedKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get Date(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pOtherAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set KeyId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set EncryptedKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set Date(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pOtherAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CMS_RECIPIENT_INFO (size: 16)
 */
export interface CMSG_CMS_RECIPIENT_INFO {
  /** u32 */
  dwRecipientChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_CMS_RECIPIENT_INFO = 16;

export function allocCMSG_CMS_RECIPIENT_INFO(data?: Partial<CMSG_CMS_RECIPIENT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CMS_RECIPIENT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwRecipientChoice !== undefined) view.setUint32(0, Number(data.dwRecipientChoice), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CMSG_CMS_RECIPIENT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwRecipientChoice(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwRecipientChoice(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA (size: 32)
 */
export interface CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwSignerIndex: number;
  /** u32 */
  dwSignerType: number;
  /** ptr */
  pvSigner: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = 32;

export function allocCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA(data?: Partial<CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x10: u32
  if (data?.dwSignerIndex !== undefined) view.setUint32(16, Number(data.dwSignerIndex), true);
  // 0x14: u32
  if (data?.dwSignerType !== undefined) view.setUint32(20, Number(data.dwSignerType), true);
  // 0x18: pointer
  if (data?.pvSigner !== undefined) view.setBigUint64(24, data.pvSigner === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvSigner))), true);
  return buf;
}

export class CMSG_CTRL_VERIFY_SIGNATURE_EX_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwSignerIndex(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwSignerType(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get pvSigner(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwSignerIndex(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwSignerType(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set pvSigner(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CTRL_DECRYPT_PARA (size: 24)
 */
export interface CMSG_CTRL_DECRYPT_PARA {
  /** u32 */
  cbSize: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwKeySpec: number;
  /** u32 */
  dwRecipientIndex: number;
}

export const sizeofCMSG_CTRL_DECRYPT_PARA = 24;

export function allocCMSG_CTRL_DECRYPT_PARA(data?: Partial<CMSG_CTRL_DECRYPT_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CTRL_DECRYPT_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(16, Number(data.dwKeySpec), true);
  // 0x14: u32
  if (data?.dwRecipientIndex !== undefined) view.setUint32(20, Number(data.dwRecipientIndex), true);
  return buf;
}

export class CMSG_CTRL_DECRYPT_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwKeySpec(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwRecipientIndex(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwRecipientIndex(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CTRL_KEY_TRANS_DECRYPT_PARA (size: 40)
 */
export interface CMSG_CTRL_KEY_TRANS_DECRYPT_PARA {
  /** u32 */
  cbSize: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwKeySpec: number;
  /** ptr */
  pKeyTrans: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwRecipientIndex: number;
}

export const sizeofCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = 40;

export function allocCMSG_CTRL_KEY_TRANS_DECRYPT_PARA(data?: Partial<CMSG_CTRL_KEY_TRANS_DECRYPT_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CTRL_KEY_TRANS_DECRYPT_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(16, Number(data.dwKeySpec), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pKeyTrans !== undefined) view.setBigUint64(24, data.pKeyTrans === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pKeyTrans))), true);
  // 0x20: u32
  if (data?.dwRecipientIndex !== undefined) view.setUint32(32, Number(data.dwRecipientIndex), true);
  // 0x24: pad4
  return buf;
}

export class CMSG_CTRL_KEY_TRANS_DECRYPT_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwKeySpec(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pKeyTrans(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwRecipientIndex(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pKeyTrans(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set dwRecipientIndex(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CTRL_KEY_AGREE_DECRYPT_PARA (size: 48)
 */
export interface CMSG_CTRL_KEY_AGREE_DECRYPT_PARA {
  /** u32 */
  cbSize: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwKeySpec: number;
  /** ptr */
  pKeyAgree: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwRecipientIndex: number;
  /** u32 */
  dwRecipientEncryptedKeyIndex: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  OriginatorPublicKey: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = 48;

export function allocCMSG_CTRL_KEY_AGREE_DECRYPT_PARA(data?: Partial<CMSG_CTRL_KEY_AGREE_DECRYPT_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CTRL_KEY_AGREE_DECRYPT_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(16, Number(data.dwKeySpec), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pKeyAgree !== undefined) view.setBigUint64(24, data.pKeyAgree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pKeyAgree))), true);
  // 0x20: u32
  if (data?.dwRecipientIndex !== undefined) view.setUint32(32, Number(data.dwRecipientIndex), true);
  // 0x24: u32
  if (data?.dwRecipientEncryptedKeyIndex !== undefined) view.setUint32(36, Number(data.dwRecipientEncryptedKeyIndex), true);
  // 0x28: pointer
  if (data?.OriginatorPublicKey !== undefined) view.setBigUint64(40, data.OriginatorPublicKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.OriginatorPublicKey))), true);
  return buf;
}

export class CMSG_CTRL_KEY_AGREE_DECRYPT_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwKeySpec(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pKeyAgree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwRecipientIndex(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: u32
  get dwRecipientEncryptedKeyIndex(): number {
    return this.view.getUint32(36, true);
  }

  // 0x28: pointer
  get OriginatorPublicKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pKeyAgree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set dwRecipientIndex(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: u32
  set dwRecipientEncryptedKeyIndex(value: number) {
    this.view.setUint32(36, value, true);
  }

  // 0x28: pointer
  set OriginatorPublicKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CTRL_MAIL_LIST_DECRYPT_PARA (size: 40)
 */
export interface CMSG_CTRL_MAIL_LIST_DECRYPT_PARA {
  /** u32 */
  cbSize: number;
  /** usize */
  hCryptProv: Deno.PointerValue;
  /** ptr */
  pMailList: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwRecipientIndex: number;
  /** u32 */
  dwKeyChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = 40;

export function allocCMSG_CTRL_MAIL_LIST_DECRYPT_PARA(data?: Partial<CMSG_CTRL_MAIL_LIST_DECRYPT_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CTRL_MAIL_LIST_DECRYPT_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: usize
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, BigInt(data.hCryptProv), true);
  // 0x10: pointer
  if (data?.pMailList !== undefined) view.setBigUint64(16, data.pMailList === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pMailList))), true);
  // 0x18: u32
  if (data?.dwRecipientIndex !== undefined) view.setUint32(24, Number(data.dwRecipientIndex), true);
  // 0x1c: u32
  if (data?.dwKeyChoice !== undefined) view.setUint32(28, Number(data.dwKeyChoice), true);
  // 0x20: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(32, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CMSG_CTRL_MAIL_LIST_DECRYPT_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: usize
  get hCryptProv(): Deno.PointerValue {
    return Number(this.view.getBigUint64(8, true));
  }

  // 0x10: pointer
  get pMailList(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwRecipientIndex(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get dwKeyChoice(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: usize
  set hCryptProv(value: Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(value), true);
  }

  // 0x10: pointer
  set pMailList(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwRecipientIndex(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set dwKeyChoice(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA (size: 16)
 */
export interface CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwSignerIndex: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  blob: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = 16;

export function allocCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA(data?: Partial<CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwSignerIndex !== undefined) view.setUint32(4, Number(data.dwSignerIndex), true);
  // 0x08: pointer
  if (data?.blob !== undefined) view.setBigUint64(8, data.blob === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.blob))), true);
  return buf;
}

export class CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwSignerIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get blob(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwSignerIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set blob(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA (size: 16)
 */
export interface CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwSignerIndex: number;
  /** u32 */
  dwUnauthAttrIndex: number;
}

export const sizeofCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = 16;

export function allocCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA(data?: Partial<CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwSignerIndex !== undefined) view.setUint32(4, Number(data.dwSignerIndex), true);
  // 0x08: u32
  if (data?.dwUnauthAttrIndex !== undefined) view.setUint32(8, Number(data.dwUnauthAttrIndex), true);
  // 0x0c: pad4
  return buf;
}

export class CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwSignerIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwUnauthAttrIndex(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwSignerIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwUnauthAttrIndex(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CONTENT_ENCRYPT_INFO (size: 112)
 */
export interface CMSG_CONTENT_ENCRYPT_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  ContentEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvEncryptionAuxInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cRecipients: number;
  /** ptr */
  rgCmsRecipients: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.PFN_CMSG_ALLOC */
  pfnAlloc: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CMSG_FREE */
  pfnFree: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwEncryptFlags: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwFlags: number;
  /** Windows.Win32.Foundation.BOOL */
  fCNG: boolean;
  /** ptr */
  pbCNGContentEncryptKeyObject: Deno.PointerValue | Uint8Array;
  /** ptr */
  pbContentEncryptKey: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbContentEncryptKey: number;
}

export const sizeofCMSG_CONTENT_ENCRYPT_INFO = 112;

export function allocCMSG_CONTENT_ENCRYPT_INFO(data?: Partial<CMSG_CONTENT_ENCRYPT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CONTENT_ENCRYPT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x10: pointer
  if (data?.ContentEncryptionAlgorithm !== undefined) view.setBigUint64(16, data.ContentEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ContentEncryptionAlgorithm))), true);
  // 0x18: pointer
  if (data?.pvEncryptionAuxInfo !== undefined) view.setBigUint64(24, data.pvEncryptionAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvEncryptionAuxInfo))), true);
  // 0x20: u32
  if (data?.cRecipients !== undefined) view.setUint32(32, Number(data.cRecipients), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgCmsRecipients !== undefined) view.setBigUint64(40, data.rgCmsRecipients === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCmsRecipients))), true);
  // 0x30: pointer
  if (data?.pfnAlloc !== undefined) view.setBigUint64(48, data.pfnAlloc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnAlloc))), true);
  // 0x38: pointer
  if (data?.pfnFree !== undefined) view.setBigUint64(56, data.pfnFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFree))), true);
  // 0x40: u32
  if (data?.dwEncryptFlags !== undefined) view.setUint32(64, Number(data.dwEncryptFlags), true);
  // 0x44: pad4
  // 0x48: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(72, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x50: u32
  if (data?.dwFlags !== undefined) view.setUint32(80, Number(data.dwFlags), true);
  // 0x54: i32
  if (data?.fCNG !== undefined) view.setInt32(84, Number(data.fCNG), true);
  // 0x58: pointer
  if (data?.pbCNGContentEncryptKeyObject !== undefined) view.setBigUint64(88, data.pbCNGContentEncryptKeyObject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbCNGContentEncryptKeyObject))), true);
  // 0x60: pointer
  if (data?.pbContentEncryptKey !== undefined) view.setBigUint64(96, data.pbContentEncryptKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbContentEncryptKey))), true);
  // 0x68: u32
  if (data?.cbContentEncryptKey !== undefined) view.setUint32(104, Number(data.cbContentEncryptKey), true);
  // 0x6c: pad4
  return buf;
}

export class CMSG_CONTENT_ENCRYPT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get ContentEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvEncryptionAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cRecipients(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgCmsRecipients(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get pfnAlloc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get pfnFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: u32
  get dwEncryptFlags(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: u32
  get dwFlags(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: i32
  get fCNG(): number {
    return this.view.getInt32(84, true);
  }

  // 0x58: pointer
  get pbCNGContentEncryptKeyObject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x60: pointer
  get pbContentEncryptKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(96, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x68: u32
  get cbContentEncryptKey(): number {
    return this.view.getUint32(104, true);
  }

  // 0x6c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set ContentEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvEncryptionAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cRecipients(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgCmsRecipients(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set pfnAlloc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set pfnFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: u32
  set dwEncryptFlags(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x50: u32
  set dwFlags(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: i32
  set fCNG(value: number) {
    this.view.setInt32(84, value, true);
  }

  // 0x58: pointer
  set pbCNGContentEncryptKeyObject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x60: pointer
  set pbContentEncryptKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(96, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x68: u32
  set cbContentEncryptKey(value: number) {
    this.view.setUint32(104, value, true);
  }

  // 0x6c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_KEY_TRANS_ENCRYPT_INFO (size: 32)
 */
export interface CMSG_KEY_TRANS_ENCRYPT_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwRecipientIndex: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedKey: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwFlags: number;
}

export const sizeofCMSG_KEY_TRANS_ENCRYPT_INFO = 32;

export function allocCMSG_KEY_TRANS_ENCRYPT_INFO(data?: Partial<CMSG_KEY_TRANS_ENCRYPT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_KEY_TRANS_ENCRYPT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwRecipientIndex !== undefined) view.setUint32(4, Number(data.dwRecipientIndex), true);
  // 0x08: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.EncryptedKey !== undefined) view.setBigUint64(16, data.EncryptedKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedKey))), true);
  // 0x18: u32
  if (data?.dwFlags !== undefined) view.setUint32(24, Number(data.dwFlags), true);
  // 0x1c: pad4
  return buf;
}

export class CMSG_KEY_TRANS_ENCRYPT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwRecipientIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get EncryptedKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwFlags(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwRecipientIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set EncryptedKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwFlags(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_KEY_AGREE_KEY_ENCRYPT_INFO (size: 16)
 */
export interface CMSG_KEY_AGREE_KEY_ENCRYPT_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedKey: Uint8Array | Deno.PointerValue;
}

export const sizeofCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = 16;

export function allocCMSG_KEY_AGREE_KEY_ENCRYPT_INFO(data?: Partial<CMSG_KEY_AGREE_KEY_ENCRYPT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_KEY_AGREE_KEY_ENCRYPT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.EncryptedKey !== undefined) view.setBigUint64(8, data.EncryptedKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedKey))), true);
  return buf;
}

export class CMSG_KEY_AGREE_KEY_ENCRYPT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get EncryptedKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set EncryptedKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_KEY_AGREE_ENCRYPT_INFO (size: 64)
 */
export interface CMSG_KEY_AGREE_ENCRYPT_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwRecipientIndex: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  UserKeyingMaterial: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CMSG_KEY_AGREE_ORIGINATOR */
  dwOriginatorChoice: CMSG_KEY_AGREE_ORIGINATOR;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  cKeyAgreeKeyEncryptInfo: number;
  /** ptr */
  rgpKeyAgreeKeyEncryptInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwFlags: number;
}

export const sizeofCMSG_KEY_AGREE_ENCRYPT_INFO = 64;

export function allocCMSG_KEY_AGREE_ENCRYPT_INFO(data?: Partial<CMSG_KEY_AGREE_ENCRYPT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_KEY_AGREE_ENCRYPT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwRecipientIndex !== undefined) view.setUint32(4, Number(data.dwRecipientIndex), true);
  // 0x08: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.UserKeyingMaterial !== undefined) view.setBigUint64(16, data.UserKeyingMaterial === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.UserKeyingMaterial))), true);
  // 0x18: u32
  if (data?.dwOriginatorChoice !== undefined) view.setUint32(24, Number(data.dwOriginatorChoice), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(32, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x28: u32
  if (data?.cKeyAgreeKeyEncryptInfo !== undefined) view.setUint32(40, Number(data.cKeyAgreeKeyEncryptInfo), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.rgpKeyAgreeKeyEncryptInfo !== undefined) view.setBigUint64(48, data.rgpKeyAgreeKeyEncryptInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpKeyAgreeKeyEncryptInfo))), true);
  // 0x38: u32
  if (data?.dwFlags !== undefined) view.setUint32(56, Number(data.dwFlags), true);
  // 0x3c: pad4
  return buf;
}

export class CMSG_KEY_AGREE_ENCRYPT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwRecipientIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get UserKeyingMaterial(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwOriginatorChoice(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get cKeyAgreeKeyEncryptInfo(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get rgpKeyAgreeKeyEncryptInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: u32
  get dwFlags(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwRecipientIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set UserKeyingMaterial(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwOriginatorChoice(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: u32
  set cKeyAgreeKeyEncryptInfo(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set rgpKeyAgreeKeyEncryptInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: u32
  set dwFlags(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_MAIL_LIST_ENCRYPT_INFO (size: 32)
 */
export interface CMSG_MAIL_LIST_ENCRYPT_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwRecipientIndex: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  KeyEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  EncryptedKey: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwFlags: number;
}

export const sizeofCMSG_MAIL_LIST_ENCRYPT_INFO = 32;

export function allocCMSG_MAIL_LIST_ENCRYPT_INFO(data?: Partial<CMSG_MAIL_LIST_ENCRYPT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_MAIL_LIST_ENCRYPT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwRecipientIndex !== undefined) view.setUint32(4, Number(data.dwRecipientIndex), true);
  // 0x08: pointer
  if (data?.KeyEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.KeyEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.KeyEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.EncryptedKey !== undefined) view.setBigUint64(16, data.EncryptedKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.EncryptedKey))), true);
  // 0x18: u32
  if (data?.dwFlags !== undefined) view.setUint32(24, Number(data.dwFlags), true);
  // 0x1c: pad4
  return buf;
}

export class CMSG_MAIL_LIST_ENCRYPT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwRecipientIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get KeyEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get EncryptedKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwFlags(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwRecipientIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set KeyEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set EncryptedKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwFlags(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CMSG_CNG_CONTENT_DECRYPT_INFO (size: 72)
 */
export interface CMSG_CNG_CONTENT_DECRYPT_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  ContentEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CMSG_ALLOC */
  pfnAlloc: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CMSG_FREE */
  pfnFree: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */
  hNCryptKey: Uint8Array | Deno.PointerValue;
  /** ptr */
  pbContentEncryptKey: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbContentEncryptKey: number;
  /** Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */
  hCNGContentEncryptKey: Uint8Array | Deno.PointerValue;
  /** ptr */
  pbCNGContentEncryptKeyObject: Deno.PointerValue | Uint8Array;
}

export const sizeofCMSG_CNG_CONTENT_DECRYPT_INFO = 72;

export function allocCMSG_CNG_CONTENT_DECRYPT_INFO(data?: Partial<CMSG_CNG_CONTENT_DECRYPT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCMSG_CNG_CONTENT_DECRYPT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.ContentEncryptionAlgorithm !== undefined) view.setBigUint64(8, data.ContentEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ContentEncryptionAlgorithm))), true);
  // 0x10: pointer
  if (data?.pfnAlloc !== undefined) view.setBigUint64(16, data.pfnAlloc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnAlloc))), true);
  // 0x18: pointer
  if (data?.pfnFree !== undefined) view.setBigUint64(24, data.pfnFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFree))), true);
  // 0x20: pointer
  if (data?.hNCryptKey !== undefined) view.setBigUint64(32, data.hNCryptKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hNCryptKey))), true);
  // 0x28: pointer
  if (data?.pbContentEncryptKey !== undefined) view.setBigUint64(40, data.pbContentEncryptKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbContentEncryptKey))), true);
  // 0x30: u32
  if (data?.cbContentEncryptKey !== undefined) view.setUint32(48, Number(data.cbContentEncryptKey), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.hCNGContentEncryptKey !== undefined) view.setBigUint64(56, data.hCNGContentEncryptKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCNGContentEncryptKey))), true);
  // 0x40: pointer
  if (data?.pbCNGContentEncryptKeyObject !== undefined) view.setBigUint64(64, data.pbCNGContentEncryptKeyObject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbCNGContentEncryptKeyObject))), true);
  return buf;
}

export class CMSG_CNG_CONTENT_DECRYPT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get ContentEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pfnAlloc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pfnFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get hNCryptKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pbContentEncryptKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cbContentEncryptKey(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get hCNGContentEncryptKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: pointer
  get pbCNGContentEncryptKeyObject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set ContentEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pfnAlloc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pfnFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set hNCryptKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pbContentEncryptKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cbContentEncryptKey(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set hCNGContentEncryptKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: pointer
  set pbCNGContentEncryptKeyObject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CONTEXT (size: 40)
 */
export interface CERT_CONTEXT {
  /** u32 */
  dwCertEncodingType: number;
  /** ptr */
  pbCertEncoded: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbCertEncoded: number;
  /** ptr */
  pCertInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hCertStore: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_CONTEXT = 40;

export function allocCERT_CONTEXT(data?: Partial<CERT_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwCertEncodingType !== undefined) view.setUint32(0, Number(data.dwCertEncodingType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbCertEncoded !== undefined) view.setBigUint64(8, data.pbCertEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbCertEncoded))), true);
  // 0x10: u32
  if (data?.cbCertEncoded !== undefined) view.setUint32(16, Number(data.cbCertEncoded), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pCertInfo !== undefined) view.setBigUint64(24, data.pCertInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertInfo))), true);
  // 0x20: pointer
  if (data?.hCertStore !== undefined) view.setBigUint64(32, data.hCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCertStore))), true);
  return buf;
}

export class CERT_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwCertEncodingType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbCertEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbCertEncoded(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pCertInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get hCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwCertEncodingType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbCertEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbCertEncoded(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pCertInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set hCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_CONTEXT (size: 40)
 */
export interface CRL_CONTEXT {
  /** u32 */
  dwCertEncodingType: number;
  /** ptr */
  pbCrlEncoded: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbCrlEncoded: number;
  /** ptr */
  pCrlInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hCertStore: Uint8Array | Deno.PointerValue;
}

export const sizeofCRL_CONTEXT = 40;

export function allocCRL_CONTEXT(data?: Partial<CRL_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwCertEncodingType !== undefined) view.setUint32(0, Number(data.dwCertEncodingType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbCrlEncoded !== undefined) view.setBigUint64(8, data.pbCrlEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbCrlEncoded))), true);
  // 0x10: u32
  if (data?.cbCrlEncoded !== undefined) view.setUint32(16, Number(data.cbCrlEncoded), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pCrlInfo !== undefined) view.setBigUint64(24, data.pCrlInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCrlInfo))), true);
  // 0x20: pointer
  if (data?.hCertStore !== undefined) view.setBigUint64(32, data.hCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCertStore))), true);
  return buf;
}

export class CRL_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwCertEncodingType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbCrlEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbCrlEncoded(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pCrlInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get hCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwCertEncodingType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbCrlEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbCrlEncoded(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pCrlInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set hCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_CONTEXT (size: 64)
 */
export interface CTL_CONTEXT {
  /** u32 */
  dwMsgAndCertEncodingType: number;
  /** ptr */
  pbCtlEncoded: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbCtlEncoded: number;
  /** ptr */
  pCtlInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hCertStore: Uint8Array | Deno.PointerValue;
  /** ptr */
  hCryptMsg: Deno.PointerValue | Uint8Array;
  /** ptr */
  pbCtlContent: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbCtlContent: number;
}

export const sizeofCTL_CONTEXT = 64;

export function allocCTL_CONTEXT(data?: Partial<CTL_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwMsgAndCertEncodingType !== undefined) view.setUint32(0, Number(data.dwMsgAndCertEncodingType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbCtlEncoded !== undefined) view.setBigUint64(8, data.pbCtlEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbCtlEncoded))), true);
  // 0x10: u32
  if (data?.cbCtlEncoded !== undefined) view.setUint32(16, Number(data.cbCtlEncoded), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pCtlInfo !== undefined) view.setBigUint64(24, data.pCtlInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCtlInfo))), true);
  // 0x20: pointer
  if (data?.hCertStore !== undefined) view.setBigUint64(32, data.hCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCertStore))), true);
  // 0x28: pointer
  if (data?.hCryptMsg !== undefined) view.setBigUint64(40, data.hCryptMsg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptMsg))), true);
  // 0x30: pointer
  if (data?.pbCtlContent !== undefined) view.setBigUint64(48, data.pbCtlContent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbCtlContent))), true);
  // 0x38: u32
  if (data?.cbCtlContent !== undefined) view.setUint32(56, Number(data.cbCtlContent), true);
  // 0x3c: pad4
  return buf;
}

export class CTL_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwMsgAndCertEncodingType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbCtlEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbCtlEncoded(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pCtlInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get hCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get hCryptMsg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get pbCtlContent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: u32
  get cbCtlContent(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x00: u32
  set dwMsgAndCertEncodingType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbCtlEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbCtlEncoded(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pCtlInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set hCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set hCryptMsg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set pbCtlContent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: u32
  set cbCtlContent(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_KEY_PROV_PARAM (size: 24)
 */
export interface CRYPT_KEY_PROV_PARAM {
  /** u32 */
  dwParam: number;
  /** ptr */
  pbData: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbData: number;
  /** u32 */
  dwFlags: number;
}

export const sizeofCRYPT_KEY_PROV_PARAM = 24;

export function allocCRYPT_KEY_PROV_PARAM(data?: Partial<CRYPT_KEY_PROV_PARAM>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_KEY_PROV_PARAM);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwParam !== undefined) view.setUint32(0, Number(data.dwParam), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbData !== undefined) view.setBigUint64(8, data.pbData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbData))), true);
  // 0x10: u32
  if (data?.cbData !== undefined) view.setUint32(16, Number(data.cbData), true);
  // 0x14: u32
  if (data?.dwFlags !== undefined) view.setUint32(20, Number(data.dwFlags), true);
  return buf;
}

export class CRYPT_KEY_PROV_PARAMView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwParam(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbData(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwFlags(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: u32
  set dwParam(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbData(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwFlags(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_KEY_PROV_INFO (size: 48)
 */
export interface CRYPT_KEY_PROV_INFO {
  /** Windows.Win32.Foundation.PWSTR */
  pwszContainerName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszProvName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwProvType: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_KEY_FLAGS */
  dwFlags: CRYPT_KEY_FLAGS;
  /** u32 */
  cProvParam: number;
  /** ptr */
  rgProvParam: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwKeySpec: number;
}

export const sizeofCRYPT_KEY_PROV_INFO = 48;

export function allocCRYPT_KEY_PROV_INFO(data?: Partial<CRYPT_KEY_PROV_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_KEY_PROV_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pwszContainerName !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.pwszContainerName);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.pwszProvName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszProvName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.dwProvType !== undefined) view.setUint32(16, Number(data.dwProvType), true);
  // 0x14: u32
  if (data?.dwFlags !== undefined) view.setUint32(20, Number(data.dwFlags), true);
  // 0x18: u32
  if (data?.cProvParam !== undefined) view.setUint32(24, Number(data.cProvParam), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgProvParam !== undefined) view.setBigUint64(32, data.rgProvParam === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgProvParam))), true);
  // 0x28: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(40, Number(data.dwKeySpec), true);
  // 0x2c: pad4
  return buf;
}

export class CRYPT_KEY_PROV_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pwszContainerName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pwszProvName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwProvType(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwFlags(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: u32
  get cProvParam(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgProvParam(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get dwKeySpec(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x00: buffer
  set pwszContainerName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set pwszProvName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set dwProvType(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwFlags(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: u32
  set cProvParam(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgProvParam(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_KEY_CONTEXT (size: 24)
 */
export interface CERT_KEY_CONTEXT {
  /** u32 */
  cbSize: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwKeySpec: number;
}

export const sizeofCERT_KEY_CONTEXT = 24;

export function allocCERT_KEY_CONTEXT(data?: Partial<CERT_KEY_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_KEY_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(16, Number(data.dwKeySpec), true);
  // 0x14: pad4
  return buf;
}

export class CERT_KEY_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwKeySpec(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.ROOT_INFO_LUID (size: 8)
 */
export interface ROOT_INFO_LUID {
  /** u32 */
  LowPart: number;
  /** i32 */
  HighPart: number;
}

export const sizeofROOT_INFO_LUID = 8;

export function allocROOT_INFO_LUID(data?: Partial<ROOT_INFO_LUID>): Uint8Array {
  const buf = new Uint8Array(sizeofROOT_INFO_LUID);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.LowPart !== undefined) view.setUint32(0, Number(data.LowPart), true);
  // 0x04: i32
  if (data?.HighPart !== undefined) view.setInt32(4, Number(data.HighPart), true);
  return buf;
}

export class ROOT_INFO_LUIDView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get LowPart(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get HighPart(): number {
    return this.view.getInt32(4, true);
  }

  // 0x00: u32
  set LowPart(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set HighPart(value: number) {
    this.view.setInt32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_SMART_CARD_ROOT_INFO (size: 16)
 */
export interface CRYPT_SMART_CARD_ROOT_INFO {
  /** array */
  rgbCardID: Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.ROOT_INFO_LUID */
  luid: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_SMART_CARD_ROOT_INFO = 16;

export function allocCRYPT_SMART_CARD_ROOT_INFO(data?: Partial<CRYPT_SMART_CARD_ROOT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_SMART_CARD_ROOT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.rgbCardID !== undefined) view.setBigUint64(0, data.rgbCardID === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgbCardID))), true);
  // 0x08: pointer
  if (data?.luid !== undefined) view.setBigUint64(8, data.luid === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.luid))), true);
  return buf;
}

export class CRYPT_SMART_CARD_ROOT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get rgbCardID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get luid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set rgbCardID(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set luid(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * _Anonymous1_e__Union (size: 64)
 */
export interface _Anonymous1_e__Union {
  /** usize */
  Data0: Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  String: string | null | Uint8Array | Uint16Array;
  /** usize */
  u: Deno.PointerValue;
  /** ptr */
  psid: Deno.PointerValue | Uint8Array;
  /** ptr */
  pguid: Deno.PointerValue | Uint8Array;
  /** u32 */
  LogonId_LowPart: number;
  /** ptr */
  pObjectTypes: Deno.PointerValue | Uint8Array;
  /** ptr */
  pIpAddress: Deno.PointerValue | Uint8Array;
}

export const sizeof_Anonymous1_e__Union = 64;

export function alloc_Anonymous1_e__Union(data?: Partial<_Anonymous1_e__Union>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous1_e__Union);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.Data0 !== undefined) view.setBigUint64(0, BigInt(data.Data0), true);
  // 0x08: buffer
  if (data?.String !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.String);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: usize
  if (data?.u !== undefined) view.setBigUint64(16, BigInt(data.u), true);
  // 0x18: pointer
  if (data?.psid !== undefined) view.setBigUint64(24, data.psid === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.psid))), true);
  // 0x20: pointer
  if (data?.pguid !== undefined) view.setBigUint64(32, data.pguid === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pguid))), true);
  // 0x28: u32
  if (data?.LogonId_LowPart !== undefined) view.setUint32(40, Number(data.LogonId_LowPart), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.pObjectTypes !== undefined) view.setBigUint64(48, data.pObjectTypes === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pObjectTypes))), true);
  // 0x38: pointer
  if (data?.pIpAddress !== undefined) view.setBigUint64(56, data.pIpAddress === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pIpAddress))), true);
  return buf;
}

export class _Anonymous1_e__UnionView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: usize
  get Data0(): Deno.PointerValue {
    return Number(this.view.getBigUint64(0, true));
  }

  // 0x08: buffer
  get String(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: usize
  get u(): Deno.PointerValue {
    return Number(this.view.getBigUint64(16, true));
  }

  // 0x18: pointer
  get psid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pguid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get LogonId_LowPart(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get pObjectTypes(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get pIpAddress(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: usize
  set Data0(value: Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(value), true);
  }

  // 0x08: buffer
  set String(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: usize
  set u(value: Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(value), true);
  }

  // 0x18: pointer
  set psid(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pguid(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: u32
  set LogonId_LowPart(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set pObjectTypes(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set pIpAddress(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * _Anonymous2_e__Union (size: 16)
 */
export interface _Anonymous2_e__Union {
  /** usize */
  Data1: Deno.PointerValue;
  /** i32 */
  LogonId_HighPart: number;
}

export const sizeof_Anonymous2_e__Union = 16;

export function alloc_Anonymous2_e__Union(data?: Partial<_Anonymous2_e__Union>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous2_e__Union);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.Data1 !== undefined) view.setBigUint64(0, BigInt(data.Data1), true);
  // 0x08: i32
  if (data?.LogonId_HighPart !== undefined) view.setInt32(8, Number(data.LogonId_HighPart), true);
  // 0x0c: pad4
  return buf;
}

export class _Anonymous2_e__UnionView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: usize
  get Data1(): Deno.PointerValue {
    return Number(this.view.getBigUint64(0, true));
  }

  // 0x08: i32
  get LogonId_HighPart(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x00: usize
  set Data1(value: Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(value), true);
  }

  // 0x08: i32
  set LogonId_HighPart(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SYSTEM_STORE_RELOCATE_PARA (size: 16)
 */
export interface CERT_SYSTEM_STORE_RELOCATE_PARA {
  /** _Anonymous1_e__Union */
  Anonymous1: Uint8Array | Deno.PointerValue;
  /** _Anonymous2_e__Union */
  Anonymous2: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_SYSTEM_STORE_RELOCATE_PARA = 16;

export function allocCERT_SYSTEM_STORE_RELOCATE_PARA(data?: Partial<CERT_SYSTEM_STORE_RELOCATE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SYSTEM_STORE_RELOCATE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Anonymous1 !== undefined) view.setBigUint64(0, data.Anonymous1 === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous1))), true);
  // 0x08: pointer
  if (data?.Anonymous2 !== undefined) view.setBigUint64(8, data.Anonymous2 === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous2))), true);
  return buf;
}

export class CERT_SYSTEM_STORE_RELOCATE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Anonymous1(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Anonymous2(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Anonymous1(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set Anonymous2(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

export type HKEY = Deno.PointerValue;

/**
 * Windows.Win32.Security.Cryptography.CERT_REGISTRY_STORE_CLIENT_GPT_PARA (size: 16)
 */
export interface CERT_REGISTRY_STORE_CLIENT_GPT_PARA {
  /** Windows.Win32.System.Registry.HKEY */
  hKeyBase: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pwszRegPath: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_REGISTRY_STORE_CLIENT_GPT_PARA = 16;

export function allocCERT_REGISTRY_STORE_CLIENT_GPT_PARA(data?: Partial<CERT_REGISTRY_STORE_CLIENT_GPT_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REGISTRY_STORE_CLIENT_GPT_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.hKeyBase !== undefined) view.setBigUint64(0, data.hKeyBase === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hKeyBase))), true);
  // 0x08: buffer
  if (data?.pwszRegPath !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszRegPath);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CERT_REGISTRY_STORE_CLIENT_GPT_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get hKeyBase(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pwszRegPath(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set hKeyBase(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: buffer
  set pwszRegPath(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_REGISTRY_STORE_ROAMING_PARA (size: 16)
 */
export interface CERT_REGISTRY_STORE_ROAMING_PARA {
  /** Windows.Win32.System.Registry.HKEY */
  hKey: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pwszStoreDirectory: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_REGISTRY_STORE_ROAMING_PARA = 16;

export function allocCERT_REGISTRY_STORE_ROAMING_PARA(data?: Partial<CERT_REGISTRY_STORE_ROAMING_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REGISTRY_STORE_ROAMING_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.hKey !== undefined) view.setBigUint64(0, data.hKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hKey))), true);
  // 0x08: buffer
  if (data?.pwszStoreDirectory !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszStoreDirectory);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CERT_REGISTRY_STORE_ROAMING_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get hKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pwszStoreDirectory(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set hKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: buffer
  set pwszStoreDirectory(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_LDAP_STORE_OPENED_PARA (size: 16)
 */
export interface CERT_LDAP_STORE_OPENED_PARA {
  /** ptr */
  pvLdapSessionHandle: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszLdapUrl: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_LDAP_STORE_OPENED_PARA = 16;

export function allocCERT_LDAP_STORE_OPENED_PARA(data?: Partial<CERT_LDAP_STORE_OPENED_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_LDAP_STORE_OPENED_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pvLdapSessionHandle !== undefined) view.setBigUint64(0, data.pvLdapSessionHandle === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvLdapSessionHandle))), true);
  // 0x08: buffer
  if (data?.pwszLdapUrl !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszLdapUrl);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CERT_LDAP_STORE_OPENED_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pvLdapSessionHandle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get pwszLdapUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pvLdapSessionHandle(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: buffer
  set pwszLdapUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_STORE_PROV_INFO (size: 40)
 */
export interface CERT_STORE_PROV_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  cStoreProvFunc: number;
  /** ptr */
  rgpvStoreProvFunc: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCERTSTOREPROV */
  hStoreProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_STORE_PROV_FLAGS */
  dwStoreProvFlags: CERT_STORE_PROV_FLAGS;
  /** ptr */
  hStoreProvFuncAddr2: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_STORE_PROV_INFO = 40;

export function allocCERT_STORE_PROV_INFO(data?: Partial<CERT_STORE_PROV_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_STORE_PROV_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.cStoreProvFunc !== undefined) view.setUint32(4, Number(data.cStoreProvFunc), true);
  // 0x08: pointer
  if (data?.rgpvStoreProvFunc !== undefined) view.setBigUint64(8, data.rgpvStoreProvFunc === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpvStoreProvFunc))), true);
  // 0x10: pointer
  if (data?.hStoreProv !== undefined) view.setBigUint64(16, data.hStoreProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hStoreProv))), true);
  // 0x18: u32
  if (data?.dwStoreProvFlags !== undefined) view.setUint32(24, Number(data.dwStoreProvFlags), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.hStoreProvFuncAddr2 !== undefined) view.setBigUint64(32, data.hStoreProvFuncAddr2 === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hStoreProvFuncAddr2))), true);
  return buf;
}

export class CERT_STORE_PROV_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cStoreProvFunc(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgpvStoreProvFunc(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hStoreProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwStoreProvFlags(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get hStoreProvFuncAddr2(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cStoreProvFunc(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgpvStoreProvFunc(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hStoreProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwStoreProvFlags(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set hStoreProvFuncAddr2(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_STORE_PROV_FIND_INFO (size: 24)
 */
export interface CERT_STORE_PROV_FIND_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMsgAndCertEncodingType: number;
  /** u32 */
  dwFindFlags: number;
  /** u32 */
  dwFindType: number;
  /** ptr */
  pvFindPara: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_STORE_PROV_FIND_INFO = 24;

export function allocCERT_STORE_PROV_FIND_INFO(data?: Partial<CERT_STORE_PROV_FIND_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_STORE_PROV_FIND_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgAndCertEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgAndCertEncodingType), true);
  // 0x08: u32
  if (data?.dwFindFlags !== undefined) view.setUint32(8, Number(data.dwFindFlags), true);
  // 0x0c: u32
  if (data?.dwFindType !== undefined) view.setUint32(12, Number(data.dwFindType), true);
  // 0x10: pointer
  if (data?.pvFindPara !== undefined) view.setBigUint64(16, data.pvFindPara === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvFindPara))), true);
  return buf;
}

export class CERT_STORE_PROV_FIND_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgAndCertEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwFindFlags(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwFindType(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: pointer
  get pvFindPara(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgAndCertEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwFindFlags(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwFindType(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: pointer
  set pvFindPara(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRL_FIND_ISSUED_FOR_PARA (size: 16)
 */
export interface CRL_FIND_ISSUED_FOR_PARA {
  /** ptr */
  pSubjectCert: Deno.PointerValue | Uint8Array;
  /** ptr */
  pIssuerCert: Deno.PointerValue | Uint8Array;
}

export const sizeofCRL_FIND_ISSUED_FOR_PARA = 16;

export function allocCRL_FIND_ISSUED_FOR_PARA(data?: Partial<CRL_FIND_ISSUED_FOR_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_FIND_ISSUED_FOR_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pSubjectCert !== undefined) view.setBigUint64(0, data.pSubjectCert === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pSubjectCert))), true);
  // 0x08: pointer
  if (data?.pIssuerCert !== undefined) view.setBigUint64(8, data.pIssuerCert === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pIssuerCert))), true);
  return buf;
}

export class CRL_FIND_ISSUED_FOR_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pSubjectCert(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pIssuerCert(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pSubjectCert(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pIssuerCert(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_ANY_SUBJECT_INFO (size: 16)
 */
export interface CTL_ANY_SUBJECT_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  SubjectAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SubjectIdentifier: Uint8Array | Deno.PointerValue;
}

export const sizeofCTL_ANY_SUBJECT_INFO = 16;

export function allocCTL_ANY_SUBJECT_INFO(data?: Partial<CTL_ANY_SUBJECT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_ANY_SUBJECT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.SubjectAlgorithm !== undefined) view.setBigUint64(0, data.SubjectAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectAlgorithm))), true);
  // 0x08: pointer
  if (data?.SubjectIdentifier !== undefined) view.setBigUint64(8, data.SubjectIdentifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectIdentifier))), true);
  return buf;
}

export class CTL_ANY_SUBJECT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get SubjectAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get SubjectIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set SubjectAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set SubjectIdentifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_FIND_USAGE_PARA (size: 32)
 */
export interface CTL_FIND_USAGE_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CTL_USAGE */
  SubjectUsage: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ListIdentifier: Uint8Array | Deno.PointerValue;
  /** ptr */
  pSigner: Deno.PointerValue | Uint8Array;
}

export const sizeofCTL_FIND_USAGE_PARA = 32;

export function allocCTL_FIND_USAGE_PARA(data?: Partial<CTL_FIND_USAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_FIND_USAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.SubjectUsage !== undefined) view.setBigUint64(8, data.SubjectUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SubjectUsage))), true);
  // 0x10: pointer
  if (data?.ListIdentifier !== undefined) view.setBigUint64(16, data.ListIdentifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ListIdentifier))), true);
  // 0x18: pointer
  if (data?.pSigner !== undefined) view.setBigUint64(24, data.pSigner === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pSigner))), true);
  return buf;
}

export class CTL_FIND_USAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get SubjectUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get ListIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pSigner(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set SubjectUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set ListIdentifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pSigner(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_FIND_SUBJECT_PARA (size: 32)
 */
export interface CTL_FIND_SUBJECT_PARA {
  /** u32 */
  cbSize: number;
  /** ptr */
  pUsagePara: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwSubjectType: number;
  /** ptr */
  pvSubject: Deno.PointerValue | Uint8Array;
}

export const sizeofCTL_FIND_SUBJECT_PARA = 32;

export function allocCTL_FIND_SUBJECT_PARA(data?: Partial<CTL_FIND_SUBJECT_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_FIND_SUBJECT_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pUsagePara !== undefined) view.setBigUint64(8, data.pUsagePara === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pUsagePara))), true);
  // 0x10: u32
  if (data?.dwSubjectType !== undefined) view.setUint32(16, Number(data.dwSubjectType), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pvSubject !== undefined) view.setBigUint64(24, data.pvSubject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvSubject))), true);
  return buf;
}

export class CTL_FIND_SUBJECT_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pUsagePara(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwSubjectType(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pvSubject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pUsagePara(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwSubjectType(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pvSubject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CREATE_CONTEXT_PARA (size: 40)
 */
export interface CERT_CREATE_CONTEXT_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_FREE */
  pfnFree: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvFree: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.PFN_CERT_CREATE_CONTEXT_SORT_FUNC */
  pfnSort: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvSort: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_CREATE_CONTEXT_PARA = 40;

export function allocCERT_CREATE_CONTEXT_PARA(data?: Partial<CERT_CREATE_CONTEXT_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CREATE_CONTEXT_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pfnFree !== undefined) view.setBigUint64(8, data.pfnFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFree))), true);
  // 0x10: pointer
  if (data?.pvFree !== undefined) view.setBigUint64(16, data.pvFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvFree))), true);
  // 0x18: pointer
  if (data?.pfnSort !== undefined) view.setBigUint64(24, data.pfnSort === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnSort))), true);
  // 0x20: pointer
  if (data?.pvSort !== undefined) view.setBigUint64(32, data.pvSort === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvSort))), true);
  return buf;
}

export class CERT_CREATE_CONTEXT_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pfnFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pfnSort(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pvSort(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pfnFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pvFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pfnSort(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pvSort(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SYSTEM_STORE_INFO (size: 8)
 */
export interface CERT_SYSTEM_STORE_INFO {
  /** u32 */
  cbSize: number;
}

export const sizeofCERT_SYSTEM_STORE_INFO = 8;

export function allocCERT_SYSTEM_STORE_INFO(data?: Partial<CERT_SYSTEM_STORE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SYSTEM_STORE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  return buf;
}

export class CERT_SYSTEM_STORE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_PHYSICAL_STORE_INFO (size: 40)
 */
export interface CERT_PHYSICAL_STORE_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PSTR */
  pszOpenStoreProvider: string | null | Uint8Array;
  /** u32 */
  dwOpenEncodingType: number;
  /** u32 */
  dwOpenFlags: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  OpenParameters: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwPriority: number;
}

export const sizeofCERT_PHYSICAL_STORE_INFO = 40;

export function allocCERT_PHYSICAL_STORE_INFO(data?: Partial<CERT_PHYSICAL_STORE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_PHYSICAL_STORE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszOpenStoreProvider !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszOpenStoreProvider);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.dwOpenEncodingType !== undefined) view.setUint32(16, Number(data.dwOpenEncodingType), true);
  // 0x14: u32
  if (data?.dwOpenFlags !== undefined) view.setUint32(20, Number(data.dwOpenFlags), true);
  // 0x18: pointer
  if (data?.OpenParameters !== undefined) view.setBigUint64(24, data.OpenParameters === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.OpenParameters))), true);
  // 0x20: u32
  if (data?.dwFlags !== undefined) view.setUint32(32, Number(data.dwFlags), true);
  // 0x24: u32
  if (data?.dwPriority !== undefined) view.setUint32(36, Number(data.dwPriority), true);
  return buf;
}

export class CERT_PHYSICAL_STORE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszOpenStoreProvider(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwOpenEncodingType(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwOpenFlags(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get OpenParameters(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwFlags(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: u32
  get dwPriority(): number {
    return this.view.getUint32(36, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszOpenStoreProvider(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set dwOpenEncodingType(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwOpenFlags(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set OpenParameters(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set dwFlags(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: u32
  set dwPriority(value: number) {
    this.view.setUint32(36, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_VERIFY_USAGE_PARA (size: 48)
 */
export interface CTL_VERIFY_USAGE_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ListIdentifier: Uint8Array | Deno.PointerValue;
  /** u32 */
  cCtlStore: number;
  /** ptr */
  rghCtlStore: Deno.PointerValue | Uint8Array;
  /** u32 */
  cSignerStore: number;
  /** ptr */
  rghSignerStore: Deno.PointerValue | Uint8Array;
}

export const sizeofCTL_VERIFY_USAGE_PARA = 48;

export function allocCTL_VERIFY_USAGE_PARA(data?: Partial<CTL_VERIFY_USAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_VERIFY_USAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.ListIdentifier !== undefined) view.setBigUint64(8, data.ListIdentifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ListIdentifier))), true);
  // 0x10: u32
  if (data?.cCtlStore !== undefined) view.setUint32(16, Number(data.cCtlStore), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rghCtlStore !== undefined) view.setBigUint64(24, data.rghCtlStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghCtlStore))), true);
  // 0x20: u32
  if (data?.cSignerStore !== undefined) view.setUint32(32, Number(data.cSignerStore), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rghSignerStore !== undefined) view.setBigUint64(40, data.rghSignerStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghSignerStore))), true);
  return buf;
}

export class CTL_VERIFY_USAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get ListIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cCtlStore(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rghCtlStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cSignerStore(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rghSignerStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set ListIdentifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cCtlStore(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rghCtlStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cSignerStore(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rghSignerStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_VERIFY_USAGE_STATUS (size: 48)
 */
export interface CTL_VERIFY_USAGE_STATUS {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwError: number;
  /** u32 */
  dwFlags: number;
  /** ptr */
  ppCtl: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwCtlEntryIndex: number;
  /** ptr */
  ppSigner: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwSignerIndex: number;
}

export const sizeofCTL_VERIFY_USAGE_STATUS = 48;

export function allocCTL_VERIFY_USAGE_STATUS(data?: Partial<CTL_VERIFY_USAGE_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_VERIFY_USAGE_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwError !== undefined) view.setUint32(4, Number(data.dwError), true);
  // 0x08: u32
  if (data?.dwFlags !== undefined) view.setUint32(8, Number(data.dwFlags), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.ppCtl !== undefined) view.setBigUint64(16, data.ppCtl === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ppCtl))), true);
  // 0x18: u32
  if (data?.dwCtlEntryIndex !== undefined) view.setUint32(24, Number(data.dwCtlEntryIndex), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.ppSigner !== undefined) view.setBigUint64(32, data.ppSigner === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ppSigner))), true);
  // 0x28: u32
  if (data?.dwSignerIndex !== undefined) view.setUint32(40, Number(data.dwSignerIndex), true);
  // 0x2c: pad4
  return buf;
}

export class CTL_VERIFY_USAGE_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwError(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwFlags(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get ppCtl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwCtlEntryIndex(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get ppSigner(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get dwSignerIndex(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwError(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwFlags(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set ppCtl(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwCtlEntryIndex(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set ppSigner(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: u32
  set dwSignerIndex(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_REVOCATION_CRL_INFO (size: 40)
 */
export interface CERT_REVOCATION_CRL_INFO {
  /** u32 */
  cbSize: number;
  /** ptr */
  pBaseCrlContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  pDeltaCrlContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  pCrlEntry: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fDeltaCrlEntry: boolean;
}

export const sizeofCERT_REVOCATION_CRL_INFO = 40;

export function allocCERT_REVOCATION_CRL_INFO(data?: Partial<CERT_REVOCATION_CRL_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REVOCATION_CRL_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pBaseCrlContext !== undefined) view.setBigUint64(8, data.pBaseCrlContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pBaseCrlContext))), true);
  // 0x10: pointer
  if (data?.pDeltaCrlContext !== undefined) view.setBigUint64(16, data.pDeltaCrlContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pDeltaCrlContext))), true);
  // 0x18: pointer
  if (data?.pCrlEntry !== undefined) view.setBigUint64(24, data.pCrlEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCrlEntry))), true);
  // 0x20: i32
  if (data?.fDeltaCrlEntry !== undefined) view.setInt32(32, Number(data.fDeltaCrlEntry), true);
  // 0x24: pad4
  return buf;
}

export class CERT_REVOCATION_CRL_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pBaseCrlContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pDeltaCrlContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pCrlEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: i32
  get fDeltaCrlEntry(): number {
    return this.view.getInt32(32, true);
  }

  // 0x24: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pBaseCrlContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pDeltaCrlContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pCrlEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: i32
  set fDeltaCrlEntry(value: number) {
    this.view.setInt32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_REVOCATION_PARA (size: 48)
 */
export interface CERT_REVOCATION_PARA {
  /** u32 */
  cbSize: number;
  /** ptr */
  pIssuerCert: Deno.PointerValue | Uint8Array;
  /** u32 */
  cCertStore: number;
  /** ptr */
  rgCertStore: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hCrlStore: Uint8Array | Deno.PointerValue;
  /** ptr */
  pftTimeToUse: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_REVOCATION_PARA = 48;

export function allocCERT_REVOCATION_PARA(data?: Partial<CERT_REVOCATION_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REVOCATION_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pIssuerCert !== undefined) view.setBigUint64(8, data.pIssuerCert === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pIssuerCert))), true);
  // 0x10: u32
  if (data?.cCertStore !== undefined) view.setUint32(16, Number(data.cCertStore), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgCertStore !== undefined) view.setBigUint64(24, data.rgCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCertStore))), true);
  // 0x20: pointer
  if (data?.hCrlStore !== undefined) view.setBigUint64(32, data.hCrlStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCrlStore))), true);
  // 0x28: pointer
  if (data?.pftTimeToUse !== undefined) view.setBigUint64(40, data.pftTimeToUse === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pftTimeToUse))), true);
  return buf;
}

export class CERT_REVOCATION_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pIssuerCert(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cCertStore(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get hCrlStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pftTimeToUse(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pIssuerCert(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cCertStore(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set hCrlStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pftTimeToUse(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_REVOCATION_STATUS (size: 24)
 */
export interface CERT_REVOCATION_STATUS {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwIndex: number;
  /** u32 */
  dwError: number;
  /** Windows.Win32.Security.Cryptography.CERT_REVOCATION_STATUS_REASON */
  dwReason: CERT_REVOCATION_STATUS_REASON;
  /** Windows.Win32.Foundation.BOOL */
  fHasFreshnessTime: boolean;
  /** u32 */
  dwFreshnessTime: number;
}

export const sizeofCERT_REVOCATION_STATUS = 24;

export function allocCERT_REVOCATION_STATUS(data?: Partial<CERT_REVOCATION_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REVOCATION_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwIndex !== undefined) view.setUint32(4, Number(data.dwIndex), true);
  // 0x08: u32
  if (data?.dwError !== undefined) view.setUint32(8, Number(data.dwError), true);
  // 0x0c: u32
  if (data?.dwReason !== undefined) view.setUint32(12, Number(data.dwReason), true);
  // 0x10: i32
  if (data?.fHasFreshnessTime !== undefined) view.setInt32(16, Number(data.fHasFreshnessTime), true);
  // 0x14: u32
  if (data?.dwFreshnessTime !== undefined) view.setUint32(20, Number(data.dwFreshnessTime), true);
  return buf;
}

export class CERT_REVOCATION_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwIndex(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwError(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwReason(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: i32
  get fHasFreshnessTime(): number {
    return this.view.getInt32(16, true);
  }

  // 0x14: u32
  get dwFreshnessTime(): number {
    return this.view.getUint32(20, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwIndex(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwError(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwReason(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: i32
  set fHasFreshnessTime(value: number) {
    this.view.setInt32(16, value, true);
  }

  // 0x14: u32
  set dwFreshnessTime(value: number) {
    this.view.setUint32(20, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO (size: 16)
 */
export interface CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO {
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  CertSignHashCNGAlgPropData: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  CertIssuerPubKeyBitLengthPropData: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = 16;

export function allocCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO(data?: Partial<CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.CertSignHashCNGAlgPropData !== undefined) view.setBigUint64(0, data.CertSignHashCNGAlgPropData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CertSignHashCNGAlgPropData))), true);
  // 0x08: pointer
  if (data?.CertIssuerPubKeyBitLengthPropData !== undefined) view.setBigUint64(8, data.CertIssuerPubKeyBitLengthPropData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.CertIssuerPubKeyBitLengthPropData))), true);
  return buf;
}

export class CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get CertSignHashCNGAlgPropData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get CertIssuerPubKeyBitLengthPropData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set CertSignHashCNGAlgPropData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set CertIssuerPubKeyBitLengthPropData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO (size: 24)
 */
export interface CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO {
  /** u32 */
  cCNGHashAlgid: number;
  /** ptr */
  rgpwszCNGHashAlgid: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwWeakIndex: number;
}

export const sizeofCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = 24;

export function allocCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO(data?: Partial<CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cCNGHashAlgid !== undefined) view.setUint32(0, Number(data.cCNGHashAlgid), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpwszCNGHashAlgid !== undefined) view.setBigUint64(8, data.rgpwszCNGHashAlgid === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpwszCNGHashAlgid))), true);
  // 0x10: u32
  if (data?.dwWeakIndex !== undefined) view.setUint32(16, Number(data.dwWeakIndex), true);
  // 0x14: pad4
  return buf;
}

export class CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cCNGHashAlgid(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpwszCNGHashAlgid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwWeakIndex(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set cCNGHashAlgid(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpwszCNGHashAlgid(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwWeakIndex(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA (size: 16)
 */
export interface CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA {
  /** u32 */
  cOID: number;
  /** ptr */
  rgpszOID: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = 16;

export function allocCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA(data?: Partial<CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cOID !== undefined) view.setUint32(0, Number(data.cOID), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpszOID !== undefined) view.setBigUint64(8, data.rgpszOID === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszOID))), true);
  return buf;
}

export class CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cOID(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpszOID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cOID(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpszOID(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_SIGN_MESSAGE_PARA (size: 104)
 */
export interface CRYPT_SIGN_MESSAGE_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMsgEncodingType: number;
  /** ptr */
  pSigningCert: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvHashAuxInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cMsgCert: number;
  /** ptr */
  rgpMsgCert: Deno.PointerValue | Uint8Array;
  /** u32 */
  cMsgCrl: number;
  /** ptr */
  rgpMsgCrl: Deno.PointerValue | Uint8Array;
  /** u32 */
  cAuthAttr: number;
  /** ptr */
  rgAuthAttr: Deno.PointerValue | Uint8Array;
  /** u32 */
  cUnauthAttr: number;
  /** ptr */
  rgUnauthAttr: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwInnerContentType: number;
}

export const sizeofCRYPT_SIGN_MESSAGE_PARA = 104;

export function allocCRYPT_SIGN_MESSAGE_PARA(data?: Partial<CRYPT_SIGN_MESSAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_SIGN_MESSAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgEncodingType), true);
  // 0x08: pointer
  if (data?.pSigningCert !== undefined) view.setBigUint64(8, data.pSigningCert === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pSigningCert))), true);
  // 0x10: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(16, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x18: pointer
  if (data?.pvHashAuxInfo !== undefined) view.setBigUint64(24, data.pvHashAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvHashAuxInfo))), true);
  // 0x20: u32
  if (data?.cMsgCert !== undefined) view.setUint32(32, Number(data.cMsgCert), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgpMsgCert !== undefined) view.setBigUint64(40, data.rgpMsgCert === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpMsgCert))), true);
  // 0x30: u32
  if (data?.cMsgCrl !== undefined) view.setUint32(48, Number(data.cMsgCrl), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.rgpMsgCrl !== undefined) view.setBigUint64(56, data.rgpMsgCrl === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpMsgCrl))), true);
  // 0x40: u32
  if (data?.cAuthAttr !== undefined) view.setUint32(64, Number(data.cAuthAttr), true);
  // 0x44: pad4
  // 0x48: pointer
  if (data?.rgAuthAttr !== undefined) view.setBigUint64(72, data.rgAuthAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgAuthAttr))), true);
  // 0x50: u32
  if (data?.cUnauthAttr !== undefined) view.setUint32(80, Number(data.cUnauthAttr), true);
  // 0x54: pad4
  // 0x58: pointer
  if (data?.rgUnauthAttr !== undefined) view.setBigUint64(88, data.rgUnauthAttr === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgUnauthAttr))), true);
  // 0x60: u32
  if (data?.dwFlags !== undefined) view.setUint32(96, Number(data.dwFlags), true);
  // 0x64: u32
  if (data?.dwInnerContentType !== undefined) view.setUint32(100, Number(data.dwInnerContentType), true);
  return buf;
}

export class CRYPT_SIGN_MESSAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pSigningCert(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvHashAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cMsgCert(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgpMsgCert(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cMsgCrl(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get rgpMsgCrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: u32
  get cAuthAttr(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  get rgAuthAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: u32
  get cUnauthAttr(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  get rgUnauthAttr(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x60: u32
  get dwFlags(): number {
    return this.view.getUint32(96, true);
  }

  // 0x64: u32
  get dwInnerContentType(): number {
    return this.view.getUint32(100, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pSigningCert(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvHashAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cMsgCert(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgpMsgCert(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cMsgCrl(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set rgpMsgCrl(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: u32
  set cAuthAttr(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  set rgAuthAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x50: u32
  set cUnauthAttr(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  set rgUnauthAttr(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x60: u32
  set dwFlags(value: number) {
    this.view.setUint32(96, value, true);
  }

  // 0x64: u32
  set dwInnerContentType(value: number) {
    this.view.setUint32(100, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_VERIFY_MESSAGE_PARA (size: 32)
 */
export interface CRYPT_VERIFY_MESSAGE_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMsgAndCertEncodingType: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_GET_SIGNER_CERTIFICATE */
  pfnGetSignerCertificate: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvGetArg: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_VERIFY_MESSAGE_PARA = 32;

export function allocCRYPT_VERIFY_MESSAGE_PARA(data?: Partial<CRYPT_VERIFY_MESSAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_VERIFY_MESSAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgAndCertEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgAndCertEncodingType), true);
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x10: pointer
  if (data?.pfnGetSignerCertificate !== undefined) view.setBigUint64(16, data.pfnGetSignerCertificate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnGetSignerCertificate))), true);
  // 0x18: pointer
  if (data?.pvGetArg !== undefined) view.setBigUint64(24, data.pvGetArg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvGetArg))), true);
  return buf;
}

export class CRYPT_VERIFY_MESSAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgAndCertEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pfnGetSignerCertificate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvGetArg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgAndCertEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pfnGetSignerCertificate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvGetArg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ENCRYPT_MESSAGE_PARA (size: 40)
 */
export interface CRYPT_ENCRYPT_MESSAGE_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMsgEncodingType: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  ContentEncryptionAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvEncryptionAuxInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwInnerContentType: number;
}

export const sizeofCRYPT_ENCRYPT_MESSAGE_PARA = 40;

export function allocCRYPT_ENCRYPT_MESSAGE_PARA(data?: Partial<CRYPT_ENCRYPT_MESSAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ENCRYPT_MESSAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgEncodingType), true);
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x10: pointer
  if (data?.ContentEncryptionAlgorithm !== undefined) view.setBigUint64(16, data.ContentEncryptionAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ContentEncryptionAlgorithm))), true);
  // 0x18: pointer
  if (data?.pvEncryptionAuxInfo !== undefined) view.setBigUint64(24, data.pvEncryptionAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvEncryptionAuxInfo))), true);
  // 0x20: u32
  if (data?.dwFlags !== undefined) view.setUint32(32, Number(data.dwFlags), true);
  // 0x24: u32
  if (data?.dwInnerContentType !== undefined) view.setUint32(36, Number(data.dwInnerContentType), true);
  return buf;
}

export class CRYPT_ENCRYPT_MESSAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get ContentEncryptionAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvEncryptionAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwFlags(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: u32
  get dwInnerContentType(): number {
    return this.view.getUint32(36, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set ContentEncryptionAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvEncryptionAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set dwFlags(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: u32
  set dwInnerContentType(value: number) {
    this.view.setUint32(36, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_DECRYPT_MESSAGE_PARA (size: 24)
 */
export interface CRYPT_DECRYPT_MESSAGE_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMsgAndCertEncodingType: number;
  /** u32 */
  cCertStore: number;
  /** ptr */
  rghCertStore: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_DECRYPT_MESSAGE_PARA = 24;

export function allocCRYPT_DECRYPT_MESSAGE_PARA(data?: Partial<CRYPT_DECRYPT_MESSAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_DECRYPT_MESSAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgAndCertEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgAndCertEncodingType), true);
  // 0x08: u32
  if (data?.cCertStore !== undefined) view.setUint32(8, Number(data.cCertStore), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rghCertStore !== undefined) view.setBigUint64(16, data.rghCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghCertStore))), true);
  return buf;
}

export class CRYPT_DECRYPT_MESSAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgAndCertEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cCertStore(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rghCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgAndCertEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cCertStore(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rghCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_HASH_MESSAGE_PARA (size: 32)
 */
export interface CRYPT_HASH_MESSAGE_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMsgEncodingType: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvHashAuxInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_HASH_MESSAGE_PARA = 32;

export function allocCRYPT_HASH_MESSAGE_PARA(data?: Partial<CRYPT_HASH_MESSAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_HASH_MESSAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgEncodingType), true);
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  // 0x10: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(16, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x18: pointer
  if (data?.pvHashAuxInfo !== undefined) view.setBigUint64(24, data.pvHashAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvHashAuxInfo))), true);
  return buf;
}

export class CRYPT_HASH_MESSAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvHashAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvHashAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_KEY_SIGN_MESSAGE_PARA (size: 48)
 */
export interface CRYPT_KEY_SIGN_MESSAGE_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CERT_QUERY_ENCODING_TYPE */
  dwMsgAndCertEncodingType: CERT_QUERY_ENCODING_TYPE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CERT_KEY_SPEC */
  dwKeySpec: CERT_KEY_SPEC;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvHashAuxInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  PubKeyAlgorithm: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_KEY_SIGN_MESSAGE_PARA = 48;

export function allocCRYPT_KEY_SIGN_MESSAGE_PARA(data?: Partial<CRYPT_KEY_SIGN_MESSAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_KEY_SIGN_MESSAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgAndCertEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgAndCertEncodingType), true);
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(16, Number(data.dwKeySpec), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(24, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x20: pointer
  if (data?.pvHashAuxInfo !== undefined) view.setBigUint64(32, data.pvHashAuxInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvHashAuxInfo))), true);
  // 0x28: pointer
  if (data?.PubKeyAlgorithm !== undefined) view.setBigUint64(40, data.PubKeyAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PubKeyAlgorithm))), true);
  return buf;
}

export class CRYPT_KEY_SIGN_MESSAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgAndCertEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwKeySpec(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pvHashAuxInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get PubKeyAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgAndCertEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pvHashAuxInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set PubKeyAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_KEY_VERIFY_MESSAGE_PARA (size: 16)
 */
export interface CRYPT_KEY_VERIFY_MESSAGE_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwMsgEncodingType: number;
  /** Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */
  hCryptProv: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_KEY_VERIFY_MESSAGE_PARA = 16;

export function allocCRYPT_KEY_VERIFY_MESSAGE_PARA(data?: Partial<CRYPT_KEY_VERIFY_MESSAGE_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_KEY_VERIFY_MESSAGE_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwMsgEncodingType !== undefined) view.setUint32(4, Number(data.dwMsgEncodingType), true);
  // 0x08: pointer
  if (data?.hCryptProv !== undefined) view.setBigUint64(8, data.hCryptProv === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hCryptProv))), true);
  return buf;
}

export class CRYPT_KEY_VERIFY_MESSAGE_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMsgEncodingType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get hCryptProv(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMsgEncodingType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set hCryptProv(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN (size: 24)
 */
export interface CERT_CHAIN {
  /** u32 */
  cCerts: number;
  /** ptr */
  certs: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_KEY_PROV_INFO */
  keyLocatorInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_CHAIN = 24;

export function allocCERT_CHAIN(data?: Partial<CERT_CHAIN>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cCerts !== undefined) view.setUint32(0, Number(data.cCerts), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.certs !== undefined) view.setBigUint64(8, data.certs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.certs))), true);
  // 0x10: pointer
  if (data?.keyLocatorInfo !== undefined) view.setBigUint64(16, data.keyLocatorInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.keyLocatorInfo))), true);
  return buf;
}

export class CERT_CHAINView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cCerts(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get certs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get keyLocatorInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cCerts(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set certs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set keyLocatorInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_BLOB_ARRAY (size: 16)
 */
export interface CRYPT_BLOB_ARRAY {
  /** u32 */
  cBlob: number;
  /** ptr */
  rgBlob: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_BLOB_ARRAY = 16;

export function allocCRYPT_BLOB_ARRAY(data?: Partial<CRYPT_BLOB_ARRAY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_BLOB_ARRAY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cBlob !== undefined) view.setUint32(0, Number(data.cBlob), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgBlob !== undefined) view.setBigUint64(8, data.rgBlob === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgBlob))), true);
  return buf;
}

export class CRYPT_BLOB_ARRAYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cBlob(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgBlob(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cBlob(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgBlob(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_CREDENTIALS (size: 24)
 */
export interface CRYPT_CREDENTIALS {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PSTR */
  pszCredentialsOid: string | null | Uint8Array;
  /** ptr */
  pvCredentials: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_CREDENTIALS = 24;

export function allocCRYPT_CREDENTIALS(data?: Partial<CRYPT_CREDENTIALS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_CREDENTIALS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszCredentialsOid !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszCredentialsOid);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.pvCredentials !== undefined) view.setBigUint64(16, data.pvCredentials === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvCredentials))), true);
  return buf;
}

export class CRYPT_CREDENTIALSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszCredentialsOid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvCredentials(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszCredentialsOid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set pvCredentials(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PASSWORD_CREDENTIALSA (size: 24)
 */
export interface CRYPT_PASSWORD_CREDENTIALSA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PSTR */
  pszUsername: string | null | Uint8Array;
  /** Windows.Win32.Foundation.PSTR */
  pszPassword: string | null | Uint8Array;
}

export const sizeofCRYPT_PASSWORD_CREDENTIALSA = 24;

export function allocCRYPT_PASSWORD_CREDENTIALSA(data?: Partial<CRYPT_PASSWORD_CREDENTIALSA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PASSWORD_CREDENTIALSA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszUsername !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszUsername);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pszPassword !== undefined) {
    (buf as any)._f16 = util.pstrToFfi(data.pszPassword);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class CRYPT_PASSWORD_CREDENTIALSAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszUsername(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pszPassword(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszUsername(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pszPassword(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PASSWORD_CREDENTIALSW (size: 24)
 */
export interface CRYPT_PASSWORD_CREDENTIALSW {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  pszUsername: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pszPassword: string | null | Uint8Array | Uint16Array;
}

export const sizeofCRYPT_PASSWORD_CREDENTIALSW = 24;

export function allocCRYPT_PASSWORD_CREDENTIALSW(data?: Partial<CRYPT_PASSWORD_CREDENTIALSW>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PASSWORD_CREDENTIALSW);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszUsername !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pszUsername);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pszPassword !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pszPassword);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class CRYPT_PASSWORD_CREDENTIALSWView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszUsername(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pszPassword(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszUsername(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pszPassword(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPTNET_URL_CACHE_PRE_FETCH_INFO (size: 40)
 */
export interface CRYPTNET_URL_CACHE_PRE_FETCH_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwObjectType: number;
  /** u32 */
  dwError: number;
  /** u32 */
  dwReserved: number;
  /** Windows.Win32.Foundation.FILETIME */
  ThisUpdateTime: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  NextUpdateTime: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  PublishTime: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPTNET_URL_CACHE_PRE_FETCH_INFO = 40;

export function allocCRYPTNET_URL_CACHE_PRE_FETCH_INFO(data?: Partial<CRYPTNET_URL_CACHE_PRE_FETCH_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTNET_URL_CACHE_PRE_FETCH_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwObjectType !== undefined) view.setUint32(4, Number(data.dwObjectType), true);
  // 0x08: u32
  if (data?.dwError !== undefined) view.setUint32(8, Number(data.dwError), true);
  // 0x0c: u32
  if (data?.dwReserved !== undefined) view.setUint32(12, Number(data.dwReserved), true);
  // 0x10: pointer
  if (data?.ThisUpdateTime !== undefined) view.setBigUint64(16, data.ThisUpdateTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ThisUpdateTime))), true);
  // 0x18: pointer
  if (data?.NextUpdateTime !== undefined) view.setBigUint64(24, data.NextUpdateTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.NextUpdateTime))), true);
  // 0x20: pointer
  if (data?.PublishTime !== undefined) view.setBigUint64(32, data.PublishTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.PublishTime))), true);
  return buf;
}

export class CRYPTNET_URL_CACHE_PRE_FETCH_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwObjectType(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwError(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwReserved(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: pointer
  get ThisUpdateTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get NextUpdateTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get PublishTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwObjectType(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwError(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwReserved(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: pointer
  set ThisUpdateTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set NextUpdateTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set PublishTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPTNET_URL_CACHE_FLUSH_INFO (size: 16)
 */
export interface CRYPTNET_URL_CACHE_FLUSH_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwExemptSeconds: number;
  /** Windows.Win32.Foundation.FILETIME */
  ExpireTime: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPTNET_URL_CACHE_FLUSH_INFO = 16;

export function allocCRYPTNET_URL_CACHE_FLUSH_INFO(data?: Partial<CRYPTNET_URL_CACHE_FLUSH_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTNET_URL_CACHE_FLUSH_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwExemptSeconds !== undefined) view.setUint32(4, Number(data.dwExemptSeconds), true);
  // 0x08: pointer
  if (data?.ExpireTime !== undefined) view.setBigUint64(8, data.ExpireTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ExpireTime))), true);
  return buf;
}

export class CRYPTNET_URL_CACHE_FLUSH_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwExemptSeconds(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get ExpireTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwExemptSeconds(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set ExpireTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPTNET_URL_CACHE_RESPONSE_INFO (size: 40)
 */
export interface CRYPTNET_URL_CACHE_RESPONSE_INFO {
  /** u32 */
  cbSize: number;
  /** u16 */
  wResponseType: number;
  /** u16 */
  wResponseFlags: number;
  /** Windows.Win32.Foundation.FILETIME */
  LastModifiedTime: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwMaxAge: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszETag: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwProxyId: number;
}

export const sizeofCRYPTNET_URL_CACHE_RESPONSE_INFO = 40;

export function allocCRYPTNET_URL_CACHE_RESPONSE_INFO(data?: Partial<CRYPTNET_URL_CACHE_RESPONSE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTNET_URL_CACHE_RESPONSE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u16
  if (data?.wResponseType !== undefined) view.setUint16(4, Number(data.wResponseType), true);
  // 0x06: u16
  if (data?.wResponseFlags !== undefined) view.setUint16(6, Number(data.wResponseFlags), true);
  // 0x08: pointer
  if (data?.LastModifiedTime !== undefined) view.setBigUint64(8, data.LastModifiedTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.LastModifiedTime))), true);
  // 0x10: u32
  if (data?.dwMaxAge !== undefined) view.setUint32(16, Number(data.dwMaxAge), true);
  // 0x14: pad4
  // 0x18: buffer
  if (data?.pwszETag !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.pwszETag);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: u32
  if (data?.dwProxyId !== undefined) view.setUint32(32, Number(data.dwProxyId), true);
  // 0x24: pad4
  return buf;
}

export class CRYPTNET_URL_CACHE_RESPONSE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u16
  get wResponseType(): number {
    return this.view.getUint16(4, true);
  }

  // 0x06: u16
  get wResponseFlags(): number {
    return this.view.getUint16(6, true);
  }

  // 0x08: pointer
  get LastModifiedTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwMaxAge(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  get pwszETag(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwProxyId(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u16
  set wResponseType(value: number) {
    this.view.setUint16(4, value, true);
  }

  // 0x06: u16
  set wResponseFlags(value: number) {
    this.view.setUint16(6, value, true);
  }

  // 0x08: pointer
  set LastModifiedTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwMaxAge(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  set pwszETag(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: u32
  set dwProxyId(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_RETRIEVE_AUX_INFO (size: 88)
 */
export interface CRYPT_RETRIEVE_AUX_INFO {
  /** u32 */
  cbSize: number;
  /** ptr */
  pLastSyncTime: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwMaxUrlRetrievalByteCount: number;
  /** ptr */
  pPreFetchInfo: Deno.PointerValue | Uint8Array;
  /** ptr */
  pFlushInfo: Deno.PointerValue | Uint8Array;
  /** ptr */
  ppResponseInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszCacheFileNamePrefix: string | null | Uint8Array | Uint16Array;
  /** ptr */
  pftCacheResync: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fProxyCacheRetrieval: boolean;
  /** u32 */
  dwHttpStatusCode: number;
  /** ptr */
  ppwszErrorResponseHeaders: Deno.PointerValue | Uint8Array;
  /** ptr */
  ppErrorContentBlob: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_RETRIEVE_AUX_INFO = 88;

export function allocCRYPT_RETRIEVE_AUX_INFO(data?: Partial<CRYPT_RETRIEVE_AUX_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_RETRIEVE_AUX_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pLastSyncTime !== undefined) view.setBigUint64(8, data.pLastSyncTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pLastSyncTime))), true);
  // 0x10: u32
  if (data?.dwMaxUrlRetrievalByteCount !== undefined) view.setUint32(16, Number(data.dwMaxUrlRetrievalByteCount), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pPreFetchInfo !== undefined) view.setBigUint64(24, data.pPreFetchInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pPreFetchInfo))), true);
  // 0x20: pointer
  if (data?.pFlushInfo !== undefined) view.setBigUint64(32, data.pFlushInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pFlushInfo))), true);
  // 0x28: pointer
  if (data?.ppResponseInfo !== undefined) view.setBigUint64(40, data.ppResponseInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ppResponseInfo))), true);
  // 0x30: buffer
  if (data?.pwszCacheFileNamePrefix !== undefined) {
    (buf as any)._f48 = util.pwstrToFfi(data.pwszCacheFileNamePrefix);
    view.setBigUint64(48, (buf as any)._f48 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f48))), true);
  }
  // 0x38: pointer
  if (data?.pftCacheResync !== undefined) view.setBigUint64(56, data.pftCacheResync === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pftCacheResync))), true);
  // 0x40: i32
  if (data?.fProxyCacheRetrieval !== undefined) view.setInt32(64, Number(data.fProxyCacheRetrieval), true);
  // 0x44: u32
  if (data?.dwHttpStatusCode !== undefined) view.setUint32(68, Number(data.dwHttpStatusCode), true);
  // 0x48: pointer
  if (data?.ppwszErrorResponseHeaders !== undefined) view.setBigUint64(72, data.ppwszErrorResponseHeaders === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ppwszErrorResponseHeaders))), true);
  // 0x50: pointer
  if (data?.ppErrorContentBlob !== undefined) view.setBigUint64(80, data.ppErrorContentBlob === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ppErrorContentBlob))), true);
  return buf;
}

export class CRYPT_RETRIEVE_AUX_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pLastSyncTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwMaxUrlRetrievalByteCount(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pPreFetchInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pFlushInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get ppResponseInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: buffer
  get pwszCacheFileNamePrefix(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get pftCacheResync(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: i32
  get fProxyCacheRetrieval(): number {
    return this.view.getInt32(64, true);
  }

  // 0x44: u32
  get dwHttpStatusCode(): number {
    return this.view.getUint32(68, true);
  }

  // 0x48: pointer
  get ppwszErrorResponseHeaders(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: pointer
  get ppErrorContentBlob(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pLastSyncTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwMaxUrlRetrievalByteCount(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pPreFetchInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pFlushInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set ppResponseInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: buffer
  set pwszCacheFileNamePrefix(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f48 = value;
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f48))), true);
  }

  // 0x38: pointer
  set pftCacheResync(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: i32
  set fProxyCacheRetrieval(value: number) {
    this.view.setInt32(64, value, true);
  }

  // 0x44: u32
  set dwHttpStatusCode(value: number) {
    this.view.setUint32(68, value, true);
  }

  // 0x48: pointer
  set ppwszErrorResponseHeaders(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x50: pointer
  set ppErrorContentBlob(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_ASYNC_RETRIEVAL_COMPLETION (size: 16)
 */
export interface CRYPT_ASYNC_RETRIEVAL_COMPLETION {
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC */
  pfnCompletion: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvCompletion: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_ASYNC_RETRIEVAL_COMPLETION = 16;

export function allocCRYPT_ASYNC_RETRIEVAL_COMPLETION(data?: Partial<CRYPT_ASYNC_RETRIEVAL_COMPLETION>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_ASYNC_RETRIEVAL_COMPLETION);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pfnCompletion !== undefined) view.setBigUint64(0, data.pfnCompletion === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnCompletion))), true);
  // 0x08: pointer
  if (data?.pvCompletion !== undefined) view.setBigUint64(8, data.pvCompletion === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvCompletion))), true);
  return buf;
}

export class CRYPT_ASYNC_RETRIEVAL_COMPLETIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pfnCompletion(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pvCompletion(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pfnCompletion(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pvCompletion(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_URL_ARRAY (size: 16)
 */
export interface CRYPT_URL_ARRAY {
  /** u32 */
  cUrl: number;
  /** ptr */
  rgwszUrl: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_URL_ARRAY = 16;

export function allocCRYPT_URL_ARRAY(data?: Partial<CRYPT_URL_ARRAY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_URL_ARRAY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cUrl !== undefined) view.setUint32(0, Number(data.cUrl), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgwszUrl !== undefined) view.setBigUint64(8, data.rgwszUrl === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgwszUrl))), true);
  return buf;
}

export class CRYPT_URL_ARRAYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cUrl(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgwszUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cUrl(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgwszUrl(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_URL_INFO (size: 24)
 */
export interface CRYPT_URL_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwSyncDeltaTime: number;
  /** u32 */
  cGroup: number;
  /** ptr */
  rgcGroupEntry: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_URL_INFO = 24;

export function allocCRYPT_URL_INFO(data?: Partial<CRYPT_URL_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_URL_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwSyncDeltaTime !== undefined) view.setUint32(4, Number(data.dwSyncDeltaTime), true);
  // 0x08: u32
  if (data?.cGroup !== undefined) view.setUint32(8, Number(data.cGroup), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.rgcGroupEntry !== undefined) view.setBigUint64(16, data.rgcGroupEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgcGroupEntry))), true);
  return buf;
}

export class CRYPT_URL_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwSyncDeltaTime(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get cGroup(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get rgcGroupEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwSyncDeltaTime(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set cGroup(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set rgcGroupEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CRL_CONTEXT_PAIR (size: 16)
 */
export interface CERT_CRL_CONTEXT_PAIR {
  /** ptr */
  pCertContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  pCrlContext: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_CRL_CONTEXT_PAIR = 16;

export function allocCERT_CRL_CONTEXT_PAIR(data?: Partial<CERT_CRL_CONTEXT_PAIR>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CRL_CONTEXT_PAIR);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pCertContext !== undefined) view.setBigUint64(0, data.pCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertContext))), true);
  // 0x08: pointer
  if (data?.pCrlContext !== undefined) view.setBigUint64(8, data.pCrlContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCrlContext))), true);
  return buf;
}

export class CERT_CRL_CONTEXT_PAIRView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pCrlContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pCrlContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO (size: 48)
 */
export interface CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO {
  /** u32 */
  cbSize: number;
  /** i32 */
  iDeltaCrlIndicator: number;
  /** ptr */
  pftCacheResync: Deno.PointerValue | Uint8Array;
  /** ptr */
  pLastSyncTime: Deno.PointerValue | Uint8Array;
  /** ptr */
  pMaxAgeTime: Deno.PointerValue | Uint8Array;
  /** ptr */
  pChainPara: Deno.PointerValue | Uint8Array;
  /** ptr */
  pDeltaCrlIndicator: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = 48;

export function allocCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO(data?: Partial<CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: i32
  if (data?.iDeltaCrlIndicator !== undefined) view.setInt32(4, Number(data.iDeltaCrlIndicator), true);
  // 0x08: pointer
  if (data?.pftCacheResync !== undefined) view.setBigUint64(8, data.pftCacheResync === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pftCacheResync))), true);
  // 0x10: pointer
  if (data?.pLastSyncTime !== undefined) view.setBigUint64(16, data.pLastSyncTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pLastSyncTime))), true);
  // 0x18: pointer
  if (data?.pMaxAgeTime !== undefined) view.setBigUint64(24, data.pMaxAgeTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pMaxAgeTime))), true);
  // 0x20: pointer
  if (data?.pChainPara !== undefined) view.setBigUint64(32, data.pChainPara === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pChainPara))), true);
  // 0x28: pointer
  if (data?.pDeltaCrlIndicator !== undefined) view.setBigUint64(40, data.pDeltaCrlIndicator === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pDeltaCrlIndicator))), true);
  return buf;
}

export class CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get iDeltaCrlIndicator(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: pointer
  get pftCacheResync(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pLastSyncTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pMaxAgeTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pChainPara(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pDeltaCrlIndicator(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set iDeltaCrlIndicator(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: pointer
  set pftCacheResync(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pLastSyncTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pMaxAgeTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pChainPara(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pDeltaCrlIndicator(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN_ENGINE_CONFIG (size: 88)
 */
export interface CERT_CHAIN_ENGINE_CONFIG {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hRestrictedRoot: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hRestrictedTrust: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hRestrictedOther: Uint8Array | Deno.PointerValue;
  /** u32 */
  cAdditionalStore: number;
  /** ptr */
  rghAdditionalStore: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwUrlRetrievalTimeout: number;
  /** u32 */
  MaximumCachedCertificates: number;
  /** u32 */
  CycleDetectionModulus: number;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hExclusiveRoot: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hExclusiveTrustedPeople: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwExclusiveFlags: number;
}

export const sizeofCERT_CHAIN_ENGINE_CONFIG = 88;

export function allocCERT_CHAIN_ENGINE_CONFIG(data?: Partial<CERT_CHAIN_ENGINE_CONFIG>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN_ENGINE_CONFIG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hRestrictedRoot !== undefined) view.setBigUint64(8, data.hRestrictedRoot === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hRestrictedRoot))), true);
  // 0x10: pointer
  if (data?.hRestrictedTrust !== undefined) view.setBigUint64(16, data.hRestrictedTrust === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hRestrictedTrust))), true);
  // 0x18: pointer
  if (data?.hRestrictedOther !== undefined) view.setBigUint64(24, data.hRestrictedOther === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hRestrictedOther))), true);
  // 0x20: u32
  if (data?.cAdditionalStore !== undefined) view.setUint32(32, Number(data.cAdditionalStore), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rghAdditionalStore !== undefined) view.setBigUint64(40, data.rghAdditionalStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghAdditionalStore))), true);
  // 0x30: u32
  if (data?.dwFlags !== undefined) view.setUint32(48, Number(data.dwFlags), true);
  // 0x34: u32
  if (data?.dwUrlRetrievalTimeout !== undefined) view.setUint32(52, Number(data.dwUrlRetrievalTimeout), true);
  // 0x38: u32
  if (data?.MaximumCachedCertificates !== undefined) view.setUint32(56, Number(data.MaximumCachedCertificates), true);
  // 0x3c: u32
  if (data?.CycleDetectionModulus !== undefined) view.setUint32(60, Number(data.CycleDetectionModulus), true);
  // 0x40: pointer
  if (data?.hExclusiveRoot !== undefined) view.setBigUint64(64, data.hExclusiveRoot === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hExclusiveRoot))), true);
  // 0x48: pointer
  if (data?.hExclusiveTrustedPeople !== undefined) view.setBigUint64(72, data.hExclusiveTrustedPeople === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hExclusiveTrustedPeople))), true);
  // 0x50: u32
  if (data?.dwExclusiveFlags !== undefined) view.setUint32(80, Number(data.dwExclusiveFlags), true);
  // 0x54: pad4
  return buf;
}

export class CERT_CHAIN_ENGINE_CONFIGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hRestrictedRoot(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hRestrictedTrust(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get hRestrictedOther(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cAdditionalStore(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rghAdditionalStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get dwFlags(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: u32
  get dwUrlRetrievalTimeout(): number {
    return this.view.getUint32(52, true);
  }

  // 0x38: u32
  get MaximumCachedCertificates(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: u32
  get CycleDetectionModulus(): number {
    return this.view.getUint32(60, true);
  }

  // 0x40: pointer
  get hExclusiveRoot(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: pointer
  get hExclusiveTrustedPeople(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: u32
  get dwExclusiveFlags(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hRestrictedRoot(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hRestrictedTrust(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set hRestrictedOther(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cAdditionalStore(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rghAdditionalStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set dwFlags(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: u32
  set dwUrlRetrievalTimeout(value: number) {
    this.view.setUint32(52, value, true);
  }

  // 0x38: u32
  set MaximumCachedCertificates(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: u32
  set CycleDetectionModulus(value: number) {
    this.view.setUint32(60, value, true);
  }

  // 0x40: pointer
  set hExclusiveRoot(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: pointer
  set hExclusiveTrustedPeople(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x50: u32
  set dwExclusiveFlags(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_TRUST_STATUS (size: 8)
 */
export interface CERT_TRUST_STATUS {
  /** u32 */
  dwErrorStatus: number;
  /** u32 */
  dwInfoStatus: number;
}

export const sizeofCERT_TRUST_STATUS = 8;

export function allocCERT_TRUST_STATUS(data?: Partial<CERT_TRUST_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_TRUST_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwErrorStatus !== undefined) view.setUint32(0, Number(data.dwErrorStatus), true);
  // 0x04: u32
  if (data?.dwInfoStatus !== undefined) view.setUint32(4, Number(data.dwInfoStatus), true);
  return buf;
}

export class CERT_TRUST_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwErrorStatus(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwInfoStatus(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set dwErrorStatus(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwInfoStatus(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_REVOCATION_INFO (size: 40)
 */
export interface CERT_REVOCATION_INFO {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwRevocationResult: number;
  /** Windows.Win32.Foundation.PSTR */
  pszRevocationOid: string | null | Uint8Array;
  /** ptr */
  pvOidSpecificInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fHasFreshnessTime: boolean;
  /** u32 */
  dwFreshnessTime: number;
  /** ptr */
  pCrlInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_REVOCATION_INFO = 40;

export function allocCERT_REVOCATION_INFO(data?: Partial<CERT_REVOCATION_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REVOCATION_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwRevocationResult !== undefined) view.setUint32(4, Number(data.dwRevocationResult), true);
  // 0x08: buffer
  if (data?.pszRevocationOid !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszRevocationOid);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.pvOidSpecificInfo !== undefined) view.setBigUint64(16, data.pvOidSpecificInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvOidSpecificInfo))), true);
  // 0x18: i32
  if (data?.fHasFreshnessTime !== undefined) view.setInt32(24, Number(data.fHasFreshnessTime), true);
  // 0x1c: u32
  if (data?.dwFreshnessTime !== undefined) view.setUint32(28, Number(data.dwFreshnessTime), true);
  // 0x20: pointer
  if (data?.pCrlInfo !== undefined) view.setBigUint64(32, data.pCrlInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCrlInfo))), true);
  return buf;
}

export class CERT_REVOCATION_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwRevocationResult(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: buffer
  get pszRevocationOid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pvOidSpecificInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: i32
  get fHasFreshnessTime(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: u32
  get dwFreshnessTime(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: pointer
  get pCrlInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwRevocationResult(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: buffer
  set pszRevocationOid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set pvOidSpecificInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: i32
  set fHasFreshnessTime(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: u32
  set dwFreshnessTime(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: pointer
  set pCrlInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_TRUST_LIST_INFO (size: 24)
 */
export interface CERT_TRUST_LIST_INFO {
  /** u32 */
  cbSize: number;
  /** ptr */
  pCtlEntry: Deno.PointerValue | Uint8Array;
  /** ptr */
  pCtlContext: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_TRUST_LIST_INFO = 24;

export function allocCERT_TRUST_LIST_INFO(data?: Partial<CERT_TRUST_LIST_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_TRUST_LIST_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pCtlEntry !== undefined) view.setBigUint64(8, data.pCtlEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCtlEntry))), true);
  // 0x10: pointer
  if (data?.pCtlContext !== undefined) view.setBigUint64(16, data.pCtlContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCtlContext))), true);
  return buf;
}

export class CERT_TRUST_LIST_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pCtlEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pCtlContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pCtlEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pCtlContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN_ELEMENT (size: 56)
 */
export interface CERT_CHAIN_ELEMENT {
  /** u32 */
  cbSize: number;
  /** ptr */
  pCertContext: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CERT_TRUST_STATUS */
  TrustStatus: Uint8Array | Deno.PointerValue;
  /** ptr */
  pRevocationInfo: Deno.PointerValue | Uint8Array;
  /** ptr */
  pIssuanceUsage: Deno.PointerValue | Uint8Array;
  /** ptr */
  pApplicationUsage: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszExtendedErrorInfo: string | null | Uint8Array | Uint16Array;
}

export const sizeofCERT_CHAIN_ELEMENT = 56;

export function allocCERT_CHAIN_ELEMENT(data?: Partial<CERT_CHAIN_ELEMENT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN_ELEMENT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pCertContext !== undefined) view.setBigUint64(8, data.pCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertContext))), true);
  // 0x10: pointer
  if (data?.TrustStatus !== undefined) view.setBigUint64(16, data.TrustStatus === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.TrustStatus))), true);
  // 0x18: pointer
  if (data?.pRevocationInfo !== undefined) view.setBigUint64(24, data.pRevocationInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pRevocationInfo))), true);
  // 0x20: pointer
  if (data?.pIssuanceUsage !== undefined) view.setBigUint64(32, data.pIssuanceUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pIssuanceUsage))), true);
  // 0x28: pointer
  if (data?.pApplicationUsage !== undefined) view.setBigUint64(40, data.pApplicationUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pApplicationUsage))), true);
  // 0x30: buffer
  if (data?.pwszExtendedErrorInfo !== undefined) {
    (buf as any)._f48 = util.pwstrToFfi(data.pwszExtendedErrorInfo);
    view.setBigUint64(48, (buf as any)._f48 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f48))), true);
  }
  return buf;
}

export class CERT_CHAIN_ELEMENTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get TrustStatus(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pRevocationInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pIssuanceUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pApplicationUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: buffer
  get pwszExtendedErrorInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set TrustStatus(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pRevocationInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pIssuanceUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pApplicationUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: buffer
  set pwszExtendedErrorInfo(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f48 = value;
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f48))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SIMPLE_CHAIN (size: 48)
 */
export interface CERT_SIMPLE_CHAIN {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CERT_TRUST_STATUS */
  TrustStatus: Uint8Array | Deno.PointerValue;
  /** u32 */
  cElement: number;
  /** ptr */
  rgpElement: Deno.PointerValue | Uint8Array;
  /** ptr */
  pTrustListInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fHasRevocationFreshnessTime: boolean;
  /** u32 */
  dwRevocationFreshnessTime: number;
}

export const sizeofCERT_SIMPLE_CHAIN = 48;

export function allocCERT_SIMPLE_CHAIN(data?: Partial<CERT_SIMPLE_CHAIN>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SIMPLE_CHAIN);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.TrustStatus !== undefined) view.setBigUint64(8, data.TrustStatus === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.TrustStatus))), true);
  // 0x10: u32
  if (data?.cElement !== undefined) view.setUint32(16, Number(data.cElement), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgpElement !== undefined) view.setBigUint64(24, data.rgpElement === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpElement))), true);
  // 0x20: pointer
  if (data?.pTrustListInfo !== undefined) view.setBigUint64(32, data.pTrustListInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pTrustListInfo))), true);
  // 0x28: i32
  if (data?.fHasRevocationFreshnessTime !== undefined) view.setInt32(40, Number(data.fHasRevocationFreshnessTime), true);
  // 0x2c: u32
  if (data?.dwRevocationFreshnessTime !== undefined) view.setUint32(44, Number(data.dwRevocationFreshnessTime), true);
  return buf;
}

export class CERT_SIMPLE_CHAINView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get TrustStatus(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cElement(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgpElement(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pTrustListInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: i32
  get fHasRevocationFreshnessTime(): number {
    return this.view.getInt32(40, true);
  }

  // 0x2c: u32
  get dwRevocationFreshnessTime(): number {
    return this.view.getUint32(44, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set TrustStatus(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cElement(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgpElement(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pTrustListInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: i32
  set fHasRevocationFreshnessTime(value: number) {
    this.view.setInt32(40, value, true);
  }

  // 0x2c: u32
  set dwRevocationFreshnessTime(value: number) {
    this.view.setUint32(44, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN_CONTEXT (size: 72)
 */
export interface CERT_CHAIN_CONTEXT {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CERT_TRUST_STATUS */
  TrustStatus: Uint8Array | Deno.PointerValue;
  /** u32 */
  cChain: number;
  /** ptr */
  rgpChain: Deno.PointerValue | Uint8Array;
  /** u32 */
  cLowerQualityChainContext: number;
  /** ptr */
  rgpLowerQualityChainContext: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fHasRevocationFreshnessTime: boolean;
  /** u32 */
  dwRevocationFreshnessTime: number;
  /** u32 */
  dwCreateFlags: number;
  /** System.Guid */
  ChainId: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_CHAIN_CONTEXT = 72;

export function allocCERT_CHAIN_CONTEXT(data?: Partial<CERT_CHAIN_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.TrustStatus !== undefined) view.setBigUint64(8, data.TrustStatus === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.TrustStatus))), true);
  // 0x10: u32
  if (data?.cChain !== undefined) view.setUint32(16, Number(data.cChain), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgpChain !== undefined) view.setBigUint64(24, data.rgpChain === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpChain))), true);
  // 0x20: u32
  if (data?.cLowerQualityChainContext !== undefined) view.setUint32(32, Number(data.cLowerQualityChainContext), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgpLowerQualityChainContext !== undefined) view.setBigUint64(40, data.rgpLowerQualityChainContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpLowerQualityChainContext))), true);
  // 0x30: i32
  if (data?.fHasRevocationFreshnessTime !== undefined) view.setInt32(48, Number(data.fHasRevocationFreshnessTime), true);
  // 0x34: u32
  if (data?.dwRevocationFreshnessTime !== undefined) view.setUint32(52, Number(data.dwRevocationFreshnessTime), true);
  // 0x38: u32
  if (data?.dwCreateFlags !== undefined) view.setUint32(56, Number(data.dwCreateFlags), true);
  // 0x3c: pad4
  // 0x40: pointer
  if (data?.ChainId !== undefined) view.setBigUint64(64, data.ChainId === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ChainId))), true);
  return buf;
}

export class CERT_CHAIN_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get TrustStatus(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cChain(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgpChain(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cLowerQualityChainContext(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgpLowerQualityChainContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: i32
  get fHasRevocationFreshnessTime(): number {
    return this.view.getInt32(48, true);
  }

  // 0x34: u32
  get dwRevocationFreshnessTime(): number {
    return this.view.getUint32(52, true);
  }

  // 0x38: u32
  get dwCreateFlags(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  get ChainId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set TrustStatus(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cChain(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgpChain(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cLowerQualityChainContext(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgpLowerQualityChainContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: i32
  set fHasRevocationFreshnessTime(value: number) {
    this.view.setInt32(48, value, true);
  }

  // 0x34: u32
  set dwRevocationFreshnessTime(value: number) {
    this.view.setUint32(52, value, true);
  }

  // 0x38: u32
  set dwCreateFlags(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  set ChainId(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_USAGE_MATCH (size: 16)
 */
export interface CERT_USAGE_MATCH {
  /** u32 */
  dwType: number;
  /** Windows.Win32.Security.Cryptography.CTL_USAGE */
  Usage: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_USAGE_MATCH = 16;

export function allocCERT_USAGE_MATCH(data?: Partial<CERT_USAGE_MATCH>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_USAGE_MATCH);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwType !== undefined) view.setUint32(0, Number(data.dwType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Usage !== undefined) view.setBigUint64(8, data.Usage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Usage))), true);
  return buf;
}

export class CERT_USAGE_MATCHView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Usage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Usage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CTL_USAGE_MATCH (size: 16)
 */
export interface CTL_USAGE_MATCH {
  /** u32 */
  dwType: number;
  /** Windows.Win32.Security.Cryptography.CTL_USAGE */
  Usage: Uint8Array | Deno.PointerValue;
}

export const sizeofCTL_USAGE_MATCH = 16;

export function allocCTL_USAGE_MATCH(data?: Partial<CTL_USAGE_MATCH>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_USAGE_MATCH);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwType !== undefined) view.setUint32(0, Number(data.dwType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Usage !== undefined) view.setBigUint64(8, data.Usage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Usage))), true);
  return buf;
}

export class CTL_USAGE_MATCHView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Usage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Usage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN_PARA (size: 16)
 */
export interface CERT_CHAIN_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CERT_USAGE_MATCH */
  RequestedUsage: Uint8Array | Deno.PointerValue;
}

export const sizeofCERT_CHAIN_PARA = 16;

export function allocCERT_CHAIN_PARA(data?: Partial<CERT_CHAIN_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.RequestedUsage !== undefined) view.setBigUint64(8, data.RequestedUsage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.RequestedUsage))), true);
  return buf;
}

export class CERT_CHAIN_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get RequestedUsage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set RequestedUsage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_REVOCATION_CHAIN_PARA (size: 56)
 */
export interface CERT_REVOCATION_CHAIN_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.HCERTCHAINENGINE */
  hChainEngine: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hAdditionalStore: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwChainFlags: number;
  /** u32 */
  dwUrlRetrievalTimeout: number;
  /** ptr */
  pftCurrentTime: Deno.PointerValue | Uint8Array;
  /** ptr */
  pftCacheResync: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbMaxUrlRetrievalByteCount: number;
}

export const sizeofCERT_REVOCATION_CHAIN_PARA = 56;

export function allocCERT_REVOCATION_CHAIN_PARA(data?: Partial<CERT_REVOCATION_CHAIN_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_REVOCATION_CHAIN_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hChainEngine !== undefined) view.setBigUint64(8, data.hChainEngine === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hChainEngine))), true);
  // 0x10: pointer
  if (data?.hAdditionalStore !== undefined) view.setBigUint64(16, data.hAdditionalStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hAdditionalStore))), true);
  // 0x18: u32
  if (data?.dwChainFlags !== undefined) view.setUint32(24, Number(data.dwChainFlags), true);
  // 0x1c: u32
  if (data?.dwUrlRetrievalTimeout !== undefined) view.setUint32(28, Number(data.dwUrlRetrievalTimeout), true);
  // 0x20: pointer
  if (data?.pftCurrentTime !== undefined) view.setBigUint64(32, data.pftCurrentTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pftCurrentTime))), true);
  // 0x28: pointer
  if (data?.pftCacheResync !== undefined) view.setBigUint64(40, data.pftCacheResync === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pftCacheResync))), true);
  // 0x30: u32
  if (data?.cbMaxUrlRetrievalByteCount !== undefined) view.setUint32(48, Number(data.cbMaxUrlRetrievalByteCount), true);
  // 0x34: pad4
  return buf;
}

export class CERT_REVOCATION_CHAIN_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hChainEngine(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hAdditionalStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwChainFlags(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: u32
  get dwUrlRetrievalTimeout(): number {
    return this.view.getUint32(28, true);
  }

  // 0x20: pointer
  get pftCurrentTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pftCacheResync(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cbMaxUrlRetrievalByteCount(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hChainEngine(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hAdditionalStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwChainFlags(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: u32
  set dwUrlRetrievalTimeout(value: number) {
    this.view.setUint32(28, value, true);
  }

  // 0x20: pointer
  set pftCurrentTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pftCacheResync(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cbMaxUrlRetrievalByteCount(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRL_REVOCATION_INFO (size: 24)
 */
export interface CRL_REVOCATION_INFO {
  /** ptr */
  pCrlEntry: Deno.PointerValue | Uint8Array;
  /** ptr */
  pCrlContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  pCrlIssuerChain: Deno.PointerValue | Uint8Array;
}

export const sizeofCRL_REVOCATION_INFO = 24;

export function allocCRL_REVOCATION_INFO(data?: Partial<CRL_REVOCATION_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRL_REVOCATION_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pCrlEntry !== undefined) view.setBigUint64(0, data.pCrlEntry === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCrlEntry))), true);
  // 0x08: pointer
  if (data?.pCrlContext !== undefined) view.setBigUint64(8, data.pCrlContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCrlContext))), true);
  // 0x10: pointer
  if (data?.pCrlIssuerChain !== undefined) view.setBigUint64(16, data.pCrlIssuerChain === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCrlIssuerChain))), true);
  return buf;
}

export class CRL_REVOCATION_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pCrlEntry(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pCrlContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pCrlIssuerChain(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pCrlEntry(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pCrlContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pCrlIssuerChain(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN_FIND_BY_ISSUER_PARA (size: 56)
 */
export interface CERT_CHAIN_FIND_BY_ISSUER_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PSTR */
  pszUsageIdentifier: string | null | Uint8Array;
  /** u32 */
  dwKeySpec: number;
  /** u32 */
  dwAcquirePrivateKeyFlags: number;
  /** u32 */
  cIssuer: number;
  /** ptr */
  rgIssuer: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK */
  pfnFindCallback: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvFindArg: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_CHAIN_FIND_BY_ISSUER_PARA = 56;

export function allocCERT_CHAIN_FIND_BY_ISSUER_PARA(data?: Partial<CERT_CHAIN_FIND_BY_ISSUER_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN_FIND_BY_ISSUER_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszUsageIdentifier !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszUsageIdentifier);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.dwKeySpec !== undefined) view.setUint32(16, Number(data.dwKeySpec), true);
  // 0x14: u32
  if (data?.dwAcquirePrivateKeyFlags !== undefined) view.setUint32(20, Number(data.dwAcquirePrivateKeyFlags), true);
  // 0x18: u32
  if (data?.cIssuer !== undefined) view.setUint32(24, Number(data.cIssuer), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgIssuer !== undefined) view.setBigUint64(32, data.rgIssuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgIssuer))), true);
  // 0x28: pointer
  if (data?.pfnFindCallback !== undefined) view.setBigUint64(40, data.pfnFindCallback === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFindCallback))), true);
  // 0x30: pointer
  if (data?.pvFindArg !== undefined) view.setBigUint64(48, data.pvFindArg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvFindArg))), true);
  return buf;
}

export class CERT_CHAIN_FIND_BY_ISSUER_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszUsageIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwKeySpec(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwAcquirePrivateKeyFlags(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: u32
  get cIssuer(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgIssuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pfnFindCallback(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get pvFindArg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszUsageIdentifier(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set dwKeySpec(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwAcquirePrivateKeyFlags(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: u32
  set cIssuer(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgIssuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pfnFindCallback(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set pvFindArg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN_POLICY_PARA (size: 16)
 */
export interface CERT_CHAIN_POLICY_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CERT_CHAIN_POLICY_FLAGS */
  dwFlags: CERT_CHAIN_POLICY_FLAGS;
  /** ptr */
  pvExtraPolicyPara: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_CHAIN_POLICY_PARA = 16;

export function allocCERT_CHAIN_POLICY_PARA(data?: Partial<CERT_CHAIN_POLICY_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN_POLICY_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwFlags !== undefined) view.setUint32(4, Number(data.dwFlags), true);
  // 0x08: pointer
  if (data?.pvExtraPolicyPara !== undefined) view.setBigUint64(8, data.pvExtraPolicyPara === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvExtraPolicyPara))), true);
  return buf;
}

export class CERT_CHAIN_POLICY_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pvExtraPolicyPara(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pvExtraPolicyPara(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_CHAIN_POLICY_STATUS (size: 24)
 */
export interface CERT_CHAIN_POLICY_STATUS {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwError: number;
  /** i32 */
  lChainIndex: number;
  /** i32 */
  lElementIndex: number;
  /** ptr */
  pvExtraPolicyStatus: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_CHAIN_POLICY_STATUS = 24;

export function allocCERT_CHAIN_POLICY_STATUS(data?: Partial<CERT_CHAIN_POLICY_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_CHAIN_POLICY_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwError !== undefined) view.setUint32(4, Number(data.dwError), true);
  // 0x08: i32
  if (data?.lChainIndex !== undefined) view.setInt32(8, Number(data.lChainIndex), true);
  // 0x0c: i32
  if (data?.lElementIndex !== undefined) view.setInt32(12, Number(data.lElementIndex), true);
  // 0x10: pointer
  if (data?.pvExtraPolicyStatus !== undefined) view.setBigUint64(16, data.pvExtraPolicyStatus === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvExtraPolicyStatus))), true);
  return buf;
}

export class CERT_CHAIN_POLICY_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwError(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get lChainIndex(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: i32
  get lElementIndex(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: pointer
  get pvExtraPolicyStatus(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwError(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set lChainIndex(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: i32
  set lElementIndex(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: pointer
  set pvExtraPolicyStatus(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA (size: 16)
 */
export interface AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwRegPolicySettings: number;
  /** ptr */
  pSignerInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = 16;

export function allocAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA(data?: Partial<AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwRegPolicySettings !== undefined) view.setUint32(4, Number(data.dwRegPolicySettings), true);
  // 0x08: pointer
  if (data?.pSignerInfo !== undefined) view.setBigUint64(8, data.pSignerInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pSignerInfo))), true);
  return buf;
}

export class AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwRegPolicySettings(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pSignerInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwRegPolicySettings(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pSignerInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS (size: 8)
 */
export interface AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.BOOL */
  fCommercial: boolean;
}

export const sizeofAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = 8;

export function allocAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS(data?: Partial<AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: i32
  if (data?.fCommercial !== undefined) view.setInt32(4, Number(data.fCommercial), true);
  return buf;
}

export class AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get fCommercial(): number {
    return this.view.getInt32(4, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set fCommercial(value: number) {
    this.view.setInt32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA (size: 16)
 */
export interface AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwRegPolicySettings: number;
  /** Windows.Win32.Foundation.BOOL */
  fCommercial: boolean;
}

export const sizeofAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = 16;

export function allocAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA(data?: Partial<AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwRegPolicySettings !== undefined) view.setUint32(4, Number(data.dwRegPolicySettings), true);
  // 0x08: i32
  if (data?.fCommercial !== undefined) view.setInt32(8, Number(data.fCommercial), true);
  // 0x0c: pad4
  return buf;
}

export class AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwRegPolicySettings(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get fCommercial(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwRegPolicySettings(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set fCommercial(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.HTTPSPolicyCallbackData (size: 24)
 */
export interface HTTPSPolicyCallbackData {
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE */
  dwAuthType: HTTPSPOLICY_CALLBACK_DATA_AUTH_TYPE;
  /** u32 */
  fdwChecks: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszServerName: string | null | Uint8Array | Uint16Array;
}

export const sizeofHTTPSPolicyCallbackData = 24;

export function allocHTTPSPolicyCallbackData(data?: Partial<HTTPSPolicyCallbackData>): Uint8Array {
  const buf = new Uint8Array(sizeofHTTPSPolicyCallbackData);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(0, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x08: u32
  if (data?.dwAuthType !== undefined) view.setUint32(8, Number(data.dwAuthType), true);
  // 0x0c: u32
  if (data?.fdwChecks !== undefined) view.setUint32(12, Number(data.fdwChecks), true);
  // 0x10: buffer
  if (data?.pwszServerName !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszServerName);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class HTTPSPolicyCallbackDataView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwAuthType(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get fdwChecks(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: buffer
  get pwszServerName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set dwAuthType(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set fdwChecks(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: buffer
  set pwszServerName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.EV_EXTRA_CERT_CHAIN_POLICY_PARA (size: 8)
 */
export interface EV_EXTRA_CERT_CHAIN_POLICY_PARA {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CERT_ROOT_PROGRAM_FLAGS */
  dwRootProgramQualifierFlags: CERT_ROOT_PROGRAM_FLAGS;
}

export const sizeofEV_EXTRA_CERT_CHAIN_POLICY_PARA = 8;

export function allocEV_EXTRA_CERT_CHAIN_POLICY_PARA(data?: Partial<EV_EXTRA_CERT_CHAIN_POLICY_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofEV_EXTRA_CERT_CHAIN_POLICY_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwRootProgramQualifierFlags !== undefined) view.setUint32(4, Number(data.dwRootProgramQualifierFlags), true);
  return buf;
}

export class EV_EXTRA_CERT_CHAIN_POLICY_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwRootProgramQualifierFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwRootProgramQualifierFlags(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.EV_EXTRA_CERT_CHAIN_POLICY_STATUS (size: 16)
 */
export interface EV_EXTRA_CERT_CHAIN_POLICY_STATUS {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwQualifiers: number;
  /** u32 */
  dwIssuanceUsageIndex: number;
}

export const sizeofEV_EXTRA_CERT_CHAIN_POLICY_STATUS = 16;

export function allocEV_EXTRA_CERT_CHAIN_POLICY_STATUS(data?: Partial<EV_EXTRA_CERT_CHAIN_POLICY_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofEV_EXTRA_CERT_CHAIN_POLICY_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwQualifiers !== undefined) view.setUint32(4, Number(data.dwQualifiers), true);
  // 0x08: u32
  if (data?.dwIssuanceUsageIndex !== undefined) view.setUint32(8, Number(data.dwIssuanceUsageIndex), true);
  // 0x0c: pad4
  return buf;
}

export class EV_EXTRA_CERT_CHAIN_POLICY_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwQualifiers(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwIssuanceUsageIndex(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwQualifiers(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwIssuanceUsageIndex(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS (size: 24)
 */
export interface SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwErrorLevel: number;
  /** u32 */
  dwErrorCategory: number;
  /** u32 */
  dwReserved: number;
  /** array */
  wszErrorText: Deno.PointerValue;
}

export const sizeofSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = 24;

export function allocSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS(data?: Partial<SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwErrorLevel !== undefined) view.setUint32(4, Number(data.dwErrorLevel), true);
  // 0x08: u32
  if (data?.dwErrorCategory !== undefined) view.setUint32(8, Number(data.dwErrorCategory), true);
  // 0x0c: u32
  if (data?.dwReserved !== undefined) view.setUint32(12, Number(data.dwReserved), true);
  // 0x10: pointer
  if (data?.wszErrorText !== undefined) view.setBigUint64(16, data.wszErrorText === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.wszErrorText))), true);
  return buf;
}

export class SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwErrorLevel(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwErrorCategory(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwReserved(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: pointer
  get wszErrorText(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwErrorLevel(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwErrorCategory(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwReserved(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: pointer
  set wszErrorText(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA (size: 24)
 */
export interface SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwReserved: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszServerName: string | null | Uint8Array | Uint16Array;
  /** array */
  rgpszHpkpValue: Deno.PointerValue;
}

export const sizeofSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = 24;

export function allocSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA(data?: Partial<SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwReserved !== undefined) view.setUint32(4, Number(data.dwReserved), true);
  // 0x08: buffer
  if (data?.pwszServerName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszServerName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.rgpszHpkpValue !== undefined) view.setBigUint64(16, data.rgpszHpkpValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpszHpkpValue))), true);
  return buf;
}

export class SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwReserved(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: buffer
  get pwszServerName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get rgpszHpkpValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwReserved(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: buffer
  set pwszServerName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set rgpszHpkpValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA (size: 16)
 */
export interface SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwReserved: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszServerName: string | null | Uint8Array | Uint16Array;
}

export const sizeofSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = 16;

export function allocSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA(data?: Partial<SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwReserved !== undefined) view.setUint32(4, Number(data.dwReserved), true);
  // 0x08: buffer
  if (data?.pwszServerName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszServerName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwReserved(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: buffer
  get pwszServerName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwReserved(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: buffer
  set pwszServerName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS (size: 16)
 */
export interface SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS {
  /** u32 */
  cbSize: number;
  /** i32 */
  lError: number;
  /** array */
  wszErrorText: Deno.PointerValue;
}

export const sizeofSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = 16;

export function allocSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS(data?: Partial<SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: i32
  if (data?.lError !== undefined) view.setInt32(4, Number(data.lError), true);
  // 0x08: pointer
  if (data?.wszErrorText !== undefined) view.setBigUint64(8, data.wszErrorText === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.wszErrorText))), true);
  return buf;
}

export class SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: i32
  get lError(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: pointer
  get wszErrorText(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: i32
  set lError(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: pointer
  set wszErrorText(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_PKCS12_PBE_PARAMS (size: 8)
 */
export interface CRYPT_PKCS12_PBE_PARAMS {
  /** i32 */
  iIterations: number;
  /** u32 */
  cbSalt: number;
}

export const sizeofCRYPT_PKCS12_PBE_PARAMS = 8;

export function allocCRYPT_PKCS12_PBE_PARAMS(data?: Partial<CRYPT_PKCS12_PBE_PARAMS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_PKCS12_PBE_PARAMS);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.iIterations !== undefined) view.setInt32(0, Number(data.iIterations), true);
  // 0x04: u32
  if (data?.cbSalt !== undefined) view.setUint32(4, Number(data.cbSalt), true);
  return buf;
}

export class CRYPT_PKCS12_PBE_PARAMSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get iIterations(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: u32
  get cbSalt(): number {
    return this.view.getUint32(4, true);
  }

  // 0x00: i32
  set iIterations(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: u32
  set cbSalt(value: number) {
    this.view.setUint32(4, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.PKCS12_PBES2_EXPORT_PARAMS (size: 24)
 */
export interface PKCS12_PBES2_EXPORT_PARAMS {
  /** u32 */
  dwSize: number;
  /** ptr */
  hNcryptDescriptor: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszPbes2Alg: string | null | Uint8Array | Uint16Array;
}

export const sizeofPKCS12_PBES2_EXPORT_PARAMS = 24;

export function allocPKCS12_PBES2_EXPORT_PARAMS(data?: Partial<PKCS12_PBES2_EXPORT_PARAMS>): Uint8Array {
  const buf = new Uint8Array(sizeofPKCS12_PBES2_EXPORT_PARAMS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hNcryptDescriptor !== undefined) view.setBigUint64(8, data.hNcryptDescriptor === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hNcryptDescriptor))), true);
  // 0x10: buffer
  if (data?.pwszPbes2Alg !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszPbes2Alg);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class PKCS12_PBES2_EXPORT_PARAMSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hNcryptDescriptor(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszPbes2Alg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hNcryptDescriptor(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set pwszPbes2Alg(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SERVER_OCSP_RESPONSE_CONTEXT (size: 24)
 */
export interface CERT_SERVER_OCSP_RESPONSE_CONTEXT {
  /** u32 */
  cbSize: number;
  /** ptr */
  pbEncodedOcspResponse: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbEncodedOcspResponse: number;
}

export const sizeofCERT_SERVER_OCSP_RESPONSE_CONTEXT = 24;

export function allocCERT_SERVER_OCSP_RESPONSE_CONTEXT(data?: Partial<CERT_SERVER_OCSP_RESPONSE_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SERVER_OCSP_RESPONSE_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbEncodedOcspResponse !== undefined) view.setBigUint64(8, data.pbEncodedOcspResponse === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbEncodedOcspResponse))), true);
  // 0x10: u32
  if (data?.cbEncodedOcspResponse !== undefined) view.setUint32(16, Number(data.cbEncodedOcspResponse), true);
  // 0x14: pad4
  return buf;
}

export class CERT_SERVER_OCSP_RESPONSE_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbEncodedOcspResponse(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbEncodedOcspResponse(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbEncodedOcspResponse(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbEncodedOcspResponse(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SERVER_OCSP_RESPONSE_OPEN_PARA (size: 40)
 */
export interface CERT_SERVER_OCSP_RESPONSE_OPEN_PARA {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwFlags: number;
  /** ptr */
  pcbUsedSize: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszOcspDirectory: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK */
  pfnUpdateCallback: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvUpdateCallbackArg: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_SERVER_OCSP_RESPONSE_OPEN_PARA = 40;

export function allocCERT_SERVER_OCSP_RESPONSE_OPEN_PARA(data?: Partial<CERT_SERVER_OCSP_RESPONSE_OPEN_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SERVER_OCSP_RESPONSE_OPEN_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwFlags !== undefined) view.setUint32(4, Number(data.dwFlags), true);
  // 0x08: pointer
  if (data?.pcbUsedSize !== undefined) view.setBigUint64(8, data.pcbUsedSize === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pcbUsedSize))), true);
  // 0x10: buffer
  if (data?.pwszOcspDirectory !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszOcspDirectory);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: pointer
  if (data?.pfnUpdateCallback !== undefined) view.setBigUint64(24, data.pfnUpdateCallback === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnUpdateCallback))), true);
  // 0x20: pointer
  if (data?.pvUpdateCallbackArg !== undefined) view.setBigUint64(32, data.pvUpdateCallbackArg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvUpdateCallbackArg))), true);
  return buf;
}

export class CERT_SERVER_OCSP_RESPONSE_OPEN_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pcbUsedSize(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszOcspDirectory(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pfnUpdateCallback(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pvUpdateCallbackArg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pcbUsedSize(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set pwszOcspDirectory(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: pointer
  set pfnUpdateCallback(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pvUpdateCallbackArg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SELECT_CHAIN_PARA (size: 40)
 */
export interface CERT_SELECT_CHAIN_PARA {
  /** Windows.Win32.Security.Cryptography.HCERTCHAINENGINE */
  hChainEngine: Uint8Array | Deno.PointerValue;
  /** ptr */
  pTime: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hAdditionalStore: Uint8Array | Deno.PointerValue;
  /** ptr */
  pChainPara: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwFlags: number;
}

export const sizeofCERT_SELECT_CHAIN_PARA = 40;

export function allocCERT_SELECT_CHAIN_PARA(data?: Partial<CERT_SELECT_CHAIN_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SELECT_CHAIN_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.hChainEngine !== undefined) view.setBigUint64(0, data.hChainEngine === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hChainEngine))), true);
  // 0x08: pointer
  if (data?.pTime !== undefined) view.setBigUint64(8, data.pTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pTime))), true);
  // 0x10: pointer
  if (data?.hAdditionalStore !== undefined) view.setBigUint64(16, data.hAdditionalStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hAdditionalStore))), true);
  // 0x18: pointer
  if (data?.pChainPara !== undefined) view.setBigUint64(24, data.pChainPara === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pChainPara))), true);
  // 0x20: u32
  if (data?.dwFlags !== undefined) view.setUint32(32, Number(data.dwFlags), true);
  // 0x24: pad4
  return buf;
}

export class CERT_SELECT_CHAIN_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get hChainEngine(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hAdditionalStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pChainPara(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwFlags(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x00: pointer
  set hChainEngine(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hAdditionalStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pChainPara(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set dwFlags(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CERT_SELECT_CRITERIA (size: 16)
 */
export interface CERT_SELECT_CRITERIA {
  /** Windows.Win32.Security.Cryptography.CERT_SELECT_CRITERIA_TYPE */
  dwType: CERT_SELECT_CRITERIA_TYPE;
  /** u32 */
  cPara: number;
  /** ptr */
  ppPara: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_SELECT_CRITERIA = 16;

export function allocCERT_SELECT_CRITERIA(data?: Partial<CERT_SELECT_CRITERIA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SELECT_CRITERIA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwType !== undefined) view.setUint32(0, Number(data.dwType), true);
  // 0x04: u32
  if (data?.cPara !== undefined) view.setUint32(4, Number(data.cPara), true);
  // 0x08: pointer
  if (data?.ppPara !== undefined) view.setBigUint64(8, data.ppPara === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ppPara))), true);
  return buf;
}

export class CERT_SELECT_CRITERIAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cPara(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get ppPara(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cPara(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set ppPara(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_REQUEST (size: 56)
 */
export interface CRYPT_TIMESTAMP_REQUEST {
  /** Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_VERSION */
  dwVersion: CRYPT_TIMESTAMP_VERSION;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  HashedMessage: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PSTR */
  pszTSAPolicyId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Nonce: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.BOOL */
  fCertReq: boolean;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_TIMESTAMP_REQUEST = 56;

export function allocCRYPT_TIMESTAMP_REQUEST(data?: Partial<CRYPT_TIMESTAMP_REQUEST>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_TIMESTAMP_REQUEST);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(8, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x10: pointer
  if (data?.HashedMessage !== undefined) view.setBigUint64(16, data.HashedMessage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashedMessage))), true);
  // 0x18: buffer
  if (data?.pszTSAPolicyId !== undefined) {
    (buf as any)._f24 = util.pstrToFfi(data.pszTSAPolicyId);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: pointer
  if (data?.Nonce !== undefined) view.setBigUint64(32, data.Nonce === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Nonce))), true);
  // 0x28: i32
  if (data?.fCertReq !== undefined) view.setInt32(40, Number(data.fCertReq), true);
  // 0x2c: u32
  if (data?.cExtension !== undefined) view.setUint32(44, Number(data.cExtension), true);
  // 0x30: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(48, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CRYPT_TIMESTAMP_REQUESTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get HashedMessage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get pszTSAPolicyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get Nonce(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: i32
  get fCertReq(): number {
    return this.view.getInt32(40, true);
  }

  // 0x2c: u32
  get cExtension(): number {
    return this.view.getUint32(44, true);
  }

  // 0x30: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set HashedMessage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: buffer
  set pszTSAPolicyId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: pointer
  set Nonce(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: i32
  set fCertReq(value: number) {
    this.view.setInt32(40, value, true);
  }

  // 0x2c: u32
  set cExtension(value: number) {
    this.view.setUint32(44, value, true);
  }

  // 0x30: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_RESPONSE (size: 32)
 */
export interface CRYPT_TIMESTAMP_RESPONSE {
  /** Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_RESPONSE_STATUS */
  dwStatus: CRYPT_TIMESTAMP_RESPONSE_STATUS;
  /** u32 */
  cFreeText: number;
  /** ptr */
  rgFreeText: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_BIT_BLOB */
  FailureInfo: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  ContentInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_TIMESTAMP_RESPONSE = 32;

export function allocCRYPT_TIMESTAMP_RESPONSE(data?: Partial<CRYPT_TIMESTAMP_RESPONSE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_TIMESTAMP_RESPONSE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwStatus !== undefined) view.setUint32(0, Number(data.dwStatus), true);
  // 0x04: u32
  if (data?.cFreeText !== undefined) view.setUint32(4, Number(data.cFreeText), true);
  // 0x08: pointer
  if (data?.rgFreeText !== undefined) view.setBigUint64(8, data.rgFreeText === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgFreeText))), true);
  // 0x10: pointer
  if (data?.FailureInfo !== undefined) view.setBigUint64(16, data.FailureInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.FailureInfo))), true);
  // 0x18: pointer
  if (data?.ContentInfo !== undefined) view.setBigUint64(24, data.ContentInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ContentInfo))), true);
  return buf;
}

export class CRYPT_TIMESTAMP_RESPONSEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwStatus(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cFreeText(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgFreeText(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get FailureInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get ContentInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwStatus(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cFreeText(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgFreeText(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set FailureInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set ContentInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_ACCURACY (size: 16)
 */
export interface CRYPT_TIMESTAMP_ACCURACY {
  /** u32 */
  dwSeconds: number;
  /** u32 */
  dwMillis: number;
  /** u32 */
  dwMicros: number;
}

export const sizeofCRYPT_TIMESTAMP_ACCURACY = 16;

export function allocCRYPT_TIMESTAMP_ACCURACY(data?: Partial<CRYPT_TIMESTAMP_ACCURACY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_TIMESTAMP_ACCURACY);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSeconds !== undefined) view.setUint32(0, Number(data.dwSeconds), true);
  // 0x04: u32
  if (data?.dwMillis !== undefined) view.setUint32(4, Number(data.dwMillis), true);
  // 0x08: u32
  if (data?.dwMicros !== undefined) view.setUint32(8, Number(data.dwMicros), true);
  // 0x0c: pad4
  return buf;
}

export class CRYPT_TIMESTAMP_ACCURACYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSeconds(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwMillis(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwMicros(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set dwSeconds(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwMillis(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwMicros(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_INFO (size: 96)
 */
export interface CRYPT_TIMESTAMP_INFO {
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Foundation.PSTR */
  pszTSAPolicyId: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  HashAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  HashedMessage: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SerialNumber: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  ftTime: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvAccuracy: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fOrdering: boolean;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Nonce: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Tsa: Uint8Array | Deno.PointerValue;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_TIMESTAMP_INFO = 96;

export function allocCRYPT_TIMESTAMP_INFO(data?: Partial<CRYPT_TIMESTAMP_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_TIMESTAMP_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwVersion !== undefined) view.setUint32(0, Number(data.dwVersion), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pszTSAPolicyId !== undefined) {
    (buf as any)._f8 = util.pstrToFfi(data.pszTSAPolicyId);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.HashAlgorithm !== undefined) view.setBigUint64(16, data.HashAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashAlgorithm))), true);
  // 0x18: pointer
  if (data?.HashedMessage !== undefined) view.setBigUint64(24, data.HashedMessage === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.HashedMessage))), true);
  // 0x20: pointer
  if (data?.SerialNumber !== undefined) view.setBigUint64(32, data.SerialNumber === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SerialNumber))), true);
  // 0x28: pointer
  if (data?.ftTime !== undefined) view.setBigUint64(40, data.ftTime === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ftTime))), true);
  // 0x30: pointer
  if (data?.pvAccuracy !== undefined) view.setBigUint64(48, data.pvAccuracy === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvAccuracy))), true);
  // 0x38: i32
  if (data?.fOrdering !== undefined) view.setInt32(56, Number(data.fOrdering), true);
  // 0x3c: pad4
  // 0x40: pointer
  if (data?.Nonce !== undefined) view.setBigUint64(64, data.Nonce === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Nonce))), true);
  // 0x48: pointer
  if (data?.Tsa !== undefined) view.setBigUint64(72, data.Tsa === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Tsa))), true);
  // 0x50: u32
  if (data?.cExtension !== undefined) view.setUint32(80, Number(data.cExtension), true);
  // 0x54: pad4
  // 0x58: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(88, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CRYPT_TIMESTAMP_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwVersion(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pszTSAPolicyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get HashAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get HashedMessage(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get SerialNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get ftTime(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get pvAccuracy(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: i32
  get fOrdering(): number {
    return this.view.getInt32(56, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  get Nonce(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: pointer
  get Tsa(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: u32
  get cExtension(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwVersion(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pszTSAPolicyId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set HashAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set HashedMessage(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set SerialNumber(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set ftTime(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set pvAccuracy(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: i32
  set fOrdering(value: number) {
    this.view.setInt32(56, value, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  set Nonce(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: pointer
  set Tsa(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x50: u32
  set cExtension(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_CONTEXT (size: 24)
 */
export interface CRYPT_TIMESTAMP_CONTEXT {
  /** u32 */
  cbEncoded: number;
  /** ptr */
  pbEncoded: Deno.PointerValue | Uint8Array;
  /** ptr */
  pTimeStamp: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_TIMESTAMP_CONTEXT = 24;

export function allocCRYPT_TIMESTAMP_CONTEXT(data?: Partial<CRYPT_TIMESTAMP_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_TIMESTAMP_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbEncoded !== undefined) view.setUint32(0, Number(data.cbEncoded), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbEncoded !== undefined) view.setBigUint64(8, data.pbEncoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbEncoded))), true);
  // 0x10: pointer
  if (data?.pTimeStamp !== undefined) view.setBigUint64(16, data.pTimeStamp === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pTimeStamp))), true);
  return buf;
}

export class CRYPT_TIMESTAMP_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbEncoded(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbEncoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pTimeStamp(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbEncoded(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbEncoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pTimeStamp(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_TIMESTAMP_PARA (size: 40)
 */
export interface CRYPT_TIMESTAMP_PARA {
  /** Windows.Win32.Foundation.PSTR */
  pszTSAPolicyId: string | null | Uint8Array;
  /** Windows.Win32.Foundation.BOOL */
  fRequestCerts: boolean;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Nonce: Uint8Array | Deno.PointerValue;
  /** u32 */
  cExtension: number;
  /** ptr */
  rgExtension: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_TIMESTAMP_PARA = 40;

export function allocCRYPT_TIMESTAMP_PARA(data?: Partial<CRYPT_TIMESTAMP_PARA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_TIMESTAMP_PARA);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.pszTSAPolicyId !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.pszTSAPolicyId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: i32
  if (data?.fRequestCerts !== undefined) view.setInt32(8, Number(data.fRequestCerts), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Nonce !== undefined) view.setBigUint64(16, data.Nonce === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Nonce))), true);
  // 0x18: u32
  if (data?.cExtension !== undefined) view.setUint32(24, Number(data.cExtension), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgExtension !== undefined) view.setBigUint64(32, data.rgExtension === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgExtension))), true);
  return buf;
}

export class CRYPT_TIMESTAMP_PARAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get pszTSAPolicyId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: i32
  get fRequestCerts(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Nonce(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cExtension(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgExtension(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set pszTSAPolicyId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: i32
  set fRequestCerts(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Nonce(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set cExtension(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgExtension(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE (size: 48)
 */
export interface CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET */
  pfnGet: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE */
  pfnRelease: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD */
  pfnFreePassword: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE */
  pfnFree: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER */
  pfnFreeIdentifier: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = 48;

export function allocCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE(data?: Partial<CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pfnGet !== undefined) view.setBigUint64(8, data.pfnGet === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnGet))), true);
  // 0x10: pointer
  if (data?.pfnRelease !== undefined) view.setBigUint64(16, data.pfnRelease === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnRelease))), true);
  // 0x18: pointer
  if (data?.pfnFreePassword !== undefined) view.setBigUint64(24, data.pfnFreePassword === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFreePassword))), true);
  // 0x20: pointer
  if (data?.pfnFree !== undefined) view.setBigUint64(32, data.pfnFree === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFree))), true);
  // 0x28: pointer
  if (data?.pfnFreeIdentifier !== undefined) view.setBigUint64(40, data.pfnFreeIdentifier === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFreeIdentifier))), true);
  return buf;
}

export class CRYPT_OBJECT_LOCATOR_PROVIDER_TABLEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pfnGet(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pfnRelease(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pfnFreePassword(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pfnFree(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pfnFreeIdentifier(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pfnGet(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pfnRelease(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pfnFreePassword(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pfnFree(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pfnFreeIdentifier(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

export type HWND = Deno.PointerValue;

/**
 * Windows.Win32.Security.Cryptography.CRYPTPROTECT_PROMPTSTRUCT (size: 24)
 */
export interface CRYPTPROTECT_PROMPTSTRUCT {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwPromptFlags: number;
  /** Windows.Win32.Foundation.HWND */
  hwndApp: Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  szPrompt: string | null | Uint8Array | Uint16Array;
}

export const sizeofCRYPTPROTECT_PROMPTSTRUCT = 24;

export function allocCRYPTPROTECT_PROMPTSTRUCT(data?: Partial<CRYPTPROTECT_PROMPTSTRUCT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTPROTECT_PROMPTSTRUCT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwPromptFlags !== undefined) view.setUint32(4, Number(data.dwPromptFlags), true);
  // 0x08: pointer
  if (data?.hwndApp !== undefined) view.setBigUint64(8, data.hwndApp === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndApp))), true);
  // 0x10: buffer
  if (data?.szPrompt !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.szPrompt);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class CRYPTPROTECT_PROMPTSTRUCTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwPromptFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get hwndApp(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get szPrompt(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwPromptFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set hwndApp(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set szPrompt(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_PROTECT_STREAM_INFO (size: 16)
 */
export interface NCRYPT_PROTECT_STREAM_INFO {
  /** Windows.Win32.Security.Cryptography.PFNCryptStreamOutputCallback */
  pfnStreamOutput: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvCallbackCtxt: Deno.PointerValue | Uint8Array;
}

export const sizeofNCRYPT_PROTECT_STREAM_INFO = 16;

export function allocNCRYPT_PROTECT_STREAM_INFO(data?: Partial<NCRYPT_PROTECT_STREAM_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_PROTECT_STREAM_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pfnStreamOutput !== undefined) view.setBigUint64(0, data.pfnStreamOutput === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnStreamOutput))), true);
  // 0x08: pointer
  if (data?.pvCallbackCtxt !== undefined) view.setBigUint64(8, data.pvCallbackCtxt === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvCallbackCtxt))), true);
  return buf;
}

export class NCRYPT_PROTECT_STREAM_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pfnStreamOutput(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pvCallbackCtxt(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pfnStreamOutput(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pvCallbackCtxt(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.NCRYPT_PROTECT_STREAM_INFO_EX (size: 16)
 */
export interface NCRYPT_PROTECT_STREAM_INFO_EX {
  /** Windows.Win32.Security.Cryptography.PFNCryptStreamOutputCallbackEx */
  pfnStreamOutput: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvCallbackCtxt: Deno.PointerValue | Uint8Array;
}

export const sizeofNCRYPT_PROTECT_STREAM_INFO_EX = 16;

export function allocNCRYPT_PROTECT_STREAM_INFO_EX(data?: Partial<NCRYPT_PROTECT_STREAM_INFO_EX>): Uint8Array {
  const buf = new Uint8Array(sizeofNCRYPT_PROTECT_STREAM_INFO_EX);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pfnStreamOutput !== undefined) view.setBigUint64(0, data.pfnStreamOutput === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnStreamOutput))), true);
  // 0x08: pointer
  if (data?.pvCallbackCtxt !== undefined) view.setBigUint64(8, data.pvCallbackCtxt === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvCallbackCtxt))), true);
  return buf;
}

export class NCRYPT_PROTECT_STREAM_INFO_EXView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pfnStreamOutput(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pvCallbackCtxt(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pfnStreamOutput(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pvCallbackCtxt(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_BLOB (size: 16)
 */
export interface CRYPT_XML_BLOB {
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_CHARSET */
  dwCharset: CRYPT_XML_CHARSET;
  /** u32 */
  cbData: number;
  /** ptr */
  pbData: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_BLOB = 16;

export function allocCRYPT_XML_BLOB(data?: Partial<CRYPT_XML_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.dwCharset !== undefined) view.setInt32(0, Number(data.dwCharset), true);
  // 0x04: u32
  if (data?.cbData !== undefined) view.setUint32(4, Number(data.cbData), true);
  // 0x08: pointer
  if (data?.pbData !== undefined) view.setBigUint64(8, data.pbData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbData))), true);
  return buf;
}

export class CRYPT_XML_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get dwCharset(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: u32
  get cbData(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pbData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: i32
  set dwCharset(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: u32
  set cbData(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pbData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB (size: 16)
 */
export interface CRYPT_XML_DATA_BLOB {
  /** u32 */
  cbData: number;
  /** ptr */
  pbData: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_DATA_BLOB = 16;

export function allocCRYPT_XML_DATA_BLOB(data?: Partial<CRYPT_XML_DATA_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_DATA_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbData !== undefined) view.setUint32(0, Number(data.cbData), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pbData !== undefined) view.setBigUint64(8, data.pbData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbData))), true);
  return buf;
}

export class CRYPT_XML_DATA_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbData(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pbData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbData(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pbData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_PROPERTY (size: 24)
 */
export interface CRYPT_XML_PROPERTY {
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_PROPERTY_ID */
  dwPropId: CRYPT_XML_PROPERTY_ID;
  /** ptr */
  pvValue: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbValue: number;
}

export const sizeofCRYPT_XML_PROPERTY = 24;

export function allocCRYPT_XML_PROPERTY(data?: Partial<CRYPT_XML_PROPERTY>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_PROPERTY);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.dwPropId !== undefined) view.setInt32(0, Number(data.dwPropId), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pvValue !== undefined) view.setBigUint64(8, data.pvValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvValue))), true);
  // 0x10: u32
  if (data?.cbValue !== undefined) view.setUint32(16, Number(data.cbValue), true);
  // 0x14: pad4
  return buf;
}

export class CRYPT_XML_PROPERTYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get dwPropId(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pvValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbValue(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: i32
  set dwPropId(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pvValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbValue(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_PROVIDER (size: 32)
 */
export interface CRYPT_XML_DATA_PROVIDER {
  /** ptr */
  pvCallbackState: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbBufferSize: number;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_XML_DATA_PROVIDER_READ */
  pfnRead: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_XML_DATA_PROVIDER_CLOSE */
  pfnClose: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_DATA_PROVIDER = 32;

export function allocCRYPT_XML_DATA_PROVIDER(data?: Partial<CRYPT_XML_DATA_PROVIDER>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_DATA_PROVIDER);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pvCallbackState !== undefined) view.setBigUint64(0, data.pvCallbackState === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvCallbackState))), true);
  // 0x08: u32
  if (data?.cbBufferSize !== undefined) view.setUint32(8, Number(data.cbBufferSize), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.pfnRead !== undefined) view.setBigUint64(16, data.pfnRead === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnRead))), true);
  // 0x18: pointer
  if (data?.pfnClose !== undefined) view.setBigUint64(24, data.pfnClose === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnClose))), true);
  return buf;
}

export class CRYPT_XML_DATA_PROVIDERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pvCallbackState(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get cbBufferSize(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get pfnRead(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pfnClose(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set pvCallbackState(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set cbBufferSize(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set pfnRead(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pfnClose(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_STATUS (size: 16)
 */
export interface CRYPT_XML_STATUS {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_STATUS_ERROR_STATUS */
  dwErrorStatus: CRYPT_XML_STATUS_ERROR_STATUS;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_STATUS_INFO_STATUS */
  dwInfoStatus: CRYPT_XML_STATUS_INFO_STATUS;
}

export const sizeofCRYPT_XML_STATUS = 16;

export function allocCRYPT_XML_STATUS(data?: Partial<CRYPT_XML_STATUS>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_STATUS);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwErrorStatus !== undefined) view.setUint32(4, Number(data.dwErrorStatus), true);
  // 0x08: u32
  if (data?.dwInfoStatus !== undefined) view.setUint32(8, Number(data.dwInfoStatus), true);
  // 0x0c: pad4
  return buf;
}

export class CRYPT_XML_STATUSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwErrorStatus(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: u32
  get dwInfoStatus(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwErrorStatus(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: u32
  set dwInfoStatus(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_ALGORITHM (size: 24)
 */
export interface CRYPT_XML_ALGORITHM {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  wszAlgorithm: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_BLOB */
  Encoded: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_ALGORITHM = 24;

export function allocCRYPT_XML_ALGORITHM(data?: Partial<CRYPT_XML_ALGORITHM>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_ALGORITHM);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.wszAlgorithm !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.wszAlgorithm);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.Encoded !== undefined) view.setBigUint64(16, data.Encoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Encoded))), true);
  return buf;
}

export class CRYPT_XML_ALGORITHMView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get wszAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Encoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set wszAlgorithm(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set Encoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_TRANSFORM_INFO (size: 32)
 */
export interface CRYPT_XML_TRANSFORM_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  wszAlgorithm: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cbBufferSize: number;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_TRANSFORM_FLAGS */
  dwFlags: CRYPT_XML_TRANSFORM_FLAGS;
  /** Windows.Win32.Security.Cryptography.PFN_CRYPT_XML_CREATE_TRANSFORM */
  pfnCreateTransform: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_TRANSFORM_INFO = 32;

export function allocCRYPT_XML_TRANSFORM_INFO(data?: Partial<CRYPT_XML_TRANSFORM_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_TRANSFORM_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.wszAlgorithm !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.wszAlgorithm);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.cbBufferSize !== undefined) view.setUint32(16, Number(data.cbBufferSize), true);
  // 0x14: u32
  if (data?.dwFlags !== undefined) view.setUint32(20, Number(data.dwFlags), true);
  // 0x18: pointer
  if (data?.pfnCreateTransform !== undefined) view.setBigUint64(24, data.pfnCreateTransform === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnCreateTransform))), true);
  return buf;
}

export class CRYPT_XML_TRANSFORM_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get wszAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbBufferSize(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwFlags(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get pfnCreateTransform(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set wszAlgorithm(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set cbBufferSize(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwFlags(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set pfnCreateTransform(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_TRANSFORM_CHAIN_CONFIG (size: 16)
 */
export interface CRYPT_XML_TRANSFORM_CHAIN_CONFIG {
  /** u32 */
  cbSize: number;
  /** u32 */
  cTransformInfo: number;
  /** ptr */
  rgpTransformInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_TRANSFORM_CHAIN_CONFIG = 16;

export function allocCRYPT_XML_TRANSFORM_CHAIN_CONFIG(data?: Partial<CRYPT_XML_TRANSFORM_CHAIN_CONFIG>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_TRANSFORM_CHAIN_CONFIG);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.cTransformInfo !== undefined) view.setUint32(4, Number(data.cTransformInfo), true);
  // 0x08: pointer
  if (data?.rgpTransformInfo !== undefined) view.setBigUint64(8, data.rgpTransformInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpTransformInfo))), true);
  return buf;
}

export class CRYPT_XML_TRANSFORM_CHAIN_CONFIGView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cTransformInfo(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rgpTransformInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cTransformInfo(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rgpTransformInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_KEY_DSA_KEY_VALUE (size: 56)
 */
export interface CRYPT_XML_KEY_DSA_KEY_VALUE {
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  P: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  Q: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  G: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  Y: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  J: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  Seed: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  Counter: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_KEY_DSA_KEY_VALUE = 56;

export function allocCRYPT_XML_KEY_DSA_KEY_VALUE(data?: Partial<CRYPT_XML_KEY_DSA_KEY_VALUE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_KEY_DSA_KEY_VALUE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.P !== undefined) view.setBigUint64(0, data.P === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.P))), true);
  // 0x08: pointer
  if (data?.Q !== undefined) view.setBigUint64(8, data.Q === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Q))), true);
  // 0x10: pointer
  if (data?.G !== undefined) view.setBigUint64(16, data.G === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.G))), true);
  // 0x18: pointer
  if (data?.Y !== undefined) view.setBigUint64(24, data.Y === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Y))), true);
  // 0x20: pointer
  if (data?.J !== undefined) view.setBigUint64(32, data.J === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.J))), true);
  // 0x28: pointer
  if (data?.Seed !== undefined) view.setBigUint64(40, data.Seed === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Seed))), true);
  // 0x30: pointer
  if (data?.Counter !== undefined) view.setBigUint64(48, data.Counter === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Counter))), true);
  return buf;
}

export class CRYPT_XML_KEY_DSA_KEY_VALUEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get P(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Q(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get G(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get Y(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get J(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get Seed(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get Counter(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set P(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set Q(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set G(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set Y(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set J(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set Seed(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set Counter(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_KEY_ECDSA_KEY_VALUE (size: 32)
 */
export interface CRYPT_XML_KEY_ECDSA_KEY_VALUE {
  /** Windows.Win32.Foundation.PWSTR */
  wszNamedCurve: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  X: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  Y: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_BLOB */
  ExplicitPara: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_KEY_ECDSA_KEY_VALUE = 32;

export function allocCRYPT_XML_KEY_ECDSA_KEY_VALUE(data?: Partial<CRYPT_XML_KEY_ECDSA_KEY_VALUE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_KEY_ECDSA_KEY_VALUE);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.wszNamedCurve !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.wszNamedCurve);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: pointer
  if (data?.X !== undefined) view.setBigUint64(8, data.X === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.X))), true);
  // 0x10: pointer
  if (data?.Y !== undefined) view.setBigUint64(16, data.Y === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Y))), true);
  // 0x18: pointer
  if (data?.ExplicitPara !== undefined) view.setBigUint64(24, data.ExplicitPara === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ExplicitPara))), true);
  return buf;
}

export class CRYPT_XML_KEY_ECDSA_KEY_VALUEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get wszNamedCurve(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get X(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Y(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get ExplicitPara(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set wszNamedCurve(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: pointer
  set X(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Y(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set ExplicitPara(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_KEY_RSA_KEY_VALUE (size: 16)
 */
export interface CRYPT_XML_KEY_RSA_KEY_VALUE {
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  Modulus: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_DATA_BLOB */
  Exponent: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_KEY_RSA_KEY_VALUE = 16;

export function allocCRYPT_XML_KEY_RSA_KEY_VALUE(data?: Partial<CRYPT_XML_KEY_RSA_KEY_VALUE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_KEY_RSA_KEY_VALUE);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Modulus !== undefined) view.setBigUint64(0, data.Modulus === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Modulus))), true);
  // 0x08: pointer
  if (data?.Exponent !== undefined) view.setBigUint64(8, data.Exponent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Exponent))), true);
  return buf;
}

export class CRYPT_XML_KEY_RSA_KEY_VALUEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Modulus(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get Exponent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Modulus(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set Exponent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_KEY_VALUE (size: 16)
 */
export interface CRYPT_XML_KEY_VALUE {
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_KEY_VALUE_TYPE */
  dwType: CRYPT_XML_KEY_VALUE_TYPE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_KEY_VALUE = 16;

export function allocCRYPT_XML_KEY_VALUE(data?: Partial<CRYPT_XML_KEY_VALUE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_KEY_VALUE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwType !== undefined) view.setUint32(0, Number(data.dwType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CRYPT_XML_KEY_VALUEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_ISSUER_SERIAL (size: 16)
 */
export interface CRYPT_XML_ISSUER_SERIAL {
  /** Windows.Win32.Foundation.PWSTR */
  wszIssuer: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszSerial: string | null | Uint8Array | Uint16Array;
}

export const sizeofCRYPT_XML_ISSUER_SERIAL = 16;

export function allocCRYPT_XML_ISSUER_SERIAL(data?: Partial<CRYPT_XML_ISSUER_SERIAL>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_ISSUER_SERIAL);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.wszIssuer !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.wszIssuer);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.wszSerial !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.wszSerial);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  return buf;
}

export class CRYPT_XML_ISSUER_SERIALView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get wszIssuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get wszSerial(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set wszIssuer(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set wszSerial(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_X509DATA_ITEM (size: 16)
 */
export interface CRYPT_XML_X509DATA_ITEM {
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_X509DATA_TYPE */
  dwType: CRYPT_XML_X509DATA_TYPE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_X509DATA_ITEM = 16;

export function allocCRYPT_XML_X509DATA_ITEM(data?: Partial<CRYPT_XML_X509DATA_ITEM>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_X509DATA_ITEM);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwType !== undefined) view.setUint32(0, Number(data.dwType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CRYPT_XML_X509DATA_ITEMView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_X509DATA (size: 16)
 */
export interface CRYPT_XML_X509DATA {
  /** u32 */
  cX509Data: number;
  /** ptr */
  rgX509Data: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_X509DATA = 16;

export function allocCRYPT_XML_X509DATA(data?: Partial<CRYPT_XML_X509DATA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_X509DATA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cX509Data !== undefined) view.setUint32(0, Number(data.cX509Data), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgX509Data !== undefined) view.setBigUint64(8, data.rgX509Data === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgX509Data))), true);
  return buf;
}

export class CRYPT_XML_X509DATAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cX509Data(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgX509Data(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cX509Data(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgX509Data(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_KEY_INFO_ITEM (size: 16)
 */
export interface CRYPT_XML_KEY_INFO_ITEM {
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_KEYINFO_TYPE */
  dwType: CRYPT_XML_KEYINFO_TYPE;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_KEY_INFO_ITEM = 16;

export function allocCRYPT_XML_KEY_INFO_ITEM(data?: Partial<CRYPT_XML_KEY_INFO_ITEM>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_KEY_INFO_ITEM);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwType !== undefined) view.setUint32(0, Number(data.dwType), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CRYPT_XML_KEY_INFO_ITEMView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwType(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwType(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_KEY_INFO (size: 40)
 */
export interface CRYPT_XML_KEY_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  wszId: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cKeyInfo: number;
  /** ptr */
  rgKeyInfo: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */
  hVerifyKey: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_KEY_INFO = 40;

export function allocCRYPT_XML_KEY_INFO(data?: Partial<CRYPT_XML_KEY_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_KEY_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.wszId !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.wszId);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.cKeyInfo !== undefined) view.setUint32(16, Number(data.cKeyInfo), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.rgKeyInfo !== undefined) view.setBigUint64(24, data.rgKeyInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgKeyInfo))), true);
  // 0x20: pointer
  if (data?.hVerifyKey !== undefined) view.setBigUint64(32, data.hVerifyKey === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hVerifyKey))), true);
  return buf;
}

export class CRYPT_XML_KEY_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get wszId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cKeyInfo(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get rgKeyInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get hVerifyKey(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set wszId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set cKeyInfo(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set rgKeyInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set hVerifyKey(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_REFERENCE (size: 72)
 */
export interface CRYPT_XML_REFERENCE {
  /** u32 */
  cbSize: number;
  /** ptr */
  hReference: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszId: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszUri: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszType: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_ALGORITHM */
  DigestMethod: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  DigestValue: Uint8Array | Deno.PointerValue;
  /** u32 */
  cTransform: number;
  /** ptr */
  rgTransform: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_REFERENCE = 72;

export function allocCRYPT_XML_REFERENCE(data?: Partial<CRYPT_XML_REFERENCE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_REFERENCE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hReference !== undefined) view.setBigUint64(8, data.hReference === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hReference))), true);
  // 0x10: buffer
  if (data?.wszId !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.wszId);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: buffer
  if (data?.wszUri !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.wszUri);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: buffer
  if (data?.wszType !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.wszType);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: pointer
  if (data?.DigestMethod !== undefined) view.setBigUint64(40, data.DigestMethod === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DigestMethod))), true);
  // 0x30: pointer
  if (data?.DigestValue !== undefined) view.setBigUint64(48, data.DigestValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DigestValue))), true);
  // 0x38: u32
  if (data?.cTransform !== undefined) view.setUint32(56, Number(data.cTransform), true);
  // 0x3c: pad4
  // 0x40: pointer
  if (data?.rgTransform !== undefined) view.setBigUint64(64, data.rgTransform === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgTransform))), true);
  return buf;
}

export class CRYPT_XML_REFERENCEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get wszId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get wszUri(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get wszType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get DigestMethod(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get DigestValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: u32
  get cTransform(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  get rgTransform(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hReference(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set wszId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: buffer
  set wszUri(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: buffer
  set wszType(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: pointer
  set DigestMethod(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set DigestValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: u32
  set cTransform(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: pad4

  // 0x40: pointer
  set rgTransform(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_REFERENCES (size: 16)
 */
export interface CRYPT_XML_REFERENCES {
  /** u32 */
  cReference: number;
  /** ptr */
  rgpReference: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_REFERENCES = 16;

export function allocCRYPT_XML_REFERENCES(data?: Partial<CRYPT_XML_REFERENCES>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_REFERENCES);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cReference !== undefined) view.setUint32(0, Number(data.cReference), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rgpReference !== undefined) view.setBigUint64(8, data.rgpReference === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpReference))), true);
  return buf;
}

export class CRYPT_XML_REFERENCESView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cReference(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rgpReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cReference(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rgpReference(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_SIGNED_INFO (size: 56)
 */
export interface CRYPT_XML_SIGNED_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  wszId: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_ALGORITHM */
  Canonicalization: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_ALGORITHM */
  SignatureMethod: Uint8Array | Deno.PointerValue;
  /** u32 */
  cReference: number;
  /** ptr */
  rgpReference: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_BLOB */
  Encoded: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_SIGNED_INFO = 56;

export function allocCRYPT_XML_SIGNED_INFO(data?: Partial<CRYPT_XML_SIGNED_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_SIGNED_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.wszId !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.wszId);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.Canonicalization !== undefined) view.setBigUint64(16, data.Canonicalization === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Canonicalization))), true);
  // 0x18: pointer
  if (data?.SignatureMethod !== undefined) view.setBigUint64(24, data.SignatureMethod === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignatureMethod))), true);
  // 0x20: u32
  if (data?.cReference !== undefined) view.setUint32(32, Number(data.cReference), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgpReference !== undefined) view.setBigUint64(40, data.rgpReference === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpReference))), true);
  // 0x30: pointer
  if (data?.Encoded !== undefined) view.setBigUint64(48, data.Encoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Encoded))), true);
  return buf;
}

export class CRYPT_XML_SIGNED_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get wszId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Canonicalization(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get SignatureMethod(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cReference(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgpReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get Encoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set wszId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set Canonicalization(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set SignatureMethod(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cReference(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgpReference(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set Encoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_OBJECT (size: 56)
 */
export interface CRYPT_XML_OBJECT {
  /** u32 */
  cbSize: number;
  /** ptr */
  hObject: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszId: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszMimeType: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszEncoding: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_REFERENCES */
  Manifest: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_BLOB */
  Encoded: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_OBJECT = 56;

export function allocCRYPT_XML_OBJECT(data?: Partial<CRYPT_XML_OBJECT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_OBJECT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hObject !== undefined) view.setBigUint64(8, data.hObject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hObject))), true);
  // 0x10: buffer
  if (data?.wszId !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.wszId);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: buffer
  if (data?.wszMimeType !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.wszMimeType);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: buffer
  if (data?.wszEncoding !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.wszEncoding);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: pointer
  if (data?.Manifest !== undefined) view.setBigUint64(40, data.Manifest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Manifest))), true);
  // 0x30: pointer
  if (data?.Encoded !== undefined) view.setBigUint64(48, data.Encoded === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Encoded))), true);
  return buf;
}

export class CRYPT_XML_OBJECTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hObject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get wszId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get wszMimeType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get wszEncoding(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get Manifest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get Encoded(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hObject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set wszId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: buffer
  set wszMimeType(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: buffer
  set wszEncoding(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: pointer
  set Manifest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set Encoded(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_SIGNATURE (size: 64)
 */
export interface CRYPT_XML_SIGNATURE {
  /** u32 */
  cbSize: number;
  /** ptr */
  hSignature: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszId: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_SIGNED_INFO */
  SignedInfo: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SignatureValue: Uint8Array | Deno.PointerValue;
  /** ptr */
  pKeyInfo: Deno.PointerValue | Uint8Array;
  /** u32 */
  cObject: number;
  /** ptr */
  rgpObject: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_SIGNATURE = 64;

export function allocCRYPT_XML_SIGNATURE(data?: Partial<CRYPT_XML_SIGNATURE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_SIGNATURE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hSignature !== undefined) view.setBigUint64(8, data.hSignature === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hSignature))), true);
  // 0x10: buffer
  if (data?.wszId !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.wszId);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: pointer
  if (data?.SignedInfo !== undefined) view.setBigUint64(24, data.SignedInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignedInfo))), true);
  // 0x20: pointer
  if (data?.SignatureValue !== undefined) view.setBigUint64(32, data.SignatureValue === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SignatureValue))), true);
  // 0x28: pointer
  if (data?.pKeyInfo !== undefined) view.setBigUint64(40, data.pKeyInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pKeyInfo))), true);
  // 0x30: u32
  if (data?.cObject !== undefined) view.setUint32(48, Number(data.cObject), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.rgpObject !== undefined) view.setBigUint64(56, data.rgpObject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpObject))), true);
  return buf;
}

export class CRYPT_XML_SIGNATUREView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hSignature(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get wszId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get SignedInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get SignatureValue(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pKeyInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cObject(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get rgpObject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hSignature(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set wszId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: pointer
  set SignedInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set SignatureValue(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pKeyInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cObject(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set rgpObject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_DOC_CTXT (size: 40)
 */
export interface CRYPT_XML_DOC_CTXT {
  /** u32 */
  cbSize: number;
  /** ptr */
  hDocCtxt: Deno.PointerValue | Uint8Array;
  /** ptr */
  pTransformsConfig: Deno.PointerValue | Uint8Array;
  /** u32 */
  cSignature: number;
  /** ptr */
  rgpSignature: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_DOC_CTXT = 40;

export function allocCRYPT_XML_DOC_CTXT(data?: Partial<CRYPT_XML_DOC_CTXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_DOC_CTXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hDocCtxt !== undefined) view.setBigUint64(8, data.hDocCtxt === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hDocCtxt))), true);
  // 0x10: pointer
  if (data?.pTransformsConfig !== undefined) view.setBigUint64(16, data.pTransformsConfig === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pTransformsConfig))), true);
  // 0x18: u32
  if (data?.cSignature !== undefined) view.setUint32(24, Number(data.cSignature), true);
  // 0x1c: pad4
  // 0x20: pointer
  if (data?.rgpSignature !== undefined) view.setBigUint64(32, data.rgpSignature === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgpSignature))), true);
  return buf;
}

export class CRYPT_XML_DOC_CTXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hDocCtxt(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pTransformsConfig(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cSignature(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  get rgpSignature(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hDocCtxt(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pTransformsConfig(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set cSignature(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: pointer
  set rgpSignature(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_KEYINFO_PARAM (size: 64)
 */
export interface CRYPT_XML_KEYINFO_PARAM {
  /** Windows.Win32.Foundation.PWSTR */
  wszId: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszKeyName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  SKI: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  wszSubjectName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cCertificate: number;
  /** ptr */
  rgCertificate: Deno.PointerValue | Uint8Array;
  /** u32 */
  cCRL: number;
  /** ptr */
  rgCRL: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_KEYINFO_PARAM = 64;

export function allocCRYPT_XML_KEYINFO_PARAM(data?: Partial<CRYPT_XML_KEYINFO_PARAM>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_KEYINFO_PARAM);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.wszId !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.wszId);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.wszKeyName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.wszKeyName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.SKI !== undefined) view.setBigUint64(16, data.SKI === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.SKI))), true);
  // 0x18: buffer
  if (data?.wszSubjectName !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.wszSubjectName);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: u32
  if (data?.cCertificate !== undefined) view.setUint32(32, Number(data.cCertificate), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rgCertificate !== undefined) view.setBigUint64(40, data.rgCertificate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCertificate))), true);
  // 0x30: u32
  if (data?.cCRL !== undefined) view.setUint32(48, Number(data.cCRL), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.rgCRL !== undefined) view.setBigUint64(56, data.rgCRL === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgCRL))), true);
  return buf;
}

export class CRYPT_XML_KEYINFO_PARAMView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get wszId(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get wszKeyName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get SKI(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get wszSubjectName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cCertificate(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rgCertificate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cCRL(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get rgCRL(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set wszId(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set wszKeyName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set SKI(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: buffer
  set wszSubjectName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: u32
  set cCertificate(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rgCertificate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cCRL(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set rgCRL(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_ALGORITHM_INFO (size: 72)
 */
export interface CRYPT_XML_ALGORITHM_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  wszAlgorithmURI: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPT_XML_GROUP_ID */
  dwGroupId: CRYPT_XML_GROUP_ID;
  /** Windows.Win32.Foundation.PWSTR */
  wszCNGAlgid: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  wszCNGExtraAlgid: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwSignFlags: number;
  /** u32 */
  dwVerifyFlags: number;
  /** ptr */
  pvPaddingInfo: Deno.PointerValue | Uint8Array;
  /** ptr */
  pvExtraInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPT_XML_ALGORITHM_INFO = 72;

export function allocCRYPT_XML_ALGORITHM_INFO(data?: Partial<CRYPT_XML_ALGORITHM_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_ALGORITHM_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.wszAlgorithmURI !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.wszAlgorithmURI);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.wszName !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.wszName);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: u32
  if (data?.dwGroupId !== undefined) view.setUint32(24, Number(data.dwGroupId), true);
  // 0x1c: pad4
  // 0x20: buffer
  if (data?.wszCNGAlgid !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.wszCNGAlgid);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: buffer
  if (data?.wszCNGExtraAlgid !== undefined) {
    (buf as any)._f40 = util.pwstrToFfi(data.wszCNGExtraAlgid);
    view.setBigUint64(40, (buf as any)._f40 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f40))), true);
  }
  // 0x30: u32
  if (data?.dwSignFlags !== undefined) view.setUint32(48, Number(data.dwSignFlags), true);
  // 0x34: u32
  if (data?.dwVerifyFlags !== undefined) view.setUint32(52, Number(data.dwVerifyFlags), true);
  // 0x38: pointer
  if (data?.pvPaddingInfo !== undefined) view.setBigUint64(56, data.pvPaddingInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvPaddingInfo))), true);
  // 0x40: pointer
  if (data?.pvExtraInfo !== undefined) view.setBigUint64(64, data.pvExtraInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvExtraInfo))), true);
  return buf;
}

export class CRYPT_XML_ALGORITHM_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get wszAlgorithmURI(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get wszName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwGroupId(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  get wszCNGAlgid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: buffer
  get wszCNGExtraAlgid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get dwSignFlags(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: u32
  get dwVerifyFlags(): number {
    return this.view.getUint32(52, true);
  }

  // 0x38: pointer
  get pvPaddingInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: pointer
  get pvExtraInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set wszAlgorithmURI(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set wszName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: u32
  set dwGroupId(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  set wszCNGAlgid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: buffer
  set wszCNGExtraAlgid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f40 = value;
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f40))), true);
  }

  // 0x30: u32
  set dwSignFlags(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: u32
  set dwVerifyFlags(value: number) {
    this.view.setUint32(52, value, true);
  }

  // 0x38: pointer
  set pvPaddingInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: pointer
  set pvExtraInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CRYPT_XML_CRYPTOGRAPHIC_INTERFACE (size: 72)
 */
export interface CRYPT_XML_CRYPTOGRAPHIC_INTERFACE {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllEncodeAlgorithm */
  fpCryptXmlEncodeAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllCreateDigest */
  fpCryptXmlCreateDigest: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllDigestData */
  fpCryptXmlDigestData: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllFinalizeDigest */
  fpCryptXmlFinalizeDigest: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllCloseDigest */
  fpCryptXmlCloseDigest: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllSignData */
  fpCryptXmlSignData: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllVerifySignature */
  fpCryptXmlVerifySignature: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CryptXmlDllGetAlgorithmInfo */
  fpCryptXmlGetAlgorithmInfo: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPT_XML_CRYPTOGRAPHIC_INTERFACE = 72;

export function allocCRYPT_XML_CRYPTOGRAPHIC_INTERFACE(data?: Partial<CRYPT_XML_CRYPTOGRAPHIC_INTERFACE>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPT_XML_CRYPTOGRAPHIC_INTERFACE);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.fpCryptXmlEncodeAlgorithm !== undefined) view.setBigUint64(8, data.fpCryptXmlEncodeAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlEncodeAlgorithm))), true);
  // 0x10: pointer
  if (data?.fpCryptXmlCreateDigest !== undefined) view.setBigUint64(16, data.fpCryptXmlCreateDigest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlCreateDigest))), true);
  // 0x18: pointer
  if (data?.fpCryptXmlDigestData !== undefined) view.setBigUint64(24, data.fpCryptXmlDigestData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlDigestData))), true);
  // 0x20: pointer
  if (data?.fpCryptXmlFinalizeDigest !== undefined) view.setBigUint64(32, data.fpCryptXmlFinalizeDigest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlFinalizeDigest))), true);
  // 0x28: pointer
  if (data?.fpCryptXmlCloseDigest !== undefined) view.setBigUint64(40, data.fpCryptXmlCloseDigest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlCloseDigest))), true);
  // 0x30: pointer
  if (data?.fpCryptXmlSignData !== undefined) view.setBigUint64(48, data.fpCryptXmlSignData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlSignData))), true);
  // 0x38: pointer
  if (data?.fpCryptXmlVerifySignature !== undefined) view.setBigUint64(56, data.fpCryptXmlVerifySignature === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlVerifySignature))), true);
  // 0x40: pointer
  if (data?.fpCryptXmlGetAlgorithmInfo !== undefined) view.setBigUint64(64, data.fpCryptXmlGetAlgorithmInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.fpCryptXmlGetAlgorithmInfo))), true);
  return buf;
}

export class CRYPT_XML_CRYPTOGRAPHIC_INTERFACEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get fpCryptXmlEncodeAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get fpCryptXmlCreateDigest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get fpCryptXmlDigestData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get fpCryptXmlFinalizeDigest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get fpCryptXmlCloseDigest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get fpCryptXmlSignData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get fpCryptXmlVerifySignature(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: pointer
  get fpCryptXmlGetAlgorithmInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set fpCryptXmlEncodeAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set fpCryptXmlCreateDigest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set fpCryptXmlDigestData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set fpCryptXmlFinalizeDigest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set fpCryptXmlCloseDigest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set fpCryptXmlSignData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set fpCryptXmlVerifySignature(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: pointer
  set fpCryptXmlGetAlgorithmInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS (size: 24)
 */
export interface INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS {
  /** i32 */
  keySize: number;
  /** Windows.Win32.Foundation.PWSTR */
  keyExchangeAlgorithm: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  signatureAlgorithm: string | null | Uint8Array | Uint16Array;
}

export const sizeofINFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS = 24;

export function allocINFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS(data?: Partial<INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofINFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.keySize !== undefined) view.setInt32(0, Number(data.keySize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.keyExchangeAlgorithm !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.keyExchangeAlgorithm);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.signatureAlgorithm !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.signatureAlgorithm);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  return buf;
}

export class INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get keySize(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get keyExchangeAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get signatureAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: i32
  set keySize(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set keyExchangeAlgorithm(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set signatureAlgorithm(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS (size: 16)
 */
export interface INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS {
  /** i32 */
  keySize: number;
  /** i32 */
  blockSize: number;
  /** i32 */
  feedbackSize: number;
}

export const sizeofINFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS = 16;

export function allocINFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS(data?: Partial<INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofINFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.keySize !== undefined) view.setInt32(0, Number(data.keySize), true);
  // 0x04: i32
  if (data?.blockSize !== undefined) view.setInt32(4, Number(data.blockSize), true);
  // 0x08: i32
  if (data?.feedbackSize !== undefined) view.setInt32(8, Number(data.feedbackSize), true);
  // 0x0c: pad4
  return buf;
}

export class INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get keySize(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: i32
  get blockSize(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: i32
  get feedbackSize(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x00: i32
  set keySize(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: i32
  set blockSize(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: i32
  set feedbackSize(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS (size: 16)
 */
export interface INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS {
  /** i32 */
  inputBlockSize: number;
  /** i32 */
  outputBlockSize: number;
  /** Windows.Win32.Foundation.BOOL */
  canTransformMultipleBlocks: boolean;
  /** Windows.Win32.Foundation.BOOL */
  canReuseTransform: boolean;
}

export const sizeofINFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS = 16;

export function allocINFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS(data?: Partial<INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofINFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.inputBlockSize !== undefined) view.setInt32(0, Number(data.inputBlockSize), true);
  // 0x04: i32
  if (data?.outputBlockSize !== undefined) view.setInt32(4, Number(data.outputBlockSize), true);
  // 0x08: i32
  if (data?.canTransformMultipleBlocks !== undefined) view.setInt32(8, Number(data.canTransformMultipleBlocks), true);
  // 0x0c: i32
  if (data?.canReuseTransform !== undefined) view.setInt32(12, Number(data.canReuseTransform), true);
  return buf;
}

export class INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get inputBlockSize(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: i32
  get outputBlockSize(): number {
    return this.view.getInt32(4, true);
  }

  // 0x08: i32
  get canTransformMultipleBlocks(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: i32
  get canReuseTransform(): number {
    return this.view.getInt32(12, true);
  }

  // 0x00: i32
  set inputBlockSize(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: i32
  set outputBlockSize(value: number) {
    this.view.setInt32(4, value, true);
  }

  // 0x08: i32
  set canTransformMultipleBlocks(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: i32
  set canReuseTransform(value: number) {
    this.view.setInt32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.INFORMATIONCARD_HASH_CRYPTO_PARAMETERS (size: 16)
 */
export interface INFORMATIONCARD_HASH_CRYPTO_PARAMETERS {
  /** i32 */
  hashSize: number;
  /** Windows.Win32.Security.Cryptography.INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS */
  transform: Uint8Array | Deno.PointerValue;
}

export const sizeofINFORMATIONCARD_HASH_CRYPTO_PARAMETERS = 16;

export function allocINFORMATIONCARD_HASH_CRYPTO_PARAMETERS(data?: Partial<INFORMATIONCARD_HASH_CRYPTO_PARAMETERS>): Uint8Array {
  const buf = new Uint8Array(sizeofINFORMATIONCARD_HASH_CRYPTO_PARAMETERS);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.hashSize !== undefined) view.setInt32(0, Number(data.hashSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.transform !== undefined) view.setBigUint64(8, data.transform === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.transform))), true);
  return buf;
}

export class INFORMATIONCARD_HASH_CRYPTO_PARAMETERSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get hashSize(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get transform(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: i32
  set hashSize(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set transform(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.INFORMATIONCARD_CRYPTO_HANDLE (size: 24)
 */
export interface INFORMATIONCARD_CRYPTO_HANDLE {
  /** Windows.Win32.Security.Cryptography.HandleType */
  type: HandleType;
  /** i64 */
  expiration: Deno.PointerValue;
  /** ptr */
  cryptoParameters: Deno.PointerValue | Uint8Array;
}

export const sizeofINFORMATIONCARD_CRYPTO_HANDLE = 24;

export function allocINFORMATIONCARD_CRYPTO_HANDLE(data?: Partial<INFORMATIONCARD_CRYPTO_HANDLE>): Uint8Array {
  const buf = new Uint8Array(sizeofINFORMATIONCARD_CRYPTO_HANDLE);
  const view = new DataView(buf.buffer);
  // 0x00: i32
  if (data?.type !== undefined) view.setInt32(0, Number(data.type), true);
  // 0x04: pad4
  // 0x08: i64
  if (data?.expiration !== undefined) view.setBigInt64(8, BigInt(data.expiration), true);
  // 0x10: pointer
  if (data?.cryptoParameters !== undefined) view.setBigUint64(16, data.cryptoParameters === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.cryptoParameters))), true);
  return buf;
}

export class INFORMATIONCARD_CRYPTO_HANDLEView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: i32
  get type(): number {
    return this.view.getInt32(0, true);
  }

  // 0x04: pad4

  // 0x08: i64
  get expiration(): Deno.PointerValue {
    return Number(this.view.getBigInt64(8, true));
  }

  // 0x10: pointer
  get cryptoParameters(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: i32
  set type(value: number) {
    this.view.setInt32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: i64
  set expiration(value: Deno.PointerValue) {
    this.view.setBigInt64(8, BigInt(value), true);
  }

  // 0x10: pointer
  set cryptoParameters(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.GENERIC_XML_TOKEN (size: 40)
 */
export interface GENERIC_XML_TOKEN {
  /** Windows.Win32.Foundation.FILETIME */
  createDate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.FILETIME */
  expiryDate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  xmlToken: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  internalTokenReference: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  externalTokenReference: string | null | Uint8Array | Uint16Array;
}

export const sizeofGENERIC_XML_TOKEN = 40;

export function allocGENERIC_XML_TOKEN(data?: Partial<GENERIC_XML_TOKEN>): Uint8Array {
  const buf = new Uint8Array(sizeofGENERIC_XML_TOKEN);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.createDate !== undefined) view.setBigUint64(0, data.createDate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.createDate))), true);
  // 0x08: pointer
  if (data?.expiryDate !== undefined) view.setBigUint64(8, data.expiryDate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.expiryDate))), true);
  // 0x10: buffer
  if (data?.xmlToken !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.xmlToken);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: buffer
  if (data?.internalTokenReference !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.internalTokenReference);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: buffer
  if (data?.externalTokenReference !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.externalTokenReference);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  return buf;
}

export class GENERIC_XML_TOKENView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get createDate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get expiryDate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get xmlToken(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get internalTokenReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get externalTokenReference(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set createDate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set expiryDate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set xmlToken(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: buffer
  set internalTokenReference(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: buffer
  set externalTokenReference(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.POLICY_ELEMENT (size: 40)
 */
export interface POLICY_ELEMENT {
  /** Windows.Win32.Foundation.PWSTR */
  targetEndpointAddress: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  issuerEndpointAddress: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  issuedTokenParameters: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  privacyNoticeLink: string | null | Uint8Array | Uint16Array;
  /** u32 */
  privacyNoticeVersion: number;
  /** Windows.Win32.Foundation.BOOL */
  useManagedPresentation: boolean;
}

export const sizeofPOLICY_ELEMENT = 40;

export function allocPOLICY_ELEMENT(data?: Partial<POLICY_ELEMENT>): Uint8Array {
  const buf = new Uint8Array(sizeofPOLICY_ELEMENT);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.targetEndpointAddress !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.targetEndpointAddress);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.issuerEndpointAddress !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.issuerEndpointAddress);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.issuedTokenParameters !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.issuedTokenParameters);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: buffer
  if (data?.privacyNoticeLink !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.privacyNoticeLink);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: u32
  if (data?.privacyNoticeVersion !== undefined) view.setUint32(32, Number(data.privacyNoticeVersion), true);
  // 0x24: i32
  if (data?.useManagedPresentation !== undefined) view.setInt32(36, Number(data.useManagedPresentation), true);
  return buf;
}

export class POLICY_ELEMENTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get targetEndpointAddress(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get issuerEndpointAddress(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get issuedTokenParameters(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get privacyNoticeLink(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get privacyNoticeVersion(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: i32
  get useManagedPresentation(): number {
    return this.view.getInt32(36, true);
  }

  // 0x00: buffer
  set targetEndpointAddress(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set issuerEndpointAddress(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set issuedTokenParameters(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: buffer
  set privacyNoticeLink(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: u32
  set privacyNoticeVersion(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: i32
  set useManagedPresentation(value: number) {
    this.view.setInt32(36, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.ENDPOINTADDRESS (size: 24)
 */
export interface ENDPOINTADDRESS {
  /** Windows.Win32.Foundation.PWSTR */
  serviceUrl: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  policyUrl: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  rawCertificate: Uint8Array | Deno.PointerValue;
}

export const sizeofENDPOINTADDRESS = 24;

export function allocENDPOINTADDRESS(data?: Partial<ENDPOINTADDRESS>): Uint8Array {
  const buf = new Uint8Array(sizeofENDPOINTADDRESS);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.serviceUrl !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.serviceUrl);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.policyUrl !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.policyUrl);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: pointer
  if (data?.rawCertificate !== undefined) view.setBigUint64(16, data.rawCertificate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rawCertificate))), true);
  return buf;
}

export class ENDPOINTADDRESSView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get serviceUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get policyUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get rawCertificate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set serviceUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set policyUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: pointer
  set rawCertificate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.ENDPOINTADDRESS2 (size: 32)
 */
export interface ENDPOINTADDRESS2 {
  /** Windows.Win32.Foundation.PWSTR */
  serviceUrl: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  policyUrl: string | null | Uint8Array | Uint16Array;
  /** u32 */
  identityType: number;
  /** ptr */
  identityBytes: Deno.PointerValue | Uint8Array;
}

export const sizeofENDPOINTADDRESS2 = 32;

export function allocENDPOINTADDRESS2(data?: Partial<ENDPOINTADDRESS2>): Uint8Array {
  const buf = new Uint8Array(sizeofENDPOINTADDRESS2);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.serviceUrl !== undefined) {
    (buf as any)._f0 = util.pwstrToFfi(data.serviceUrl);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: buffer
  if (data?.policyUrl !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.policyUrl);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.identityType !== undefined) view.setUint32(16, Number(data.identityType), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.identityBytes !== undefined) view.setBigUint64(24, data.identityBytes === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.identityBytes))), true);
  return buf;
}

export class ENDPOINTADDRESS2View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get serviceUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: buffer
  get policyUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get identityType(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get identityBytes(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: buffer
  set serviceUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: buffer
  set policyUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set identityType(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set identityBytes(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CERTIFICATE_CHAIN_BLOB (size: 16)
 */
export interface CERTIFICATE_CHAIN_BLOB {
  /** u32 */
  certCount: number;
  /** ptr */
  rawCertificates: Deno.PointerValue | Uint8Array;
}

export const sizeofCERTIFICATE_CHAIN_BLOB = 16;

export function allocCERTIFICATE_CHAIN_BLOB(data?: Partial<CERTIFICATE_CHAIN_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofCERTIFICATE_CHAIN_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.certCount !== undefined) view.setUint32(0, Number(data.certCount), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.rawCertificates !== undefined) view.setBigUint64(8, data.rawCertificates === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rawCertificates))), true);
  return buf;
}

export class CERTIFICATE_CHAIN_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get certCount(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get rawCertificates(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set certCount(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set rawCertificates(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.CLAIMLIST (size: 16)
 */
export interface CLAIMLIST {
  /** u32 */
  count: number;
  /** ptr */
  claims: Deno.PointerValue | Uint8Array;
}

export const sizeofCLAIMLIST = 16;

export function allocCLAIMLIST(data?: Partial<CLAIMLIST>): Uint8Array {
  const buf = new Uint8Array(sizeofCLAIMLIST);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.count !== undefined) view.setUint32(0, Number(data.count), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.claims !== undefined) view.setBigUint64(8, data.claims === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.claims))), true);
  return buf;
}

export class CLAIMLISTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get count(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get claims(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set count(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set claims(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.RECIPIENTPOLICY (size: 56)
 */
export interface RECIPIENTPOLICY {
  /** Windows.Win32.Security.Cryptography.ENDPOINTADDRESS */
  recipient: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.ENDPOINTADDRESS */
  issuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  tokenType: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CLAIMLIST */
  requiredClaims: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CLAIMLIST */
  optionalClaims: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  privacyUrl: string | null | Uint8Array | Uint16Array;
  /** u32 */
  privacyVersion: number;
}

export const sizeofRECIPIENTPOLICY = 56;

export function allocRECIPIENTPOLICY(data?: Partial<RECIPIENTPOLICY>): Uint8Array {
  const buf = new Uint8Array(sizeofRECIPIENTPOLICY);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.recipient !== undefined) view.setBigUint64(0, data.recipient === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.recipient))), true);
  // 0x08: pointer
  if (data?.issuer !== undefined) view.setBigUint64(8, data.issuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.issuer))), true);
  // 0x10: buffer
  if (data?.tokenType !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.tokenType);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: pointer
  if (data?.requiredClaims !== undefined) view.setBigUint64(24, data.requiredClaims === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.requiredClaims))), true);
  // 0x20: pointer
  if (data?.optionalClaims !== undefined) view.setBigUint64(32, data.optionalClaims === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.optionalClaims))), true);
  // 0x28: buffer
  if (data?.privacyUrl !== undefined) {
    (buf as any)._f40 = util.pwstrToFfi(data.privacyUrl);
    view.setBigUint64(40, (buf as any)._f40 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f40))), true);
  }
  // 0x30: u32
  if (data?.privacyVersion !== undefined) view.setUint32(48, Number(data.privacyVersion), true);
  // 0x34: pad4
  return buf;
}

export class RECIPIENTPOLICYView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get recipient(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get issuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get tokenType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get requiredClaims(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get optionalClaims(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: buffer
  get privacyUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get privacyVersion(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x00: pointer
  set recipient(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set issuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set tokenType(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: pointer
  set requiredClaims(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set optionalClaims(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: buffer
  set privacyUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f40 = value;
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f40))), true);
  }

  // 0x30: u32
  set privacyVersion(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4
}

/**
 * Windows.Win32.Security.Cryptography.RECIPIENTPOLICY2 (size: 56)
 */
export interface RECIPIENTPOLICY2 {
  /** Windows.Win32.Security.Cryptography.ENDPOINTADDRESS2 */
  recipient: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.ENDPOINTADDRESS2 */
  issuer: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  tokenType: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.CLAIMLIST */
  requiredClaims: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CLAIMLIST */
  optionalClaims: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  privacyUrl: string | null | Uint8Array | Uint16Array;
  /** u32 */
  privacyVersion: number;
}

export const sizeofRECIPIENTPOLICY2 = 56;

export function allocRECIPIENTPOLICY2(data?: Partial<RECIPIENTPOLICY2>): Uint8Array {
  const buf = new Uint8Array(sizeofRECIPIENTPOLICY2);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.recipient !== undefined) view.setBigUint64(0, data.recipient === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.recipient))), true);
  // 0x08: pointer
  if (data?.issuer !== undefined) view.setBigUint64(8, data.issuer === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.issuer))), true);
  // 0x10: buffer
  if (data?.tokenType !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.tokenType);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: pointer
  if (data?.requiredClaims !== undefined) view.setBigUint64(24, data.requiredClaims === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.requiredClaims))), true);
  // 0x20: pointer
  if (data?.optionalClaims !== undefined) view.setBigUint64(32, data.optionalClaims === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.optionalClaims))), true);
  // 0x28: buffer
  if (data?.privacyUrl !== undefined) {
    (buf as any)._f40 = util.pwstrToFfi(data.privacyUrl);
    view.setBigUint64(40, (buf as any)._f40 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f40))), true);
  }
  // 0x30: u32
  if (data?.privacyVersion !== undefined) view.setUint32(48, Number(data.privacyVersion), true);
  // 0x34: pad4
  return buf;
}

export class RECIPIENTPOLICY2View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get recipient(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get issuer(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get tokenType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get requiredClaims(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get optionalClaims(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: buffer
  get privacyUrl(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get privacyVersion(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x00: pointer
  set recipient(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set issuer(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set tokenType(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: pointer
  set requiredClaims(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set optionalClaims(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: buffer
  set privacyUrl(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f40 = value;
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f40))), true);
  }

  // 0x30: u32
  set privacyVersion(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4
}

/**
 * Windows.Win32.Security.Cryptography.Sip.SIP_SUBJECTINFO (size: 112)
 */
export interface SIP_SUBJECTINFO {
  /** u32 */
  cbSize: number;
  /** ptr */
  pgSubjectType: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.HANDLE */
  hFile: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pwsFileName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwsDisplayName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwReserved1: number;
  /** u32 */
  dwIntVersion: number;
  /** usize */
  hProv: Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  DigestAlgorithm: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwEncodingType: number;
  /** u32 */
  dwReserved2: number;
  /** u32 */
  fdwCAPISettings: number;
  /** u32 */
  fdwSecuritySettings: number;
  /** u32 */
  dwIndex: number;
  /** u32 */
  dwUnionChoice: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** ptr */
  pClientData: Deno.PointerValue | Uint8Array;
}

export const sizeofSIP_SUBJECTINFO = 112;

export function allocSIP_SUBJECTINFO(data?: Partial<SIP_SUBJECTINFO>): Uint8Array {
  const buf = new Uint8Array(sizeofSIP_SUBJECTINFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pgSubjectType !== undefined) view.setBigUint64(8, data.pgSubjectType === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pgSubjectType))), true);
  // 0x10: pointer
  if (data?.hFile !== undefined) view.setBigUint64(16, data.hFile === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hFile))), true);
  // 0x18: buffer
  if (data?.pwsFileName !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.pwsFileName);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: buffer
  if (data?.pwsDisplayName !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.pwsDisplayName);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: u32
  if (data?.dwReserved1 !== undefined) view.setUint32(40, Number(data.dwReserved1), true);
  // 0x2c: u32
  if (data?.dwIntVersion !== undefined) view.setUint32(44, Number(data.dwIntVersion), true);
  // 0x30: usize
  if (data?.hProv !== undefined) view.setBigUint64(48, BigInt(data.hProv), true);
  // 0x38: pointer
  if (data?.DigestAlgorithm !== undefined) view.setBigUint64(56, data.DigestAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DigestAlgorithm))), true);
  // 0x40: u32
  if (data?.dwFlags !== undefined) view.setUint32(64, Number(data.dwFlags), true);
  // 0x44: u32
  if (data?.dwEncodingType !== undefined) view.setUint32(68, Number(data.dwEncodingType), true);
  // 0x48: u32
  if (data?.dwReserved2 !== undefined) view.setUint32(72, Number(data.dwReserved2), true);
  // 0x4c: u32
  if (data?.fdwCAPISettings !== undefined) view.setUint32(76, Number(data.fdwCAPISettings), true);
  // 0x50: u32
  if (data?.fdwSecuritySettings !== undefined) view.setUint32(80, Number(data.fdwSecuritySettings), true);
  // 0x54: u32
  if (data?.dwIndex !== undefined) view.setUint32(84, Number(data.dwIndex), true);
  // 0x58: u32
  if (data?.dwUnionChoice !== undefined) view.setUint32(88, Number(data.dwUnionChoice), true);
  // 0x5c: pad4
  // 0x60: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(96, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x68: pointer
  if (data?.pClientData !== undefined) view.setBigUint64(104, data.pClientData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pClientData))), true);
  return buf;
}

export class SIP_SUBJECTINFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pgSubjectType(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hFile(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get pwsFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pwsDisplayName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get dwReserved1(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: u32
  get dwIntVersion(): number {
    return this.view.getUint32(44, true);
  }

  // 0x30: usize
  get hProv(): Deno.PointerValue {
    return Number(this.view.getBigUint64(48, true));
  }

  // 0x38: pointer
  get DigestAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: u32
  get dwFlags(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: u32
  get dwEncodingType(): number {
    return this.view.getUint32(68, true);
  }

  // 0x48: u32
  get dwReserved2(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: u32
  get fdwCAPISettings(): number {
    return this.view.getUint32(76, true);
  }

  // 0x50: u32
  get fdwSecuritySettings(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: u32
  get dwIndex(): number {
    return this.view.getUint32(84, true);
  }

  // 0x58: u32
  get dwUnionChoice(): number {
    return this.view.getUint32(88, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(96, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x68: pointer
  get pClientData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(104, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pgSubjectType(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hFile(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: buffer
  set pwsFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: buffer
  set pwsDisplayName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: u32
  set dwReserved1(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: u32
  set dwIntVersion(value: number) {
    this.view.setUint32(44, value, true);
  }

  // 0x30: usize
  set hProv(value: Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(value), true);
  }

  // 0x38: pointer
  set DigestAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: u32
  set dwFlags(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: u32
  set dwEncodingType(value: number) {
    this.view.setUint32(68, value, true);
  }

  // 0x48: u32
  set dwReserved2(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: u32
  set fdwCAPISettings(value: number) {
    this.view.setUint32(76, value, true);
  }

  // 0x50: u32
  set fdwSecuritySettings(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: u32
  set dwIndex(value: number) {
    this.view.setUint32(84, value, true);
  }

  // 0x58: u32
  set dwUnionChoice(value: number) {
    this.view.setUint32(88, value, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(96, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x68: pointer
  set pClientData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Sip.MS_ADDINFO_FLAT (size: 16)
 */
export interface MS_ADDINFO_FLAT {
  /** u32 */
  cbStruct: number;
  /** ptr */
  pIndirectData: Deno.PointerValue | Uint8Array;
}

export const sizeofMS_ADDINFO_FLAT = 16;

export function allocMS_ADDINFO_FLAT(data?: Partial<MS_ADDINFO_FLAT>): Uint8Array {
  const buf = new Uint8Array(sizeofMS_ADDINFO_FLAT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pIndirectData !== undefined) view.setBigUint64(8, data.pIndirectData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pIndirectData))), true);
  return buf;
}

export class MS_ADDINFO_FLATView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pIndirectData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pIndirectData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Sip.MS_ADDINFO_BLOB (size: 32)
 */
export interface MS_ADDINFO_BLOB {
  /** u32 */
  cbStruct: number;
  /** u32 */
  cbMemObject: number;
  /** ptr */
  pbMemObject: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbMemSignedMsg: number;
  /** ptr */
  pbMemSignedMsg: Deno.PointerValue | Uint8Array;
}

export const sizeofMS_ADDINFO_BLOB = 32;

export function allocMS_ADDINFO_BLOB(data?: Partial<MS_ADDINFO_BLOB>): Uint8Array {
  const buf = new Uint8Array(sizeofMS_ADDINFO_BLOB);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: u32
  if (data?.cbMemObject !== undefined) view.setUint32(4, Number(data.cbMemObject), true);
  // 0x08: pointer
  if (data?.pbMemObject !== undefined) view.setBigUint64(8, data.pbMemObject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbMemObject))), true);
  // 0x10: u32
  if (data?.cbMemSignedMsg !== undefined) view.setUint32(16, Number(data.cbMemSignedMsg), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pbMemSignedMsg !== undefined) view.setBigUint64(24, data.pbMemSignedMsg === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbMemSignedMsg))), true);
  return buf;
}

export class MS_ADDINFO_BLOBView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbMemObject(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pbMemObject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbMemSignedMsg(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pbMemSignedMsg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbMemObject(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pbMemObject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbMemSignedMsg(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pbMemSignedMsg(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Sip.SIP_CAP_SET_V2 (size: 16)
 */
export interface SIP_CAP_SET_V2 {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Foundation.BOOL */
  isMultiSign: boolean;
  /** u32 */
  dwReserved: number;
}

export const sizeofSIP_CAP_SET_V2 = 16;

export function allocSIP_CAP_SET_V2(data?: Partial<SIP_CAP_SET_V2>): Uint8Array {
  const buf = new Uint8Array(sizeofSIP_CAP_SET_V2);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwVersion !== undefined) view.setUint32(4, Number(data.dwVersion), true);
  // 0x08: i32
  if (data?.isMultiSign !== undefined) view.setInt32(8, Number(data.isMultiSign), true);
  // 0x0c: u32
  if (data?.dwReserved !== undefined) view.setUint32(12, Number(data.dwReserved), true);
  return buf;
}

export class SIP_CAP_SET_V2View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwVersion(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get isMultiSign(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: u32
  get dwReserved(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwVersion(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set isMultiSign(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: u32
  set dwReserved(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Sip.SIP_CAP_SET_V3 (size: 24)
 */
export interface SIP_CAP_SET_V3 {
  /** u32 */
  cbSize: number;
  /** u32 */
  dwVersion: number;
  /** Windows.Win32.Foundation.BOOL */
  isMultiSign: boolean;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofSIP_CAP_SET_V3 = 24;

export function allocSIP_CAP_SET_V3(data?: Partial<SIP_CAP_SET_V3>): Uint8Array {
  const buf = new Uint8Array(sizeofSIP_CAP_SET_V3);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: u32
  if (data?.dwVersion !== undefined) view.setUint32(4, Number(data.dwVersion), true);
  // 0x08: i32
  if (data?.isMultiSign !== undefined) view.setInt32(8, Number(data.isMultiSign), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(16, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class SIP_CAP_SET_V3View {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwVersion(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get isMultiSign(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwVersion(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set isMultiSign(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Sip.SIP_INDIRECT_DATA (size: 24)
 */
export interface SIP_INDIRECT_DATA {
  /** Windows.Win32.Security.Cryptography.CRYPT_ATTRIBUTE_TYPE_VALUE */
  Data: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_ALGORITHM_IDENTIFIER */
  DigestAlgorithm: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPTOAPI_BLOB */
  Digest: Uint8Array | Deno.PointerValue;
}

export const sizeofSIP_INDIRECT_DATA = 24;

export function allocSIP_INDIRECT_DATA(data?: Partial<SIP_INDIRECT_DATA>): Uint8Array {
  const buf = new Uint8Array(sizeofSIP_INDIRECT_DATA);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Data !== undefined) view.setBigUint64(0, data.Data === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Data))), true);
  // 0x08: pointer
  if (data?.DigestAlgorithm !== undefined) view.setBigUint64(8, data.DigestAlgorithm === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.DigestAlgorithm))), true);
  // 0x10: pointer
  if (data?.Digest !== undefined) view.setBigUint64(16, data.Digest === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Digest))), true);
  return buf;
}

export class SIP_INDIRECT_DATAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get Data(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get DigestAlgorithm(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get Digest(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set Data(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set DigestAlgorithm(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set Digest(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Sip.SIP_DISPATCH_INFO (size: 56)
 */
export interface SIP_DISPATCH_INFO {
  /** u32 */
  cbSize: number;
  /** Windows.Win32.Foundation.HANDLE */
  hSIP: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.Sip.pCryptSIPGetSignedDataMsg */
  pfGet: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.Sip.pCryptSIPPutSignedDataMsg */
  pfPut: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.Sip.pCryptSIPCreateIndirectData */
  pfCreate: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.Sip.pCryptSIPVerifyIndirectData */
  pfVerify: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.Sip.pCryptSIPRemoveSignedDataMsg */
  pfRemove: Uint8Array | Deno.PointerValue;
}

export const sizeofSIP_DISPATCH_INFO = 56;

export function allocSIP_DISPATCH_INFO(data?: Partial<SIP_DISPATCH_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofSIP_DISPATCH_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hSIP !== undefined) view.setBigUint64(8, data.hSIP === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hSIP))), true);
  // 0x10: pointer
  if (data?.pfGet !== undefined) view.setBigUint64(16, data.pfGet === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfGet))), true);
  // 0x18: pointer
  if (data?.pfPut !== undefined) view.setBigUint64(24, data.pfPut === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfPut))), true);
  // 0x20: pointer
  if (data?.pfCreate !== undefined) view.setBigUint64(32, data.pfCreate === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfCreate))), true);
  // 0x28: pointer
  if (data?.pfVerify !== undefined) view.setBigUint64(40, data.pfVerify === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfVerify))), true);
  // 0x30: pointer
  if (data?.pfRemove !== undefined) view.setBigUint64(48, data.pfRemove === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfRemove))), true);
  return buf;
}

export class SIP_DISPATCH_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hSIP(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pfGet(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pfPut(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pfCreate(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pfVerify(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get pfRemove(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hSIP(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pfGet(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pfPut(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: pointer
  set pfCreate(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set pfVerify(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set pfRemove(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Sip.SIP_ADD_NEWPROVIDER (size: 96)
 */
export interface SIP_ADD_NEWPROVIDER {
  /** u32 */
  cbStruct: number;
  /** ptr */
  pgSubject: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszDLLFileName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszMagicNumber: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszIsFunctionName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszGetFuncName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszPutFuncName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszCreateFuncName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszVerifyFuncName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszRemoveFuncName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszIsFunctionNameFmt2: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszGetCapFuncName: string | null | Uint8Array | Uint16Array;
}

export const sizeofSIP_ADD_NEWPROVIDER = 96;

export function allocSIP_ADD_NEWPROVIDER(data?: Partial<SIP_ADD_NEWPROVIDER>): Uint8Array {
  const buf = new Uint8Array(sizeofSIP_ADD_NEWPROVIDER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pgSubject !== undefined) view.setBigUint64(8, data.pgSubject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pgSubject))), true);
  // 0x10: buffer
  if (data?.pwszDLLFileName !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszDLLFileName);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: buffer
  if (data?.pwszMagicNumber !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.pwszMagicNumber);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: buffer
  if (data?.pwszIsFunctionName !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.pwszIsFunctionName);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: buffer
  if (data?.pwszGetFuncName !== undefined) {
    (buf as any)._f40 = util.pwstrToFfi(data.pwszGetFuncName);
    view.setBigUint64(40, (buf as any)._f40 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f40))), true);
  }
  // 0x30: buffer
  if (data?.pwszPutFuncName !== undefined) {
    (buf as any)._f48 = util.pwstrToFfi(data.pwszPutFuncName);
    view.setBigUint64(48, (buf as any)._f48 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f48))), true);
  }
  // 0x38: buffer
  if (data?.pwszCreateFuncName !== undefined) {
    (buf as any)._f56 = util.pwstrToFfi(data.pwszCreateFuncName);
    view.setBigUint64(56, (buf as any)._f56 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f56))), true);
  }
  // 0x40: buffer
  if (data?.pwszVerifyFuncName !== undefined) {
    (buf as any)._f64 = util.pwstrToFfi(data.pwszVerifyFuncName);
    view.setBigUint64(64, (buf as any)._f64 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f64))), true);
  }
  // 0x48: buffer
  if (data?.pwszRemoveFuncName !== undefined) {
    (buf as any)._f72 = util.pwstrToFfi(data.pwszRemoveFuncName);
    view.setBigUint64(72, (buf as any)._f72 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f72))), true);
  }
  // 0x50: buffer
  if (data?.pwszIsFunctionNameFmt2 !== undefined) {
    (buf as any)._f80 = util.pwstrToFfi(data.pwszIsFunctionNameFmt2);
    view.setBigUint64(80, (buf as any)._f80 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f80))), true);
  }
  // 0x58: buffer
  if (data?.pwszGetCapFuncName !== undefined) {
    (buf as any)._f88 = util.pwstrToFfi(data.pwszGetCapFuncName);
    view.setBigUint64(88, (buf as any)._f88 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f88))), true);
  }
  return buf;
}

export class SIP_ADD_NEWPROVIDERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pgSubject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszDLLFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get pwszMagicNumber(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pwszIsFunctionName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: buffer
  get pwszGetFuncName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: buffer
  get pwszPutFuncName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: buffer
  get pwszCreateFuncName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: buffer
  get pwszVerifyFuncName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: buffer
  get pwszRemoveFuncName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: buffer
  get pwszIsFunctionNameFmt2(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x58: buffer
  get pwszGetCapFuncName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pgSubject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: buffer
  set pwszDLLFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: buffer
  set pwszMagicNumber(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: buffer
  set pwszIsFunctionName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: buffer
  set pwszGetFuncName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f40 = value;
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f40))), true);
  }

  // 0x30: buffer
  set pwszPutFuncName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f48 = value;
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f48))), true);
  }

  // 0x38: buffer
  set pwszCreateFuncName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f56 = value;
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f56))), true);
  }

  // 0x40: buffer
  set pwszVerifyFuncName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f64 = value;
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f64))), true);
  }

  // 0x48: buffer
  set pwszRemoveFuncName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f72 = value;
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f72))), true);
  }

  // 0x50: buffer
  set pwszIsFunctionNameFmt2(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f80 = value;
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f80))), true);
  }

  // 0x58: buffer
  set pwszGetCapFuncName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f88 = value;
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f88))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.Catalog.MS_ADDINFO_CATALOGMEMBER (size: 24)
 */
export interface MS_ADDINFO_CATALOGMEMBER {
  /** u32 */
  cbStruct: number;
  /** ptr */
  pStore: Deno.PointerValue | Uint8Array;
  /** ptr */
  pMember: Deno.PointerValue | Uint8Array;
}

export const sizeofMS_ADDINFO_CATALOGMEMBER = 24;

export function allocMS_ADDINFO_CATALOGMEMBER(data?: Partial<MS_ADDINFO_CATALOGMEMBER>): Uint8Array {
  const buf = new Uint8Array(sizeofMS_ADDINFO_CATALOGMEMBER);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbStruct !== undefined) view.setUint32(0, Number(data.cbStruct), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pStore !== undefined) view.setBigUint64(8, data.pStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pStore))), true);
  // 0x10: pointer
  if (data?.pMember !== undefined) view.setBigUint64(16, data.pMember === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pMember))), true);
  return buf;
}

export class MS_ADDINFO_CATALOGMEMBERView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbStruct(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pMember(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbStruct(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pMember(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

export type HINSTANCE = Deno.PointerValue;

export type LPARAM = Deno.PointerValue;

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_SELECT_STRUCT_A (size: 136)
 */
export interface CERT_SELECT_STRUCT_A {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.HWND */
  hwndParent: Deno.PointerValue;
  /** Windows.Win32.Foundation.HINSTANCE */
  hInstance: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PSTR */
  pTemplateName: string | null | Uint8Array;
  /** Windows.Win32.Security.Cryptography.UI.CERT_SELECT_STRUCT_FLAGS */
  dwFlags: CERT_SELECT_STRUCT_FLAGS;
  /** Windows.Win32.Foundation.PSTR */
  szTitle: string | null | Uint8Array;
  /** u32 */
  cCertStore: number;
  /** ptr */
  arrayCertStore: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PSTR */
  szPurposeOid: string | null | Uint8Array;
  /** u32 */
  cCertContext: number;
  /** ptr */
  arrayCertContext: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.LPARAM */
  lCustData: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.PFNCMHOOKPROC */
  pfnHook: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.PFNCMFILTERPROC */
  pfnFilter: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PSTR */
  szHelpFileName: string | null | Uint8Array;
  /** u32 */
  dwHelpId: number;
  /** usize */
  hprov: Deno.PointerValue;
}

export const sizeofCERT_SELECT_STRUCT_A = 136;

export function allocCERT_SELECT_STRUCT_A(data?: Partial<CERT_SELECT_STRUCT_A>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SELECT_STRUCT_A);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hwndParent !== undefined) view.setBigUint64(8, data.hwndParent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndParent))), true);
  // 0x10: pointer
  if (data?.hInstance !== undefined) view.setBigUint64(16, data.hInstance === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hInstance))), true);
  // 0x18: buffer
  if (data?.pTemplateName !== undefined) {
    (buf as any)._f24 = util.pstrToFfi(data.pTemplateName);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: u32
  if (data?.dwFlags !== undefined) view.setUint32(32, Number(data.dwFlags), true);
  // 0x24: pad4
  // 0x28: buffer
  if (data?.szTitle !== undefined) {
    (buf as any)._f40 = util.pstrToFfi(data.szTitle);
    view.setBigUint64(40, (buf as any)._f40 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f40))), true);
  }
  // 0x30: u32
  if (data?.cCertStore !== undefined) view.setUint32(48, Number(data.cCertStore), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.arrayCertStore !== undefined) view.setBigUint64(56, data.arrayCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayCertStore))), true);
  // 0x40: buffer
  if (data?.szPurposeOid !== undefined) {
    (buf as any)._f64 = util.pstrToFfi(data.szPurposeOid);
    view.setBigUint64(64, (buf as any)._f64 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f64))), true);
  }
  // 0x48: u32
  if (data?.cCertContext !== undefined) view.setUint32(72, Number(data.cCertContext), true);
  // 0x4c: pad4
  // 0x50: pointer
  if (data?.arrayCertContext !== undefined) view.setBigUint64(80, data.arrayCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayCertContext))), true);
  // 0x58: pointer
  if (data?.lCustData !== undefined) view.setBigUint64(88, data.lCustData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.lCustData))), true);
  // 0x60: pointer
  if (data?.pfnHook !== undefined) view.setBigUint64(96, data.pfnHook === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnHook))), true);
  // 0x68: pointer
  if (data?.pfnFilter !== undefined) view.setBigUint64(104, data.pfnFilter === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFilter))), true);
  // 0x70: buffer
  if (data?.szHelpFileName !== undefined) {
    (buf as any)._f112 = util.pstrToFfi(data.szHelpFileName);
    view.setBigUint64(112, (buf as any)._f112 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f112))), true);
  }
  // 0x78: u32
  if (data?.dwHelpId !== undefined) view.setUint32(120, Number(data.dwHelpId), true);
  // 0x7c: pad4
  // 0x80: usize
  if (data?.hprov !== undefined) view.setBigUint64(128, BigInt(data.hprov), true);
  return buf;
}

export class CERT_SELECT_STRUCT_AView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hwndParent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hInstance(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get pTemplateName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwFlags(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: buffer
  get szTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cCertStore(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get arrayCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: buffer
  get szPurposeOid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: u32
  get cCertContext(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  get arrayCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x58: pointer
  get lCustData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x60: pointer
  get pfnHook(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(96, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x68: pointer
  get pfnFilter(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(104, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x70: buffer
  get szHelpFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(112, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x78: u32
  get dwHelpId(): number {
    return this.view.getUint32(120, true);
  }

  // 0x7c: pad4

  // 0x80: usize
  get hprov(): Deno.PointerValue {
    return Number(this.view.getBigUint64(128, true));
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hwndParent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hInstance(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: buffer
  set pTemplateName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: u32
  set dwFlags(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: buffer
  set szTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f40 = value;
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f40))), true);
  }

  // 0x30: u32
  set cCertStore(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set arrayCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: buffer
  set szPurposeOid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f64 = value;
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f64))), true);
  }

  // 0x48: u32
  set cCertContext(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  set arrayCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x58: pointer
  set lCustData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x60: pointer
  set pfnHook(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(96, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x68: pointer
  set pfnFilter(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x70: buffer
  set szHelpFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f112 = value;
    this.view.setBigUint64(112, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f112))), true);
  }

  // 0x78: u32
  set dwHelpId(value: number) {
    this.view.setUint32(120, value, true);
  }

  // 0x7c: pad4

  // 0x80: usize
  set hprov(value: Deno.PointerValue) {
    this.view.setBigUint64(128, BigInt(value), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_SELECT_STRUCT_W (size: 136)
 */
export interface CERT_SELECT_STRUCT_W {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.HWND */
  hwndParent: Deno.PointerValue;
  /** Windows.Win32.Foundation.HINSTANCE */
  hInstance: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pTemplateName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.UI.CERT_SELECT_STRUCT_FLAGS */
  dwFlags: CERT_SELECT_STRUCT_FLAGS;
  /** Windows.Win32.Foundation.PWSTR */
  szTitle: string | null | Uint8Array | Uint16Array;
  /** u32 */
  cCertStore: number;
  /** ptr */
  arrayCertStore: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PSTR */
  szPurposeOid: string | null | Uint8Array;
  /** u32 */
  cCertContext: number;
  /** ptr */
  arrayCertContext: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.LPARAM */
  lCustData: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.PFNCMHOOKPROC */
  pfnHook: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.PFNCMFILTERPROC */
  pfnFilter: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  szHelpFileName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwHelpId: number;
  /** usize */
  hprov: Deno.PointerValue;
}

export const sizeofCERT_SELECT_STRUCT_W = 136;

export function allocCERT_SELECT_STRUCT_W(data?: Partial<CERT_SELECT_STRUCT_W>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SELECT_STRUCT_W);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hwndParent !== undefined) view.setBigUint64(8, data.hwndParent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndParent))), true);
  // 0x10: pointer
  if (data?.hInstance !== undefined) view.setBigUint64(16, data.hInstance === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hInstance))), true);
  // 0x18: buffer
  if (data?.pTemplateName !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.pTemplateName);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: u32
  if (data?.dwFlags !== undefined) view.setUint32(32, Number(data.dwFlags), true);
  // 0x24: pad4
  // 0x28: buffer
  if (data?.szTitle !== undefined) {
    (buf as any)._f40 = util.pwstrToFfi(data.szTitle);
    view.setBigUint64(40, (buf as any)._f40 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f40))), true);
  }
  // 0x30: u32
  if (data?.cCertStore !== undefined) view.setUint32(48, Number(data.cCertStore), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.arrayCertStore !== undefined) view.setBigUint64(56, data.arrayCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayCertStore))), true);
  // 0x40: buffer
  if (data?.szPurposeOid !== undefined) {
    (buf as any)._f64 = util.pstrToFfi(data.szPurposeOid);
    view.setBigUint64(64, (buf as any)._f64 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f64))), true);
  }
  // 0x48: u32
  if (data?.cCertContext !== undefined) view.setUint32(72, Number(data.cCertContext), true);
  // 0x4c: pad4
  // 0x50: pointer
  if (data?.arrayCertContext !== undefined) view.setBigUint64(80, data.arrayCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayCertContext))), true);
  // 0x58: pointer
  if (data?.lCustData !== undefined) view.setBigUint64(88, data.lCustData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.lCustData))), true);
  // 0x60: pointer
  if (data?.pfnHook !== undefined) view.setBigUint64(96, data.pfnHook === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnHook))), true);
  // 0x68: pointer
  if (data?.pfnFilter !== undefined) view.setBigUint64(104, data.pfnFilter === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnFilter))), true);
  // 0x70: buffer
  if (data?.szHelpFileName !== undefined) {
    (buf as any)._f112 = util.pwstrToFfi(data.szHelpFileName);
    view.setBigUint64(112, (buf as any)._f112 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f112))), true);
  }
  // 0x78: u32
  if (data?.dwHelpId !== undefined) view.setUint32(120, Number(data.dwHelpId), true);
  // 0x7c: pad4
  // 0x80: usize
  if (data?.hprov !== undefined) view.setBigUint64(128, BigInt(data.hprov), true);
  return buf;
}

export class CERT_SELECT_STRUCT_WView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hwndParent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hInstance(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get pTemplateName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get dwFlags(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: buffer
  get szTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cCertStore(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get arrayCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: buffer
  get szPurposeOid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: u32
  get cCertContext(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  get arrayCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x58: pointer
  get lCustData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x60: pointer
  get pfnHook(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(96, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x68: pointer
  get pfnFilter(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(104, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x70: buffer
  get szHelpFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(112, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x78: u32
  get dwHelpId(): number {
    return this.view.getUint32(120, true);
  }

  // 0x7c: pad4

  // 0x80: usize
  get hprov(): Deno.PointerValue {
    return Number(this.view.getBigUint64(128, true));
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hwndParent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hInstance(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: buffer
  set pTemplateName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: u32
  set dwFlags(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: buffer
  set szTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f40 = value;
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f40))), true);
  }

  // 0x30: u32
  set cCertStore(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set arrayCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: buffer
  set szPurposeOid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f64 = value;
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f64))), true);
  }

  // 0x48: u32
  set cCertContext(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  set arrayCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x58: pointer
  set lCustData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x60: pointer
  set pfnHook(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(96, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x68: pointer
  set pfnFilter(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x70: buffer
  set szHelpFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f112 = value;
    this.view.setBigUint64(112, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f112))), true);
  }

  // 0x78: u32
  set dwHelpId(value: number) {
    this.view.setUint32(120, value, true);
  }

  // 0x7c: pad4

  // 0x80: usize
  set hprov(value: Deno.PointerValue) {
    this.view.setBigUint64(128, BigInt(value), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_VIEWPROPERTIES_STRUCT_A (size: 160)
 */
export interface CERT_VIEWPROPERTIES_STRUCT_A {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.HWND */
  hwndParent: Deno.PointerValue;
  /** Windows.Win32.Foundation.HINSTANCE */
  hInstance: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.CERT_VIEWPROPERTIES_STRUCT_FLAGS */
  dwFlags: CERT_VIEWPROPERTIES_STRUCT_FLAGS;
  /** Windows.Win32.Foundation.PSTR */
  szTitle: string | null | Uint8Array;
  /** ptr */
  pCertContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  arrayPurposes: Deno.PointerValue | Uint8Array;
  /** u32 */
  cArrayPurposes: number;
  /** u32 */
  cRootStores: number;
  /** ptr */
  rghstoreRoots: Deno.PointerValue | Uint8Array;
  /** u32 */
  cStores: number;
  /** ptr */
  rghstoreCAs: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTrustStores: number;
  /** ptr */
  rghstoreTrust: Deno.PointerValue | Uint8Array;
  /** usize */
  hprov: Deno.PointerValue;
  /** Windows.Win32.Foundation.LPARAM */
  lCustData: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwPad: number;
  /** Windows.Win32.Foundation.PSTR */
  szHelpFileName: string | null | Uint8Array;
  /** u32 */
  dwHelpId: number;
  /** u32 */
  nStartPage: number;
  /** u32 */
  cArrayPropSheetPages: number;
  /** ptr */
  arrayPropSheetPages: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_VIEWPROPERTIES_STRUCT_A = 160;

export function allocCERT_VIEWPROPERTIES_STRUCT_A(data?: Partial<CERT_VIEWPROPERTIES_STRUCT_A>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_VIEWPROPERTIES_STRUCT_A);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hwndParent !== undefined) view.setBigUint64(8, data.hwndParent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndParent))), true);
  // 0x10: pointer
  if (data?.hInstance !== undefined) view.setBigUint64(16, data.hInstance === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hInstance))), true);
  // 0x18: u32
  if (data?.dwFlags !== undefined) view.setUint32(24, Number(data.dwFlags), true);
  // 0x1c: pad4
  // 0x20: buffer
  if (data?.szTitle !== undefined) {
    (buf as any)._f32 = util.pstrToFfi(data.szTitle);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: pointer
  if (data?.pCertContext !== undefined) view.setBigUint64(40, data.pCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertContext))), true);
  // 0x30: pointer
  if (data?.arrayPurposes !== undefined) view.setBigUint64(48, data.arrayPurposes === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayPurposes))), true);
  // 0x38: u32
  if (data?.cArrayPurposes !== undefined) view.setUint32(56, Number(data.cArrayPurposes), true);
  // 0x3c: u32
  if (data?.cRootStores !== undefined) view.setUint32(60, Number(data.cRootStores), true);
  // 0x40: pointer
  if (data?.rghstoreRoots !== undefined) view.setBigUint64(64, data.rghstoreRoots === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreRoots))), true);
  // 0x48: u32
  if (data?.cStores !== undefined) view.setUint32(72, Number(data.cStores), true);
  // 0x4c: pad4
  // 0x50: pointer
  if (data?.rghstoreCAs !== undefined) view.setBigUint64(80, data.rghstoreCAs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreCAs))), true);
  // 0x58: u32
  if (data?.cTrustStores !== undefined) view.setUint32(88, Number(data.cTrustStores), true);
  // 0x5c: pad4
  // 0x60: pointer
  if (data?.rghstoreTrust !== undefined) view.setBigUint64(96, data.rghstoreTrust === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreTrust))), true);
  // 0x68: usize
  if (data?.hprov !== undefined) view.setBigUint64(104, BigInt(data.hprov), true);
  // 0x70: pointer
  if (data?.lCustData !== undefined) view.setBigUint64(112, data.lCustData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.lCustData))), true);
  // 0x78: u32
  if (data?.dwPad !== undefined) view.setUint32(120, Number(data.dwPad), true);
  // 0x7c: pad4
  // 0x80: buffer
  if (data?.szHelpFileName !== undefined) {
    (buf as any)._f128 = util.pstrToFfi(data.szHelpFileName);
    view.setBigUint64(128, (buf as any)._f128 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f128))), true);
  }
  // 0x88: u32
  if (data?.dwHelpId !== undefined) view.setUint32(136, Number(data.dwHelpId), true);
  // 0x8c: u32
  if (data?.nStartPage !== undefined) view.setUint32(140, Number(data.nStartPage), true);
  // 0x90: u32
  if (data?.cArrayPropSheetPages !== undefined) view.setUint32(144, Number(data.cArrayPropSheetPages), true);
  // 0x94: pad4
  // 0x98: pointer
  if (data?.arrayPropSheetPages !== undefined) view.setBigUint64(152, data.arrayPropSheetPages === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayPropSheetPages))), true);
  return buf;
}

export class CERT_VIEWPROPERTIES_STRUCT_AView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hwndParent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hInstance(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwFlags(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  get szTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get arrayPurposes(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: u32
  get cArrayPurposes(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: u32
  get cRootStores(): number {
    return this.view.getUint32(60, true);
  }

  // 0x40: pointer
  get rghstoreRoots(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: u32
  get cStores(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  get rghstoreCAs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x58: u32
  get cTrustStores(): number {
    return this.view.getUint32(88, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  get rghstoreTrust(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(96, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x68: usize
  get hprov(): Deno.PointerValue {
    return Number(this.view.getBigUint64(104, true));
  }

  // 0x70: pointer
  get lCustData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(112, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x78: u32
  get dwPad(): number {
    return this.view.getUint32(120, true);
  }

  // 0x7c: pad4

  // 0x80: buffer
  get szHelpFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(128, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x88: u32
  get dwHelpId(): number {
    return this.view.getUint32(136, true);
  }

  // 0x8c: u32
  get nStartPage(): number {
    return this.view.getUint32(140, true);
  }

  // 0x90: u32
  get cArrayPropSheetPages(): number {
    return this.view.getUint32(144, true);
  }

  // 0x94: pad4

  // 0x98: pointer
  get arrayPropSheetPages(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(152, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hwndParent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hInstance(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwFlags(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  set szTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: pointer
  set pCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set arrayPurposes(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: u32
  set cArrayPurposes(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: u32
  set cRootStores(value: number) {
    this.view.setUint32(60, value, true);
  }

  // 0x40: pointer
  set rghstoreRoots(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: u32
  set cStores(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  set rghstoreCAs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x58: u32
  set cTrustStores(value: number) {
    this.view.setUint32(88, value, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  set rghstoreTrust(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(96, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x68: usize
  set hprov(value: Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(value), true);
  }

  // 0x70: pointer
  set lCustData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(112, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x78: u32
  set dwPad(value: number) {
    this.view.setUint32(120, value, true);
  }

  // 0x7c: pad4

  // 0x80: buffer
  set szHelpFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f128 = value;
    this.view.setBigUint64(128, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f128))), true);
  }

  // 0x88: u32
  set dwHelpId(value: number) {
    this.view.setUint32(136, value, true);
  }

  // 0x8c: u32
  set nStartPage(value: number) {
    this.view.setUint32(140, value, true);
  }

  // 0x90: u32
  set cArrayPropSheetPages(value: number) {
    this.view.setUint32(144, value, true);
  }

  // 0x94: pad4

  // 0x98: pointer
  set arrayPropSheetPages(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(152, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_VIEWPROPERTIES_STRUCT_W (size: 160)
 */
export interface CERT_VIEWPROPERTIES_STRUCT_W {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.HWND */
  hwndParent: Deno.PointerValue;
  /** Windows.Win32.Foundation.HINSTANCE */
  hInstance: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.CERT_VIEWPROPERTIES_STRUCT_FLAGS */
  dwFlags: CERT_VIEWPROPERTIES_STRUCT_FLAGS;
  /** Windows.Win32.Foundation.PWSTR */
  szTitle: string | null | Uint8Array | Uint16Array;
  /** ptr */
  pCertContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  arrayPurposes: Deno.PointerValue | Uint8Array;
  /** u32 */
  cArrayPurposes: number;
  /** u32 */
  cRootStores: number;
  /** ptr */
  rghstoreRoots: Deno.PointerValue | Uint8Array;
  /** u32 */
  cStores: number;
  /** ptr */
  rghstoreCAs: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTrustStores: number;
  /** ptr */
  rghstoreTrust: Deno.PointerValue | Uint8Array;
  /** usize */
  hprov: Deno.PointerValue;
  /** Windows.Win32.Foundation.LPARAM */
  lCustData: Uint8Array | Deno.PointerValue;
  /** u32 */
  dwPad: number;
  /** Windows.Win32.Foundation.PWSTR */
  szHelpFileName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwHelpId: number;
  /** u32 */
  nStartPage: number;
  /** u32 */
  cArrayPropSheetPages: number;
  /** ptr */
  arrayPropSheetPages: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_VIEWPROPERTIES_STRUCT_W = 160;

export function allocCERT_VIEWPROPERTIES_STRUCT_W(data?: Partial<CERT_VIEWPROPERTIES_STRUCT_W>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_VIEWPROPERTIES_STRUCT_W);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hwndParent !== undefined) view.setBigUint64(8, data.hwndParent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndParent))), true);
  // 0x10: pointer
  if (data?.hInstance !== undefined) view.setBigUint64(16, data.hInstance === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hInstance))), true);
  // 0x18: u32
  if (data?.dwFlags !== undefined) view.setUint32(24, Number(data.dwFlags), true);
  // 0x1c: pad4
  // 0x20: buffer
  if (data?.szTitle !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.szTitle);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: pointer
  if (data?.pCertContext !== undefined) view.setBigUint64(40, data.pCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertContext))), true);
  // 0x30: pointer
  if (data?.arrayPurposes !== undefined) view.setBigUint64(48, data.arrayPurposes === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayPurposes))), true);
  // 0x38: u32
  if (data?.cArrayPurposes !== undefined) view.setUint32(56, Number(data.cArrayPurposes), true);
  // 0x3c: u32
  if (data?.cRootStores !== undefined) view.setUint32(60, Number(data.cRootStores), true);
  // 0x40: pointer
  if (data?.rghstoreRoots !== undefined) view.setBigUint64(64, data.rghstoreRoots === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreRoots))), true);
  // 0x48: u32
  if (data?.cStores !== undefined) view.setUint32(72, Number(data.cStores), true);
  // 0x4c: pad4
  // 0x50: pointer
  if (data?.rghstoreCAs !== undefined) view.setBigUint64(80, data.rghstoreCAs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreCAs))), true);
  // 0x58: u32
  if (data?.cTrustStores !== undefined) view.setUint32(88, Number(data.cTrustStores), true);
  // 0x5c: pad4
  // 0x60: pointer
  if (data?.rghstoreTrust !== undefined) view.setBigUint64(96, data.rghstoreTrust === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreTrust))), true);
  // 0x68: usize
  if (data?.hprov !== undefined) view.setBigUint64(104, BigInt(data.hprov), true);
  // 0x70: pointer
  if (data?.lCustData !== undefined) view.setBigUint64(112, data.lCustData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.lCustData))), true);
  // 0x78: u32
  if (data?.dwPad !== undefined) view.setUint32(120, Number(data.dwPad), true);
  // 0x7c: pad4
  // 0x80: buffer
  if (data?.szHelpFileName !== undefined) {
    (buf as any)._f128 = util.pwstrToFfi(data.szHelpFileName);
    view.setBigUint64(128, (buf as any)._f128 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f128))), true);
  }
  // 0x88: u32
  if (data?.dwHelpId !== undefined) view.setUint32(136, Number(data.dwHelpId), true);
  // 0x8c: u32
  if (data?.nStartPage !== undefined) view.setUint32(140, Number(data.nStartPage), true);
  // 0x90: u32
  if (data?.cArrayPropSheetPages !== undefined) view.setUint32(144, Number(data.cArrayPropSheetPages), true);
  // 0x94: pad4
  // 0x98: pointer
  if (data?.arrayPropSheetPages !== undefined) view.setBigUint64(152, data.arrayPropSheetPages === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayPropSheetPages))), true);
  return buf;
}

export class CERT_VIEWPROPERTIES_STRUCT_WView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hwndParent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get hInstance(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwFlags(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  get szTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get pCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get arrayPurposes(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: u32
  get cArrayPurposes(): number {
    return this.view.getUint32(56, true);
  }

  // 0x3c: u32
  get cRootStores(): number {
    return this.view.getUint32(60, true);
  }

  // 0x40: pointer
  get rghstoreRoots(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(64, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x48: u32
  get cStores(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  get rghstoreCAs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(80, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x58: u32
  get cTrustStores(): number {
    return this.view.getUint32(88, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  get rghstoreTrust(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(96, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x68: usize
  get hprov(): Deno.PointerValue {
    return Number(this.view.getBigUint64(104, true));
  }

  // 0x70: pointer
  get lCustData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(112, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x78: u32
  get dwPad(): number {
    return this.view.getUint32(120, true);
  }

  // 0x7c: pad4

  // 0x80: buffer
  get szHelpFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(128, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x88: u32
  get dwHelpId(): number {
    return this.view.getUint32(136, true);
  }

  // 0x8c: u32
  get nStartPage(): number {
    return this.view.getUint32(140, true);
  }

  // 0x90: u32
  get cArrayPropSheetPages(): number {
    return this.view.getUint32(144, true);
  }

  // 0x94: pad4

  // 0x98: pointer
  get arrayPropSheetPages(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(152, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hwndParent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set hInstance(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set dwFlags(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4

  // 0x20: buffer
  set szTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: pointer
  set pCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set arrayPurposes(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: u32
  set cArrayPurposes(value: number) {
    this.view.setUint32(56, value, true);
  }

  // 0x3c: u32
  set cRootStores(value: number) {
    this.view.setUint32(60, value, true);
  }

  // 0x40: pointer
  set rghstoreRoots(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(64, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x48: u32
  set cStores(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: pad4

  // 0x50: pointer
  set rghstoreCAs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(80, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x58: u32
  set cTrustStores(value: number) {
    this.view.setUint32(88, value, true);
  }

  // 0x5c: pad4

  // 0x60: pointer
  set rghstoreTrust(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(96, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x68: usize
  set hprov(value: Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(value), true);
  }

  // 0x70: pointer
  set lCustData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(112, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x78: u32
  set dwPad(value: number) {
    this.view.setUint32(120, value, true);
  }

  // 0x7c: pad4

  // 0x80: buffer
  set szHelpFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f128 = value;
    this.view.setBigUint64(128, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f128))), true);
  }

  // 0x88: u32
  set dwHelpId(value: number) {
    this.view.setUint32(136, value, true);
  }

  // 0x8c: u32
  set nStartPage(value: number) {
    this.view.setUint32(140, value, true);
  }

  // 0x90: u32
  set cArrayPropSheetPages(value: number) {
    this.view.setUint32(144, value, true);
  }

  // 0x94: pad4

  // 0x98: pointer
  set arrayPropSheetPages(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(152, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_FILTER_EXTENSION_MATCH (size: 32)
 */
export interface CERT_FILTER_EXTENSION_MATCH {
  /** Windows.Win32.Foundation.PSTR */
  szExtensionOID: string | null | Uint8Array;
  /** u32 */
  dwTestOperation: number;
  /** ptr */
  pbTestData: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbTestData: number;
}

export const sizeofCERT_FILTER_EXTENSION_MATCH = 32;

export function allocCERT_FILTER_EXTENSION_MATCH(data?: Partial<CERT_FILTER_EXTENSION_MATCH>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_FILTER_EXTENSION_MATCH);
  const view = new DataView(buf.buffer);
  // 0x00: buffer
  if (data?.szExtensionOID !== undefined) {
    (buf as any)._f0 = util.pstrToFfi(data.szExtensionOID);
    view.setBigUint64(0, (buf as any)._f0 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f0))), true);
  }
  // 0x08: u32
  if (data?.dwTestOperation !== undefined) view.setUint32(8, Number(data.dwTestOperation), true);
  // 0x0c: pad4
  // 0x10: pointer
  if (data?.pbTestData !== undefined) view.setBigUint64(16, data.pbTestData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbTestData))), true);
  // 0x18: u32
  if (data?.cbTestData !== undefined) view.setUint32(24, Number(data.cbTestData), true);
  // 0x1c: pad4
  return buf;
}

export class CERT_FILTER_EXTENSION_MATCHView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: buffer
  get szExtensionOID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwTestOperation(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  get pbTestData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get cbTestData(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: buffer
  set szExtensionOID(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f0 = value;
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f0))), true);
  }

  // 0x08: u32
  set dwTestOperation(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: pad4

  // 0x10: pointer
  set pbTestData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: u32
  set cbTestData(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_FILTER_DATA (size: 24)
 */
export interface CERT_FILTER_DATA {
  /** u32 */
  dwSize: number;
  /** u32 */
  cExtensionChecks: number;
  /** ptr */
  arrayExtensionChecks: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwCheckingFlags: number;
}

export const sizeofCERT_FILTER_DATA = 24;

export function allocCERT_FILTER_DATA(data?: Partial<CERT_FILTER_DATA>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_FILTER_DATA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: u32
  if (data?.cExtensionChecks !== undefined) view.setUint32(4, Number(data.cExtensionChecks), true);
  // 0x08: pointer
  if (data?.arrayExtensionChecks !== undefined) view.setBigUint64(8, data.arrayExtensionChecks === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.arrayExtensionChecks))), true);
  // 0x10: u32
  if (data?.dwCheckingFlags !== undefined) view.setUint32(16, Number(data.dwCheckingFlags), true);
  // 0x14: pad4
  return buf;
}

export class CERT_FILTER_DATAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cExtensionChecks(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get arrayExtensionChecks(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwCheckingFlags(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cExtensionChecks(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set arrayExtensionChecks(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwCheckingFlags(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_VERIFY_CERTIFICATE_TRUST (size: 144)
 */
export interface CERT_VERIFY_CERTIFICATE_TRUST {
  /** u32 */
  cbSize: number;
  /** ptr */
  pccert: Deno.PointerValue | Uint8Array;
  /** u32 */
  dwFlags: number;
  /** u32 */
  dwIgnoreErr: number;
  /** ptr */
  pdwErrors: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PSTR */
  pszUsageOid: string | null | Uint8Array;
  /** usize */
  hprov: Deno.PointerValue;
  /** u32 */
  cRootStores: number;
  /** ptr */
  rghstoreRoots: Deno.PointerValue | Uint8Array;
  /** u32 */
  cStores: number;
  /** ptr */
  rghstoreCAs: Deno.PointerValue | Uint8Array;
  /** u32 */
  cTrustStores: number;
  /** ptr */
  rghstoreTrust: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.LPARAM */
  lCustData: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.PFNTRUSTHELPER */
  pfnTrustHelper: Uint8Array | Deno.PointerValue;
  /** ptr */
  pcChain: Deno.PointerValue | Uint8Array;
  /** ptr */
  prgChain: Deno.PointerValue | Uint8Array;
  /** ptr */
  prgdwErrors: Deno.PointerValue | Uint8Array;
  /** ptr */
  prgpbTrustInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCERT_VERIFY_CERTIFICATE_TRUST = 144;

export function allocCERT_VERIFY_CERTIFICATE_TRUST(data?: Partial<CERT_VERIFY_CERTIFICATE_TRUST>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_VERIFY_CERTIFICATE_TRUST);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.cbSize !== undefined) view.setUint32(0, Number(data.cbSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pccert !== undefined) view.setBigUint64(8, data.pccert === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pccert))), true);
  // 0x10: u32
  if (data?.dwFlags !== undefined) view.setUint32(16, Number(data.dwFlags), true);
  // 0x14: u32
  if (data?.dwIgnoreErr !== undefined) view.setUint32(20, Number(data.dwIgnoreErr), true);
  // 0x18: pointer
  if (data?.pdwErrors !== undefined) view.setBigUint64(24, data.pdwErrors === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pdwErrors))), true);
  // 0x20: buffer
  if (data?.pszUsageOid !== undefined) {
    (buf as any)._f32 = util.pstrToFfi(data.pszUsageOid);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: usize
  if (data?.hprov !== undefined) view.setBigUint64(40, BigInt(data.hprov), true);
  // 0x30: u32
  if (data?.cRootStores !== undefined) view.setUint32(48, Number(data.cRootStores), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.rghstoreRoots !== undefined) view.setBigUint64(56, data.rghstoreRoots === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreRoots))), true);
  // 0x40: u32
  if (data?.cStores !== undefined) view.setUint32(64, Number(data.cStores), true);
  // 0x44: pad4
  // 0x48: pointer
  if (data?.rghstoreCAs !== undefined) view.setBigUint64(72, data.rghstoreCAs === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreCAs))), true);
  // 0x50: u32
  if (data?.cTrustStores !== undefined) view.setUint32(80, Number(data.cTrustStores), true);
  // 0x54: pad4
  // 0x58: pointer
  if (data?.rghstoreTrust !== undefined) view.setBigUint64(88, data.rghstoreTrust === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghstoreTrust))), true);
  // 0x60: pointer
  if (data?.lCustData !== undefined) view.setBigUint64(96, data.lCustData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.lCustData))), true);
  // 0x68: pointer
  if (data?.pfnTrustHelper !== undefined) view.setBigUint64(104, data.pfnTrustHelper === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pfnTrustHelper))), true);
  // 0x70: pointer
  if (data?.pcChain !== undefined) view.setBigUint64(112, data.pcChain === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pcChain))), true);
  // 0x78: pointer
  if (data?.prgChain !== undefined) view.setBigUint64(120, data.prgChain === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.prgChain))), true);
  // 0x80: pointer
  if (data?.prgdwErrors !== undefined) view.setBigUint64(128, data.prgdwErrors === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.prgdwErrors))), true);
  // 0x88: pointer
  if (data?.prgpbTrustInfo !== undefined) view.setBigUint64(136, data.prgpbTrustInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.prgpbTrustInfo))), true);
  return buf;
}

export class CERT_VERIFY_CERTIFICATE_TRUSTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get cbSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pccert(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwFlags(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get dwIgnoreErr(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get pdwErrors(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pszUsageOid(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: usize
  get hprov(): Deno.PointerValue {
    return Number(this.view.getBigUint64(40, true));
  }

  // 0x30: u32
  get cRootStores(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get rghstoreRoots(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: u32
  get cStores(): number {
    return this.view.getUint32(64, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  get rghstoreCAs(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(72, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x50: u32
  get cTrustStores(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  get rghstoreTrust(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x60: pointer
  get lCustData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(96, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x68: pointer
  get pfnTrustHelper(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(104, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x70: pointer
  get pcChain(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(112, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x78: pointer
  get prgChain(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(120, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x80: pointer
  get prgdwErrors(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(128, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x88: pointer
  get prgpbTrustInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(136, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set cbSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pccert(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwFlags(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set dwIgnoreErr(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set pdwErrors(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: buffer
  set pszUsageOid(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: usize
  set hprov(value: Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(value), true);
  }

  // 0x30: u32
  set cRootStores(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set rghstoreRoots(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: u32
  set cStores(value: number) {
    this.view.setUint32(64, value, true);
  }

  // 0x44: pad4

  // 0x48: pointer
  set rghstoreCAs(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(72, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x50: u32
  set cTrustStores(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: pad4

  // 0x58: pointer
  set rghstoreTrust(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x60: pointer
  set lCustData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(96, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x68: pointer
  set pfnTrustHelper(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x70: pointer
  set pcChain(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(112, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x78: pointer
  set prgChain(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(120, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x80: pointer
  set prgdwErrors(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(128, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x88: pointer
  set prgpbTrustInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(136, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CTL_MODIFY_REQUEST (size: 16)
 */
export interface CTL_MODIFY_REQUEST {
  /** ptr */
  pccert: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.UI.CTL_MODIFY_REQUEST_OPERATION */
  dwOperation: CTL_MODIFY_REQUEST_OPERATION;
  /** u32 */
  dwError: number;
}

export const sizeofCTL_MODIFY_REQUEST = 16;

export function allocCTL_MODIFY_REQUEST(data?: Partial<CTL_MODIFY_REQUEST>): Uint8Array {
  const buf = new Uint8Array(sizeofCTL_MODIFY_REQUEST);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.pccert !== undefined) view.setBigUint64(0, data.pccert === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pccert))), true);
  // 0x08: u32
  if (data?.dwOperation !== undefined) view.setUint32(8, Number(data.dwOperation), true);
  // 0x0c: u32
  if (data?.dwError !== undefined) view.setUint32(12, Number(data.dwError), true);
  return buf;
}

export class CTL_MODIFY_REQUESTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get pccert(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: u32
  get dwOperation(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get dwError(): number {
    return this.view.getUint32(12, true);
  }

  // 0x00: pointer
  set pccert(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: u32
  set dwOperation(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set dwError(value: number) {
    this.view.setUint32(12, value, true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CERT_SELECTUI_INPUT (size: 24)
 */
export interface CERT_SELECTUI_INPUT {
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hStore: Uint8Array | Deno.PointerValue;
  /** ptr */
  prgpChain: Deno.PointerValue | Uint8Array;
  /** u32 */
  cChain: number;
}

export const sizeofCERT_SELECTUI_INPUT = 24;

export function allocCERT_SELECTUI_INPUT(data?: Partial<CERT_SELECTUI_INPUT>): Uint8Array {
  const buf = new Uint8Array(sizeofCERT_SELECTUI_INPUT);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.hStore !== undefined) view.setBigUint64(0, data.hStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hStore))), true);
  // 0x08: pointer
  if (data?.prgpChain !== undefined) view.setBigUint64(8, data.prgpChain === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.prgpChain))), true);
  // 0x10: u32
  if (data?.cChain !== undefined) view.setUint32(16, Number(data.cChain), true);
  // 0x14: pad4
  return buf;
}

export class CERT_SELECTUI_INPUTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get hStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get prgpChain(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cChain(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x00: pointer
  set hStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set prgpChain(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cChain(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_CERT_MGR_STRUCT (size: 40)
 */
export interface CRYPTUI_CERT_MGR_STRUCT {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.HWND */
  hwndParent: Deno.PointerValue;
  /** u32 */
  dwFlags: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszTitle: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PSTR */
  pszInitUsageOID: string | null | Uint8Array;
}

export const sizeofCRYPTUI_CERT_MGR_STRUCT = 40;

export function allocCRYPTUI_CERT_MGR_STRUCT(data?: Partial<CRYPTUI_CERT_MGR_STRUCT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_CERT_MGR_STRUCT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hwndParent !== undefined) view.setBigUint64(8, data.hwndParent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndParent))), true);
  // 0x10: u32
  if (data?.dwFlags !== undefined) view.setUint32(16, Number(data.dwFlags), true);
  // 0x14: pad4
  // 0x18: buffer
  if (data?.pwszTitle !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.pwszTitle);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: buffer
  if (data?.pszInitUsageOID !== undefined) {
    (buf as any)._f32 = util.pstrToFfi(data.pszInitUsageOID);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  return buf;
}

export class CRYPTUI_CERT_MGR_STRUCTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hwndParent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwFlags(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  get pwszTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pszInitUsageOID(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hwndParent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwFlags(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  set pwszTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: buffer
  set pszInitUsageOID(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO (size: 40)
 */
export interface CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO {
  /** u32 */
  dwSize: number;
  /** ptr */
  pGuidSubject: Deno.PointerValue | Uint8Array;
  /** u32 */
  cbBlob: number;
  /** ptr */
  pbBlob: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszDisplayName: string | null | Uint8Array | Uint16Array;
}

export const sizeofCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO = 40;

export function allocCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO(data?: Partial<CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.pGuidSubject !== undefined) view.setBigUint64(8, data.pGuidSubject === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pGuidSubject))), true);
  // 0x10: u32
  if (data?.cbBlob !== undefined) view.setUint32(16, Number(data.cbBlob), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.pbBlob !== undefined) view.setBigUint64(24, data.pbBlob === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbBlob))), true);
  // 0x20: buffer
  if (data?.pwszDisplayName !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.pwszDisplayName);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  return buf;
}

export class CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get pGuidSubject(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get cbBlob(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get pbBlob(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pwszDisplayName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set pGuidSubject(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set cbBlob(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set pbBlob(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: buffer
  set pwszDisplayName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO (size: 32)
 */
export interface CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO {
  /** u32 */
  dwSize: number;
  /** u32 */
  cCertStore: number;
  /** ptr */
  rghCertStore: Deno.PointerValue | Uint8Array;
  /** Windows.Win32.Security.Cryptography.UI.PFNCFILTERPROC */
  pFilterCallback: Uint8Array | Deno.PointerValue;
  /** ptr */
  pvCallbackData: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO = 32;

export function allocCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO(data?: Partial<CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: u32
  if (data?.cCertStore !== undefined) view.setUint32(4, Number(data.cCertStore), true);
  // 0x08: pointer
  if (data?.rghCertStore !== undefined) view.setBigUint64(8, data.rghCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghCertStore))), true);
  // 0x10: pointer
  if (data?.pFilterCallback !== undefined) view.setBigUint64(16, data.pFilterCallback === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pFilterCallback))), true);
  // 0x18: pointer
  if (data?.pvCallbackData !== undefined) view.setBigUint64(24, data.pvCallbackData === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pvCallbackData))), true);
  return buf;
}

export class CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cCertStore(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get rghCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: pointer
  get pFilterCallback(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: pointer
  get pvCallbackData(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cCertStore(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set rghCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: pointer
  set pFilterCallback(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x18: pointer
  set pvCallbackData(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO (size: 32)
 */
export interface CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszPvkFileName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszProvName: string | null | Uint8Array | Uint16Array;
  /** u32 */
  dwProvType: number;
}

export const sizeofCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO = 32;

export function allocCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO(data?: Partial<CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pwszPvkFileName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszPvkFileName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pwszProvName !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszProvName);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: u32
  if (data?.dwProvType !== undefined) view.setUint32(24, Number(data.dwProvType), true);
  // 0x1c: pad4
  return buf;
}

export class CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pwszPvkFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszProvName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: u32
  get dwProvType(): number {
    return this.view.getUint32(24, true);
  }

  // 0x1c: pad4

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pwszPvkFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pwszProvName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: u32
  set dwProvType(value: number) {
    this.view.setUint32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO (size: 32)
 */
export interface CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszSigningCertFileName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_PVK_OPTION */
  dwPvkChoice: CRYPTUI_WIZ_DIGITAL_SIGN_PVK_OPTION;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
}

export const sizeofCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO = 32;

export function allocCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO(data?: Partial<CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pwszSigningCertFileName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszSigningCertFileName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.dwPvkChoice !== undefined) view.setUint32(16, Number(data.dwPvkChoice), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(24, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  return buf;
}

export class CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pwszSigningCertFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwPvkChoice(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pwszSigningCertFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set dwPvkChoice(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO (size: 64)
 */
export interface CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_SIG_TYPE */
  dwAttrFlags: CRYPTUI_WIZ_DIGITAL_SIGN_SIG_TYPE;
  /** Windows.Win32.Foundation.PWSTR */
  pwszDescription: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszMoreInfoLocation: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.PSTR */
  pszHashAlg: string | null | Uint8Array;
  /** Windows.Win32.Foundation.PWSTR */
  pwszSigningCertDisplayString: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.HCERTSTORE */
  hAdditionalCertStore: Uint8Array | Deno.PointerValue;
  /** ptr */
  psAuthenticated: Deno.PointerValue | Uint8Array;
  /** ptr */
  psUnauthenticated: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO = 64;

export function allocCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO(data?: Partial<CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: u32
  if (data?.dwAttrFlags !== undefined) view.setUint32(4, Number(data.dwAttrFlags), true);
  // 0x08: buffer
  if (data?.pwszDescription !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszDescription);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: buffer
  if (data?.pwszMoreInfoLocation !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszMoreInfoLocation);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: buffer
  if (data?.pszHashAlg !== undefined) {
    (buf as any)._f24 = util.pstrToFfi(data.pszHashAlg);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: buffer
  if (data?.pwszSigningCertDisplayString !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.pwszSigningCertDisplayString);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: pointer
  if (data?.hAdditionalCertStore !== undefined) view.setBigUint64(40, data.hAdditionalCertStore === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hAdditionalCertStore))), true);
  // 0x30: pointer
  if (data?.psAuthenticated !== undefined) view.setBigUint64(48, data.psAuthenticated === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.psAuthenticated))), true);
  // 0x38: pointer
  if (data?.psUnauthenticated !== undefined) view.setBigUint64(56, data.psUnauthenticated === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.psUnauthenticated))), true);
  return buf;
}

export class CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwAttrFlags(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: buffer
  get pwszDescription(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: buffer
  get pwszMoreInfoLocation(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: buffer
  get pszHashAlg(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pwszSigningCertDisplayString(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get hAdditionalCertStore(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: pointer
  get psAuthenticated(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x38: pointer
  get psUnauthenticated(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwAttrFlags(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: buffer
  set pwszDescription(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: buffer
  set pwszMoreInfoLocation(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: buffer
  set pszHashAlg(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: buffer
  set pwszSigningCertDisplayString(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: pointer
  set hAdditionalCertStore(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: pointer
  set psAuthenticated(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x38: pointer
  set psUnauthenticated(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_INFO (size: 56)
 */
export interface CRYPTUI_WIZ_DIGITAL_SIGN_INFO {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT */
  dwSubjectChoice: CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT;
  /** _Anonymous1_e__Union */
  Anonymous1: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN */
  dwSigningCertChoice: CRYPTUI_WIZ_DIGITAL_SIGN;
  /** _Anonymous2_e__Union */
  Anonymous2: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.PWSTR */
  pwszTimestampURL: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_ADDITIONAL_CERT_CHOICE */
  dwAdditionalCertChoice: CRYPTUI_WIZ_DIGITAL_ADDITIONAL_CERT_CHOICE;
  /** ptr */
  pSignExtInfo: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPTUI_WIZ_DIGITAL_SIGN_INFO = 56;

export function allocCRYPTUI_WIZ_DIGITAL_SIGN_INFO(data?: Partial<CRYPTUI_WIZ_DIGITAL_SIGN_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_DIGITAL_SIGN_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: u32
  if (data?.dwSubjectChoice !== undefined) view.setUint32(4, Number(data.dwSubjectChoice), true);
  // 0x08: pointer
  if (data?.Anonymous1 !== undefined) view.setBigUint64(8, data.Anonymous1 === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous1))), true);
  // 0x10: u32
  if (data?.dwSigningCertChoice !== undefined) view.setUint32(16, Number(data.dwSigningCertChoice), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Anonymous2 !== undefined) view.setBigUint64(24, data.Anonymous2 === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous2))), true);
  // 0x20: buffer
  if (data?.pwszTimestampURL !== undefined) {
    (buf as any)._f32 = util.pwstrToFfi(data.pwszTimestampURL);
    view.setBigUint64(32, (buf as any)._f32 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f32))), true);
  }
  // 0x28: u32
  if (data?.dwAdditionalCertChoice !== undefined) view.setUint32(40, Number(data.dwAdditionalCertChoice), true);
  // 0x2c: pad4
  // 0x30: pointer
  if (data?.pSignExtInfo !== undefined) view.setBigUint64(48, data.pSignExtInfo === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pSignExtInfo))), true);
  return buf;
}

export class CRYPTUI_WIZ_DIGITAL_SIGN_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwSubjectChoice(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get Anonymous1(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwSigningCertChoice(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Anonymous2(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: buffer
  get pwszTimestampURL(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: u32
  get dwAdditionalCertChoice(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  get pSignExtInfo(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(48, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwSubjectChoice(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set Anonymous1(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwSigningCertChoice(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Anonymous2(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: buffer
  set pwszTimestampURL(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f32 = value;
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f32))), true);
  }

  // 0x28: u32
  set dwAdditionalCertChoice(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: pad4

  // 0x30: pointer
  set pSignExtInfo(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(48, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT (size: 16)
 */
export interface CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT {
  /** u32 */
  dwSize: number;
  /** u32 */
  cbBlob: number;
  /** ptr */
  pbBlob: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT = 16;

export function allocCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT(data?: Partial<CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: u32
  if (data?.cbBlob !== undefined) view.setUint32(4, Number(data.cbBlob), true);
  // 0x08: pointer
  if (data?.pbBlob !== undefined) view.setBigUint64(8, data.pbBlob === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pbBlob))), true);
  return buf;
}

export class CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get cbBlob(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get pbBlob(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set cbBlob(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set pbBlob(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_INITDIALOG_STRUCT (size: 16)
 */
export interface CRYPTUI_INITDIALOG_STRUCT {
  /** Windows.Win32.Foundation.LPARAM */
  lParam: Uint8Array | Deno.PointerValue;
  /** ptr */
  pCertContext: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPTUI_INITDIALOG_STRUCT = 16;

export function allocCRYPTUI_INITDIALOG_STRUCT(data?: Partial<CRYPTUI_INITDIALOG_STRUCT>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_INITDIALOG_STRUCT);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.lParam !== undefined) view.setBigUint64(0, data.lParam === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.lParam))), true);
  // 0x08: pointer
  if (data?.pCertContext !== undefined) view.setBigUint64(8, data.pCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertContext))), true);
  return buf;
}

export class CRYPTUI_INITDIALOG_STRUCTView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: pointer
  get lParam(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(0, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x08: pointer
  get pCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: pointer
  set lParam(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(0, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x08: pointer
  set pCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_VIEWCERTIFICATE_STRUCTW (size: 120)
 */
export interface CRYPTUI_VIEWCERTIFICATE_STRUCTW {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.HWND */
  hwndParent: Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_VIEWCERTIFICATE_FLAGS */
  dwFlags: CRYPTUI_VIEWCERTIFICATE_FLAGS;
  /** Windows.Win32.Foundation.PWSTR */
  szTitle: string | null | Uint8Array | Uint16Array;
  /** ptr */
  pCertContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  rgszPurposes: Deno.PointerValue | Uint8Array;
  /** u32 */
  cPurposes: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.BOOL */
  fpCryptProviderDataTrustedUsage: boolean;
  /** u32 */
  idxSigner: number;
  /** u32 */
  idxCert: number;
  /** Windows.Win32.Foundation.BOOL */
  fCounterSigner: boolean;
  /** u32 */
  idxCounterSigner: number;
  /** u32 */
  cStores: number;
  /** ptr */
  rghStores: Deno.PointerValue | Uint8Array;
  /** u32 */
  cPropSheetPages: number;
  /** ptr */
  rgPropSheetPages: Deno.PointerValue | Uint8Array;
  /** u32 */
  nStartPage: number;
}

export const sizeofCRYPTUI_VIEWCERTIFICATE_STRUCTW = 120;

export function allocCRYPTUI_VIEWCERTIFICATE_STRUCTW(data?: Partial<CRYPTUI_VIEWCERTIFICATE_STRUCTW>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_VIEWCERTIFICATE_STRUCTW);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hwndParent !== undefined) view.setBigUint64(8, data.hwndParent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndParent))), true);
  // 0x10: u32
  if (data?.dwFlags !== undefined) view.setUint32(16, Number(data.dwFlags), true);
  // 0x14: pad4
  // 0x18: buffer
  if (data?.szTitle !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.szTitle);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: pointer
  if (data?.pCertContext !== undefined) view.setBigUint64(32, data.pCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertContext))), true);
  // 0x28: pointer
  if (data?.rgszPurposes !== undefined) view.setBigUint64(40, data.rgszPurposes === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgszPurposes))), true);
  // 0x30: u32
  if (data?.cPurposes !== undefined) view.setUint32(48, Number(data.cPurposes), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(56, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x40: i32
  if (data?.fpCryptProviderDataTrustedUsage !== undefined) view.setInt32(64, Number(data.fpCryptProviderDataTrustedUsage), true);
  // 0x44: u32
  if (data?.idxSigner !== undefined) view.setUint32(68, Number(data.idxSigner), true);
  // 0x48: u32
  if (data?.idxCert !== undefined) view.setUint32(72, Number(data.idxCert), true);
  // 0x4c: i32
  if (data?.fCounterSigner !== undefined) view.setInt32(76, Number(data.fCounterSigner), true);
  // 0x50: u32
  if (data?.idxCounterSigner !== undefined) view.setUint32(80, Number(data.idxCounterSigner), true);
  // 0x54: u32
  if (data?.cStores !== undefined) view.setUint32(84, Number(data.cStores), true);
  // 0x58: pointer
  if (data?.rghStores !== undefined) view.setBigUint64(88, data.rghStores === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghStores))), true);
  // 0x60: u32
  if (data?.cPropSheetPages !== undefined) view.setUint32(96, Number(data.cPropSheetPages), true);
  // 0x64: pad4
  // 0x68: pointer
  if (data?.rgPropSheetPages !== undefined) view.setBigUint64(104, data.rgPropSheetPages === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgPropSheetPages))), true);
  // 0x70: u32
  if (data?.nStartPage !== undefined) view.setUint32(112, Number(data.nStartPage), true);
  // 0x74: pad4
  return buf;
}

export class CRYPTUI_VIEWCERTIFICATE_STRUCTWView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hwndParent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwFlags(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  get szTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get rgszPurposes(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cPurposes(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: i32
  get fpCryptProviderDataTrustedUsage(): number {
    return this.view.getInt32(64, true);
  }

  // 0x44: u32
  get idxSigner(): number {
    return this.view.getUint32(68, true);
  }

  // 0x48: u32
  get idxCert(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: i32
  get fCounterSigner(): number {
    return this.view.getInt32(76, true);
  }

  // 0x50: u32
  get idxCounterSigner(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: u32
  get cStores(): number {
    return this.view.getUint32(84, true);
  }

  // 0x58: pointer
  get rghStores(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x60: u32
  get cPropSheetPages(): number {
    return this.view.getUint32(96, true);
  }

  // 0x64: pad4

  // 0x68: pointer
  get rgPropSheetPages(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(104, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x70: u32
  get nStartPage(): number {
    return this.view.getUint32(112, true);
  }

  // 0x74: pad4

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hwndParent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwFlags(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  set szTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: pointer
  set pCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set rgszPurposes(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cPurposes(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: i32
  set fpCryptProviderDataTrustedUsage(value: number) {
    this.view.setInt32(64, value, true);
  }

  // 0x44: u32
  set idxSigner(value: number) {
    this.view.setUint32(68, value, true);
  }

  // 0x48: u32
  set idxCert(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: i32
  set fCounterSigner(value: number) {
    this.view.setInt32(76, value, true);
  }

  // 0x50: u32
  set idxCounterSigner(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: u32
  set cStores(value: number) {
    this.view.setUint32(84, value, true);
  }

  // 0x58: pointer
  set rghStores(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x60: u32
  set cPropSheetPages(value: number) {
    this.view.setUint32(96, value, true);
  }

  // 0x64: pad4

  // 0x68: pointer
  set rgPropSheetPages(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x70: u32
  set nStartPage(value: number) {
    this.view.setUint32(112, value, true);
  }

  // 0x74: pad4
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_VIEWCERTIFICATE_STRUCTA (size: 120)
 */
export interface CRYPTUI_VIEWCERTIFICATE_STRUCTA {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.HWND */
  hwndParent: Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_VIEWCERTIFICATE_FLAGS */
  dwFlags: CRYPTUI_VIEWCERTIFICATE_FLAGS;
  /** Windows.Win32.Foundation.PSTR */
  szTitle: string | null | Uint8Array;
  /** ptr */
  pCertContext: Deno.PointerValue | Uint8Array;
  /** ptr */
  rgszPurposes: Deno.PointerValue | Uint8Array;
  /** u32 */
  cPurposes: number;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Foundation.BOOL */
  fpCryptProviderDataTrustedUsage: boolean;
  /** u32 */
  idxSigner: number;
  /** u32 */
  idxCert: number;
  /** Windows.Win32.Foundation.BOOL */
  fCounterSigner: boolean;
  /** u32 */
  idxCounterSigner: number;
  /** u32 */
  cStores: number;
  /** ptr */
  rghStores: Deno.PointerValue | Uint8Array;
  /** u32 */
  cPropSheetPages: number;
  /** ptr */
  rgPropSheetPages: Deno.PointerValue | Uint8Array;
  /** u32 */
  nStartPage: number;
}

export const sizeofCRYPTUI_VIEWCERTIFICATE_STRUCTA = 120;

export function allocCRYPTUI_VIEWCERTIFICATE_STRUCTA(data?: Partial<CRYPTUI_VIEWCERTIFICATE_STRUCTA>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_VIEWCERTIFICATE_STRUCTA);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: pointer
  if (data?.hwndParent !== undefined) view.setBigUint64(8, data.hwndParent === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.hwndParent))), true);
  // 0x10: u32
  if (data?.dwFlags !== undefined) view.setUint32(16, Number(data.dwFlags), true);
  // 0x14: pad4
  // 0x18: buffer
  if (data?.szTitle !== undefined) {
    (buf as any)._f24 = util.pstrToFfi(data.szTitle);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  // 0x20: pointer
  if (data?.pCertContext !== undefined) view.setBigUint64(32, data.pCertContext === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.pCertContext))), true);
  // 0x28: pointer
  if (data?.rgszPurposes !== undefined) view.setBigUint64(40, data.rgszPurposes === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgszPurposes))), true);
  // 0x30: u32
  if (data?.cPurposes !== undefined) view.setUint32(48, Number(data.cPurposes), true);
  // 0x34: pad4
  // 0x38: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(56, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x40: i32
  if (data?.fpCryptProviderDataTrustedUsage !== undefined) view.setInt32(64, Number(data.fpCryptProviderDataTrustedUsage), true);
  // 0x44: u32
  if (data?.idxSigner !== undefined) view.setUint32(68, Number(data.idxSigner), true);
  // 0x48: u32
  if (data?.idxCert !== undefined) view.setUint32(72, Number(data.idxCert), true);
  // 0x4c: i32
  if (data?.fCounterSigner !== undefined) view.setInt32(76, Number(data.fCounterSigner), true);
  // 0x50: u32
  if (data?.idxCounterSigner !== undefined) view.setUint32(80, Number(data.idxCounterSigner), true);
  // 0x54: u32
  if (data?.cStores !== undefined) view.setUint32(84, Number(data.cStores), true);
  // 0x58: pointer
  if (data?.rghStores !== undefined) view.setBigUint64(88, data.rghStores === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghStores))), true);
  // 0x60: u32
  if (data?.cPropSheetPages !== undefined) view.setUint32(96, Number(data.cPropSheetPages), true);
  // 0x64: pad4
  // 0x68: pointer
  if (data?.rgPropSheetPages !== undefined) view.setBigUint64(104, data.rgPropSheetPages === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rgPropSheetPages))), true);
  // 0x70: u32
  if (data?.nStartPage !== undefined) view.setUint32(112, Number(data.nStartPage), true);
  // 0x74: pad4
  return buf;
}

export class CRYPTUI_VIEWCERTIFICATE_STRUCTAView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  get hwndParent(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwFlags(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  get szTitle(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: pointer
  get pCertContext(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(32, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x28: pointer
  get rgszPurposes(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x30: u32
  get cPurposes(): number {
    return this.view.getUint32(48, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x40: i32
  get fpCryptProviderDataTrustedUsage(): number {
    return this.view.getInt32(64, true);
  }

  // 0x44: u32
  get idxSigner(): number {
    return this.view.getUint32(68, true);
  }

  // 0x48: u32
  get idxCert(): number {
    return this.view.getUint32(72, true);
  }

  // 0x4c: i32
  get fCounterSigner(): number {
    return this.view.getInt32(76, true);
  }

  // 0x50: u32
  get idxCounterSigner(): number {
    return this.view.getUint32(80, true);
  }

  // 0x54: u32
  get cStores(): number {
    return this.view.getUint32(84, true);
  }

  // 0x58: pointer
  get rghStores(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(88, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x60: u32
  get cPropSheetPages(): number {
    return this.view.getUint32(96, true);
  }

  // 0x64: pad4

  // 0x68: pointer
  get rgPropSheetPages(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(104, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x70: u32
  get nStartPage(): number {
    return this.view.getUint32(112, true);
  }

  // 0x74: pad4

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: pointer
  set hwndParent(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwFlags(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  set szTitle(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }

  // 0x20: pointer
  set pCertContext(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(32, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x28: pointer
  set rgszPurposes(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x30: u32
  set cPurposes(value: number) {
    this.view.setUint32(48, value, true);
  }

  // 0x34: pad4

  // 0x38: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x40: i32
  set fpCryptProviderDataTrustedUsage(value: number) {
    this.view.setInt32(64, value, true);
  }

  // 0x44: u32
  set idxSigner(value: number) {
    this.view.setUint32(68, value, true);
  }

  // 0x48: u32
  set idxCert(value: number) {
    this.view.setUint32(72, value, true);
  }

  // 0x4c: i32
  set fCounterSigner(value: number) {
    this.view.setInt32(76, value, true);
  }

  // 0x50: u32
  set idxCounterSigner(value: number) {
    this.view.setUint32(80, value, true);
  }

  // 0x54: u32
  set cStores(value: number) {
    this.view.setUint32(84, value, true);
  }

  // 0x58: pointer
  set rghStores(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(88, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x60: u32
  set cPropSheetPages(value: number) {
    this.view.setUint32(96, value, true);
  }

  // 0x64: pad4

  // 0x68: pointer
  set rgPropSheetPages(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(104, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x70: u32
  set nStartPage(value: number) {
    this.view.setUint32(112, value, true);
  }

  // 0x74: pad4
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_EXPORT_INFO (size: 48)
 */
export interface CRYPTUI_WIZ_EXPORT_INFO {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Foundation.PWSTR */
  pwszExportFileName: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_EXPORT_SUBJECT */
  dwSubjectChoice: CRYPTUI_WIZ_EXPORT_SUBJECT;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** u32 */
  cStores: number;
  /** ptr */
  rghStores: Deno.PointerValue | Uint8Array;
}

export const sizeofCRYPTUI_WIZ_EXPORT_INFO = 48;

export function allocCRYPTUI_WIZ_EXPORT_INFO(data?: Partial<CRYPTUI_WIZ_EXPORT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_EXPORT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: pad4
  // 0x08: buffer
  if (data?.pwszExportFileName !== undefined) {
    (buf as any)._f8 = util.pwstrToFfi(data.pwszExportFileName);
    view.setBigUint64(8, (buf as any)._f8 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f8))), true);
  }
  // 0x10: u32
  if (data?.dwSubjectChoice !== undefined) view.setUint32(16, Number(data.dwSubjectChoice), true);
  // 0x14: pad4
  // 0x18: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(24, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x20: u32
  if (data?.cStores !== undefined) view.setUint32(32, Number(data.cStores), true);
  // 0x24: pad4
  // 0x28: pointer
  if (data?.rghStores !== undefined) view.setBigUint64(40, data.rghStores === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.rghStores))), true);
  return buf;
}

export class CRYPTUI_WIZ_EXPORT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  get pwszExportFileName(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwSubjectChoice(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x20: u32
  get cStores(): number {
    return this.view.getUint32(32, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  get rghStores(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(40, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: pad4

  // 0x08: buffer
  set pwszExportFileName(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f8 = value;
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f8))), true);
  }

  // 0x10: u32
  set dwSubjectChoice(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x20: u32
  set cStores(value: number) {
    this.view.setUint32(32, value, true);
  }

  // 0x24: pad4

  // 0x28: pointer
  set rghStores(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(40, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO (size: 32)
 */
export interface CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_EXPORT_FORMAT */
  dwExportFormat: CRYPTUI_WIZ_EXPORT_FORMAT;
  /** Windows.Win32.Foundation.BOOL */
  fExportChain: boolean;
  /** Windows.Win32.Foundation.BOOL */
  fExportPrivateKeys: boolean;
  /** Windows.Win32.Foundation.PWSTR */
  pwszPassword: string | null | Uint8Array | Uint16Array;
  /** Windows.Win32.Foundation.BOOL */
  fStrongEncryption: boolean;
}

export const sizeofCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO = 32;

export function allocCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO(data?: Partial<CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: u32
  if (data?.dwExportFormat !== undefined) view.setUint32(4, Number(data.dwExportFormat), true);
  // 0x08: i32
  if (data?.fExportChain !== undefined) view.setInt32(8, Number(data.fExportChain), true);
  // 0x0c: i32
  if (data?.fExportPrivateKeys !== undefined) view.setInt32(12, Number(data.fExportPrivateKeys), true);
  // 0x10: buffer
  if (data?.pwszPassword !== undefined) {
    (buf as any)._f16 = util.pwstrToFfi(data.pwszPassword);
    view.setBigUint64(16, (buf as any)._f16 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f16))), true);
  }
  // 0x18: i32
  if (data?.fStrongEncryption !== undefined) view.setInt32(24, Number(data.fStrongEncryption), true);
  // 0x1c: pad4
  return buf;
}

export class CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwExportFormat(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: i32
  get fExportChain(): number {
    return this.view.getInt32(8, true);
  }

  // 0x0c: i32
  get fExportPrivateKeys(): number {
    return this.view.getInt32(12, true);
  }

  // 0x10: buffer
  get pwszPassword(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(16, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x18: i32
  get fStrongEncryption(): number {
    return this.view.getInt32(24, true);
  }

  // 0x1c: pad4

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwExportFormat(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: i32
  set fExportChain(value: number) {
    this.view.setInt32(8, value, true);
  }

  // 0x0c: i32
  set fExportPrivateKeys(value: number) {
    this.view.setInt32(12, value, true);
  }

  // 0x10: buffer
  set pwszPassword(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f16 = value;
    this.view.setBigUint64(16, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f16))), true);
  }

  // 0x18: i32
  set fStrongEncryption(value: number) {
    this.view.setInt32(24, value, true);
  }

  // 0x1c: pad4
}

/**
 * Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_IMPORT_SRC_INFO (size: 32)
 */
export interface CRYPTUI_WIZ_IMPORT_SRC_INFO {
  /** u32 */
  dwSize: number;
  /** Windows.Win32.Security.Cryptography.UI.CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION */
  dwSubjectChoice: CRYPTUI_WIZ_IMPORT_SUBJECT_OPTION;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue;
  /** Windows.Win32.Security.Cryptography.CRYPT_KEY_FLAGS */
  dwFlags: CRYPT_KEY_FLAGS;
  /** Windows.Win32.Foundation.PWSTR */
  pwszPassword: string | null | Uint8Array | Uint16Array;
}

export const sizeofCRYPTUI_WIZ_IMPORT_SRC_INFO = 32;

export function allocCRYPTUI_WIZ_IMPORT_SRC_INFO(data?: Partial<CRYPTUI_WIZ_IMPORT_SRC_INFO>): Uint8Array {
  const buf = new Uint8Array(sizeofCRYPTUI_WIZ_IMPORT_SRC_INFO);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.dwSize !== undefined) view.setUint32(0, Number(data.dwSize), true);
  // 0x04: u32
  if (data?.dwSubjectChoice !== undefined) view.setUint32(4, Number(data.dwSubjectChoice), true);
  // 0x08: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(8, data.Anonymous === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.Anonymous))), true);
  // 0x10: u32
  if (data?.dwFlags !== undefined) view.setUint32(16, Number(data.dwFlags), true);
  // 0x14: pad4
  // 0x18: buffer
  if (data?.pwszPassword !== undefined) {
    (buf as any)._f24 = util.pwstrToFfi(data.pwszPassword);
    view.setBigUint64(24, (buf as any)._f24 === null ? 0n : BigInt(Deno.UnsafePointer.value(Deno.UnsafePointer.of((buf as any)._f24))), true);
  }
  return buf;
}

export class CRYPTUI_WIZ_IMPORT_SRC_INFOView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get dwSize(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get dwSubjectChoice(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get Anonymous(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x10: u32
  get dwFlags(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  get pwszPassword(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set dwSize(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set dwSubjectChoice(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set Anonymous(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }

  // 0x10: u32
  set dwFlags(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: pad4

  // 0x18: buffer
  set pwszPassword(value: Uint8Array | Deno.PointerValue) {
    (this.buf as any)._f24 = value;
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer((this.buf as any)._f24))), true);
  }
}

export type NTSTATUS = number;

export type HRESULT = number;

export type PSID = Deno.PointerValue | Uint8Array;

export type NCRYPT_DESCRIPTOR_HANDLE = Deno.PointerValue;

export type NCRYPT_STREAM_HANDLE = Deno.PointerValue;

// Native Libraries

try {
  var libADVAPI32_dll = Deno.dlopen("ADVAPI32.dll", {
    CryptAcquireContextA: {
      parameters: ["pointer", "buffer", "buffer", "u32", "u32"],
      result: "i32",
    },
    CryptAcquireContextW: {
      parameters: ["pointer", "buffer", "buffer", "u32", "u32"],
      result: "i32",
    },
    CryptReleaseContext: {
      parameters: ["usize", "u32"],
      result: "i32",
    },
    CryptGenKey: {
      parameters: ["usize", "u32", "u32", "pointer"],
      result: "i32",
    },
    CryptDeriveKey: {
      parameters: ["usize", "u32", "usize", "u32", "pointer"],
      result: "i32",
    },
    CryptDestroyKey: {
      parameters: ["usize"],
      result: "i32",
    },
    CryptSetKeyParam: {
      parameters: ["usize", "u32", "pointer", "u32"],
      result: "i32",
    },
    CryptGetKeyParam: {
      parameters: ["usize", "u32", "pointer", "pointer", "u32"],
      result: "i32",
    },
    CryptSetHashParam: {
      parameters: ["usize", "u32", "pointer", "u32"],
      result: "i32",
    },
    CryptGetHashParam: {
      parameters: ["usize", "u32", "pointer", "pointer", "u32"],
      result: "i32",
    },
    CryptSetProvParam: {
      parameters: ["usize", "u32", "pointer", "u32"],
      result: "i32",
    },
    CryptGetProvParam: {
      parameters: ["usize", "u32", "pointer", "pointer", "u32"],
      result: "i32",
    },
    CryptGenRandom: {
      parameters: ["usize", "u32", "pointer"],
      result: "i32",
    },
    CryptGetUserKey: {
      parameters: ["usize", "u32", "pointer"],
      result: "i32",
    },
    CryptExportKey: {
      parameters: ["usize", "usize", "u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptImportKey: {
      parameters: ["usize", "pointer", "u32", "usize", "u32", "pointer"],
      result: "i32",
    },
    CryptEncrypt: {
      parameters: ["usize", "usize", "i32", "u32", "pointer", "pointer", "u32"],
      result: "i32",
    },
    CryptDecrypt: {
      parameters: ["usize", "usize", "i32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptCreateHash: {
      parameters: ["usize", "u32", "usize", "u32", "pointer"],
      result: "i32",
    },
    CryptHashData: {
      parameters: ["usize", "pointer", "u32", "u32"],
      result: "i32",
    },
    CryptHashSessionKey: {
      parameters: ["usize", "usize", "u32"],
      result: "i32",
    },
    CryptDestroyHash: {
      parameters: ["usize"],
      result: "i32",
    },
    CryptSignHashA: {
      parameters: ["usize", "u32", "buffer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptSignHashW: {
      parameters: ["usize", "u32", "buffer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptVerifySignatureA: {
      parameters: ["usize", "pointer", "u32", "usize", "buffer", "u32"],
      result: "i32",
    },
    CryptVerifySignatureW: {
      parameters: ["usize", "pointer", "u32", "usize", "buffer", "u32"],
      result: "i32",
    },
    CryptSetProviderA: {
      parameters: ["buffer", "u32"],
      result: "i32",
    },
    CryptSetProviderW: {
      parameters: ["buffer", "u32"],
      result: "i32",
    },
    CryptSetProviderExA: {
      parameters: ["buffer", "u32", "pointer", "u32"],
      result: "i32",
    },
    CryptSetProviderExW: {
      parameters: ["buffer", "u32", "pointer", "u32"],
      result: "i32",
    },
    CryptGetDefaultProviderA: {
      parameters: ["u32", "pointer", "u32", "buffer", "pointer"],
      result: "i32",
    },
    CryptGetDefaultProviderW: {
      parameters: ["u32", "pointer", "u32", "buffer", "pointer"],
      result: "i32",
    },
    CryptEnumProviderTypesA: {
      parameters: ["u32", "pointer", "u32", "pointer", "buffer", "pointer"],
      result: "i32",
    },
    CryptEnumProviderTypesW: {
      parameters: ["u32", "pointer", "u32", "pointer", "buffer", "pointer"],
      result: "i32",
    },
    CryptEnumProvidersA: {
      parameters: ["u32", "pointer", "u32", "pointer", "buffer", "pointer"],
      result: "i32",
    },
    CryptEnumProvidersW: {
      parameters: ["u32", "pointer", "u32", "pointer", "buffer", "pointer"],
      result: "i32",
    },
    CryptContextAddRef: {
      parameters: ["usize", "pointer", "u32"],
      result: "i32",
    },
    CryptDuplicateKey: {
      parameters: ["usize", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptDuplicateHash: {
      parameters: ["usize", "pointer", "u32", "pointer"],
      result: "i32",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libbcrypt_dll = Deno.dlopen("bcrypt.dll", {
    BCryptOpenAlgorithmProvider: {
      parameters: ["pointer", "buffer", "buffer", "u32"],
      result: "pointer",
    },
    BCryptEnumAlgorithms: {
      parameters: ["u32", "pointer", "pointer", "u32"],
      result: "pointer",
    },
    BCryptEnumProviders: {
      parameters: ["buffer", "pointer", "pointer", "u32"],
      result: "pointer",
    },
    BCryptGetProperty: {
      parameters: ["pointer", "buffer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptSetProperty: {
      parameters: ["pointer", "buffer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptCloseAlgorithmProvider: {
      parameters: ["pointer", "u32"],
      result: "pointer",
    },
    BCryptFreeBuffer: {
      parameters: ["pointer"],
      result: "void",
    },
    BCryptGenerateSymmetricKey: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptGenerateKeyPair: {
      parameters: ["pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptEncrypt: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "u32", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptDecrypt: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "u32", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptExportKey: {
      parameters: ["pointer", "pointer", "buffer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptImportKey: {
      parameters: ["pointer", "pointer", "buffer", "pointer", "pointer", "u32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptImportKeyPair: {
      parameters: ["pointer", "pointer", "buffer", "pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptDuplicateKey: {
      parameters: ["pointer", "pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptFinalizeKeyPair: {
      parameters: ["pointer", "u32"],
      result: "pointer",
    },
    BCryptDestroyKey: {
      parameters: ["pointer"],
      result: "pointer",
    },
    BCryptDestroySecret: {
      parameters: ["pointer"],
      result: "pointer",
    },
    BCryptSignHash: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptVerifySignature: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptSecretAgreement: {
      parameters: ["pointer", "pointer", "pointer", "u32"],
      result: "pointer",
    },
    BCryptDeriveKey: {
      parameters: ["pointer", "buffer", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptKeyDerivation: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptCreateHash: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptHashData: {
      parameters: ["pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptFinishHash: {
      parameters: ["pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptCreateMultiHash: {
      parameters: ["pointer", "pointer", "u32", "pointer", "u32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptProcessMultiOperations: {
      parameters: ["pointer", "i32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptDuplicateHash: {
      parameters: ["pointer", "pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptDestroyHash: {
      parameters: ["pointer"],
      result: "pointer",
    },
    BCryptHash: {
      parameters: ["pointer", "pointer", "u32", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    BCryptGenRandom: {
      parameters: ["pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptDeriveKeyCapi: {
      parameters: ["pointer", "pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptDeriveKeyPBKDF2: {
      parameters: ["pointer", "pointer", "u32", "pointer", "u32", "u64", "pointer", "u32", "u32"],
      result: "pointer",
    },
    BCryptQueryProviderRegistration: {
      parameters: ["buffer", "u32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptEnumRegisteredProviders: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    BCryptCreateContext: {
      parameters: ["u32", "buffer", "pointer"],
      result: "pointer",
    },
    BCryptDeleteContext: {
      parameters: ["u32", "buffer"],
      result: "pointer",
    },
    BCryptEnumContexts: {
      parameters: ["u32", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptConfigureContext: {
      parameters: ["u32", "buffer", "pointer"],
      result: "pointer",
    },
    BCryptQueryContextConfiguration: {
      parameters: ["u32", "buffer", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptAddContextFunction: {
      parameters: ["u32", "buffer", "u32", "buffer", "u32"],
      result: "pointer",
    },
    BCryptRemoveContextFunction: {
      parameters: ["u32", "buffer", "u32", "buffer"],
      result: "pointer",
    },
    BCryptEnumContextFunctions: {
      parameters: ["u32", "buffer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptConfigureContextFunction: {
      parameters: ["u32", "buffer", "u32", "buffer", "pointer"],
      result: "pointer",
    },
    BCryptQueryContextFunctionConfiguration: {
      parameters: ["u32", "buffer", "u32", "buffer", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptEnumContextFunctionProviders: {
      parameters: ["u32", "buffer", "u32", "buffer", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptSetContextFunctionProperty: {
      parameters: ["u32", "buffer", "u32", "buffer", "buffer", "u32", "pointer"],
      result: "pointer",
    },
    BCryptQueryContextFunctionProperty: {
      parameters: ["u32", "buffer", "u32", "buffer", "buffer", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptRegisterConfigChangeNotify: {
      parameters: ["pointer"],
      result: "pointer",
    },
    BCryptUnregisterConfigChangeNotify: {
      parameters: ["pointer"],
      result: "pointer",
    },
    BCryptResolveProviders: {
      parameters: ["buffer", "u32", "buffer", "buffer", "u32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    BCryptGetFipsAlgorithmMode: {
      parameters: ["pointer"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libncrypt_dll = Deno.dlopen("ncrypt.dll", {
    NCryptOpenStorageProvider: {
      parameters: ["pointer", "buffer", "u32"],
      result: "pointer",
    },
    NCryptEnumAlgorithms: {
      parameters: ["pointer", "u32", "pointer", "pointer", "u32"],
      result: "pointer",
    },
    NCryptIsAlgSupported: {
      parameters: ["pointer", "buffer", "u32"],
      result: "pointer",
    },
    NCryptEnumKeys: {
      parameters: ["pointer", "buffer", "pointer", "pointer", "u32"],
      result: "pointer",
    },
    NCryptEnumStorageProviders: {
      parameters: ["pointer", "pointer", "u32"],
      result: "pointer",
    },
    NCryptFreeBuffer: {
      parameters: ["pointer"],
      result: "pointer",
    },
    NCryptOpenKey: {
      parameters: ["pointer", "pointer", "buffer", "u32", "u32"],
      result: "pointer",
    },
    NCryptCreatePersistedKey: {
      parameters: ["pointer", "pointer", "buffer", "buffer", "u32", "u32"],
      result: "pointer",
    },
    NCryptGetProperty: {
      parameters: ["pointer", "buffer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptSetProperty: {
      parameters: ["pointer", "buffer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    NCryptFinalizeKey: {
      parameters: ["pointer", "u32"],
      result: "pointer",
    },
    NCryptEncrypt: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptDecrypt: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptImportKey: {
      parameters: ["pointer", "pointer", "buffer", "pointer", "pointer", "pointer", "u32", "u32"],
      result: "pointer",
    },
    NCryptExportKey: {
      parameters: ["pointer", "pointer", "buffer", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptSignHash: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptVerifySignature: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    NCryptDeleteKey: {
      parameters: ["pointer", "u32"],
      result: "pointer",
    },
    NCryptFreeObject: {
      parameters: ["pointer"],
      result: "pointer",
    },
    NCryptIsKeyHandle: {
      parameters: ["pointer"],
      result: "i32",
    },
    NCryptTranslateHandle: {
      parameters: ["pointer", "pointer", "usize", "usize", "u32", "u32"],
      result: "pointer",
    },
    NCryptNotifyChangeKey: {
      parameters: ["pointer", "pointer", "u32"],
      result: "pointer",
    },
    NCryptSecretAgreement: {
      parameters: ["pointer", "pointer", "pointer", "u32"],
      result: "pointer",
    },
    NCryptDeriveKey: {
      parameters: ["pointer", "buffer", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptKeyDerivation: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptCreateClaim: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptVerifyClaim: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    NCryptRegisterProtectionDescriptorName: {
      parameters: ["buffer", "buffer", "u32"],
      result: "pointer",
    },
    NCryptQueryProtectionDescriptorName: {
      parameters: ["buffer", "buffer", "pointer", "u32"],
      result: "pointer",
    },
    NCryptCreateProtectionDescriptor: {
      parameters: ["buffer", "u32", "pointer"],
      result: "pointer",
    },
    NCryptCloseProtectionDescriptor: {
      parameters: ["pointer"],
      result: "pointer",
    },
    NCryptGetProtectionDescriptorInfo: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "pointer",
    },
    NCryptProtectSecret: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    NCryptUnprotectSecret: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    NCryptStreamOpenToProtect: {
      parameters: ["pointer", "u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    NCryptStreamOpenToUnprotect: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    NCryptStreamOpenToUnprotectEx: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    NCryptStreamUpdate: {
      parameters: ["pointer", "pointer", "usize", "i32"],
      result: "pointer",
    },
    NCryptStreamClose: {
      parameters: ["pointer"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libCRYPT32_dll = Deno.dlopen("CRYPT32.dll", {
    CryptFormatObject: {
      parameters: ["u32", "u32", "u32", "pointer", "buffer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptEncodeObjectEx: {
      parameters: ["u32", "buffer", "pointer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptEncodeObject: {
      parameters: ["u32", "buffer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptDecodeObjectEx: {
      parameters: ["u32", "buffer", "pointer", "u32", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptDecodeObject: {
      parameters: ["u32", "buffer", "pointer", "u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptInstallOIDFunctionAddress: {
      parameters: ["pointer", "u32", "buffer", "u32", "pointer", "u32"],
      result: "i32",
    },
    CryptInitOIDFunctionSet: {
      parameters: ["buffer", "u32"],
      result: "pointer",
    },
    CryptGetOIDFunctionAddress: {
      parameters: ["pointer", "u32", "buffer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptGetDefaultOIDDllList: {
      parameters: ["pointer", "u32", "buffer", "pointer"],
      result: "i32",
    },
    CryptGetDefaultOIDFunctionAddress: {
      parameters: ["pointer", "u32", "buffer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptFreeOIDFunctionAddress: {
      parameters: ["pointer", "u32"],
      result: "i32",
    },
    CryptRegisterOIDFunction: {
      parameters: ["u32", "buffer", "buffer", "buffer", "buffer"],
      result: "i32",
    },
    CryptUnregisterOIDFunction: {
      parameters: ["u32", "buffer", "buffer"],
      result: "i32",
    },
    CryptRegisterDefaultOIDFunction: {
      parameters: ["u32", "buffer", "u32", "buffer"],
      result: "i32",
    },
    CryptUnregisterDefaultOIDFunction: {
      parameters: ["u32", "buffer", "buffer"],
      result: "i32",
    },
    CryptSetOIDFunctionValue: {
      parameters: ["u32", "buffer", "buffer", "buffer", "u32", "pointer", "u32"],
      result: "i32",
    },
    CryptGetOIDFunctionValue: {
      parameters: ["u32", "buffer", "buffer", "buffer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptEnumOIDFunction: {
      parameters: ["u32", "buffer", "buffer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptFindOIDInfo: {
      parameters: ["u32", "pointer", "u32"],
      result: "pointer",
    },
    CryptRegisterOIDInfo: {
      parameters: ["pointer", "u32"],
      result: "i32",
    },
    CryptUnregisterOIDInfo: {
      parameters: ["pointer"],
      result: "i32",
    },
    CryptEnumOIDInfo: {
      parameters: ["u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptFindLocalizedName: {
      parameters: ["buffer"],
      result: "buffer",
    },
    CryptMsgOpenToEncode: {
      parameters: ["u32", "u32", "u32", "pointer", "buffer", "pointer"],
      result: "pointer",
    },
    CryptMsgCalculateEncodedLength: {
      parameters: ["u32", "u32", "u32", "pointer", "buffer", "u32"],
      result: "u32",
    },
    CryptMsgOpenToDecode: {
      parameters: ["u32", "u32", "u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    CryptMsgDuplicate: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CryptMsgClose: {
      parameters: ["pointer"],
      result: "i32",
    },
    CryptMsgUpdate: {
      parameters: ["pointer", "pointer", "u32", "i32"],
      result: "i32",
    },
    CryptMsgGetParam: {
      parameters: ["pointer", "u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptMsgControl: {
      parameters: ["pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CryptMsgVerifyCountersignatureEncoded: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptMsgVerifyCountersignatureEncodedEx: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "u32", "u32", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptMsgCountersign: {
      parameters: ["pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CryptMsgCountersignEncoded: {
      parameters: ["u32", "pointer", "u32", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertOpenStore: {
      parameters: ["buffer", "u32", "pointer", "u32", "pointer"],
      result: "pointer",
    },
    CertDuplicateStore: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CertSaveStore: {
      parameters: ["pointer", "u32", "u32", "u32", "pointer", "u32"],
      result: "i32",
    },
    CertCloseStore: {
      parameters: ["pointer", "u32"],
      result: "i32",
    },
    CertGetSubjectCertificateFromStore: {
      parameters: ["pointer", "u32", "pointer"],
      result: "pointer",
    },
    CertEnumCertificatesInStore: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    CertFindCertificateInStore: {
      parameters: ["pointer", "u32", "u32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CertGetIssuerCertificateFromStore: {
      parameters: ["pointer", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    CertVerifySubjectCertificateContext: {
      parameters: ["pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertDuplicateCertificateContext: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CertCreateCertificateContext: {
      parameters: ["u32", "pointer", "u32"],
      result: "pointer",
    },
    CertFreeCertificateContext: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertSetCertificateContextProperty: {
      parameters: ["pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertGetCertificateContextProperty: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertEnumCertificateContextProperties: {
      parameters: ["pointer", "u32"],
      result: "u32",
    },
    CertCreateCTLEntryFromCertificateContextProperties: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertSetCertificateContextPropertiesFromCTLEntry: {
      parameters: ["pointer", "pointer", "u32"],
      result: "i32",
    },
    CertGetCRLFromStore: {
      parameters: ["pointer", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    CertEnumCRLsInStore: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    CertFindCRLInStore: {
      parameters: ["pointer", "u32", "u32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CertDuplicateCRLContext: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CertCreateCRLContext: {
      parameters: ["u32", "pointer", "u32"],
      result: "pointer",
    },
    CertFreeCRLContext: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertSetCRLContextProperty: {
      parameters: ["pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertGetCRLContextProperty: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertEnumCRLContextProperties: {
      parameters: ["pointer", "u32"],
      result: "u32",
    },
    CertFindCertificateInCRL: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertIsValidCRLForCertificate: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertAddEncodedCertificateToStore: {
      parameters: ["pointer", "u32", "pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertAddCertificateContextToStore: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertAddSerializedElementToStore: {
      parameters: ["pointer", "pointer", "u32", "u32", "u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertDeleteCertificateFromStore: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertAddEncodedCRLToStore: {
      parameters: ["pointer", "u32", "pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertAddCRLContextToStore: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertDeleteCRLFromStore: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertSerializeCertificateStoreElement: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertSerializeCRLStoreElement: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertDuplicateCTLContext: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CertCreateCTLContext: {
      parameters: ["u32", "pointer", "u32"],
      result: "pointer",
    },
    CertFreeCTLContext: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertSetCTLContextProperty: {
      parameters: ["pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertGetCTLContextProperty: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertEnumCTLContextProperties: {
      parameters: ["pointer", "u32"],
      result: "u32",
    },
    CertEnumCTLsInStore: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    CertFindSubjectInCTL: {
      parameters: ["u32", "u32", "pointer", "pointer", "u32"],
      result: "pointer",
    },
    CertFindCTLInStore: {
      parameters: ["pointer", "u32", "u32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CertAddEncodedCTLToStore: {
      parameters: ["pointer", "u32", "pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertAddCTLContextToStore: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertSerializeCTLStoreElement: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertDeleteCTLFromStore: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertAddCertificateLinkToStore: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertAddCRLLinkToStore: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertAddCTLLinkToStore: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertAddStoreToCollection: {
      parameters: ["pointer", "pointer", "u32", "u32"],
      result: "i32",
    },
    CertRemoveStoreFromCollection: {
      parameters: ["pointer", "pointer"],
      result: "void",
    },
    CertControlStore: {
      parameters: ["pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertSetStoreProperty: {
      parameters: ["pointer", "u32", "u32", "pointer"],
      result: "i32",
    },
    CertGetStoreProperty: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertCreateContext: {
      parameters: ["u32", "u32", "pointer", "u32", "u32", "pointer"],
      result: "pointer",
    },
    CertRegisterSystemStore: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertRegisterPhysicalStore: {
      parameters: ["pointer", "u32", "buffer", "pointer", "pointer"],
      result: "i32",
    },
    CertUnregisterSystemStore: {
      parameters: ["pointer", "u32"],
      result: "i32",
    },
    CertUnregisterPhysicalStore: {
      parameters: ["pointer", "u32", "buffer"],
      result: "i32",
    },
    CertEnumSystemStoreLocation: {
      parameters: ["u32", "pointer", "pointer"],
      result: "i32",
    },
    CertEnumSystemStore: {
      parameters: ["u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertEnumPhysicalStore: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertGetEnhancedKeyUsage: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertSetEnhancedKeyUsage: {
      parameters: ["pointer", "pointer"],
      result: "i32",
    },
    CertAddEnhancedKeyUsageIdentifier: {
      parameters: ["pointer", "buffer"],
      result: "i32",
    },
    CertRemoveEnhancedKeyUsageIdentifier: {
      parameters: ["pointer", "buffer"],
      result: "i32",
    },
    CertGetValidUsages: {
      parameters: ["u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptMsgGetAndVerifySigner: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptMsgSignCTL: {
      parameters: ["u32", "pointer", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptMsgEncodeAndSignCTL: {
      parameters: ["u32", "pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertFindSubjectInSortedCTL: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertEnumSubjectInSortedCTL: {
      parameters: ["pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertVerifyCTLUsage: {
      parameters: ["u32", "u32", "pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertVerifyRevocation: {
      parameters: ["u32", "u32", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertCompareIntegerBlob: {
      parameters: ["pointer", "pointer"],
      result: "i32",
    },
    CertCompareCertificate: {
      parameters: ["u32", "pointer", "pointer"],
      result: "i32",
    },
    CertCompareCertificateName: {
      parameters: ["u32", "pointer", "pointer"],
      result: "i32",
    },
    CertIsRDNAttrsInCertificateName: {
      parameters: ["u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertComparePublicKeyInfo: {
      parameters: ["u32", "pointer", "pointer"],
      result: "i32",
    },
    CertGetPublicKeyLength: {
      parameters: ["u32", "pointer"],
      result: "u32",
    },
    CryptVerifyCertificateSignature: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptVerifyCertificateSignatureEx: {
      parameters: ["pointer", "u32", "u32", "pointer", "u32", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertIsStrongHashToSign: {
      parameters: ["pointer", "buffer", "pointer"],
      result: "i32",
    },
    CryptHashToBeSigned: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptHashCertificate: {
      parameters: ["pointer", "u32", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptHashCertificate2: {
      parameters: ["buffer", "u32", "pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptSignCertificate: {
      parameters: ["pointer", "u32", "u32", "pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptSignAndEncodeCertificate: {
      parameters: ["pointer", "u32", "u32", "buffer", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertVerifyTimeValidity: {
      parameters: ["pointer", "pointer"],
      result: "i32",
    },
    CertVerifyCRLTimeValidity: {
      parameters: ["pointer", "pointer"],
      result: "i32",
    },
    CertVerifyValidityNesting: {
      parameters: ["pointer", "pointer"],
      result: "i32",
    },
    CertVerifyCRLRevocation: {
      parameters: ["u32", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CertAlgIdToOID: {
      parameters: ["u32"],
      result: "buffer",
    },
    CertOIDToAlgId: {
      parameters: ["buffer"],
      result: "u32",
    },
    CertFindExtension: {
      parameters: ["buffer", "u32", "pointer"],
      result: "pointer",
    },
    CertFindAttribute: {
      parameters: ["buffer", "u32", "pointer"],
      result: "pointer",
    },
    CertFindRDNAttr: {
      parameters: ["buffer", "pointer"],
      result: "pointer",
    },
    CertGetIntendedKeyUsage: {
      parameters: ["u32", "pointer", "pointer", "u32"],
      result: "i32",
    },
    CryptInstallDefaultContext: {
      parameters: ["usize", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptUninstallDefaultContext: {
      parameters: ["pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptExportPublicKeyInfo: {
      parameters: ["pointer", "u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptExportPublicKeyInfoEx: {
      parameters: ["pointer", "u32", "u32", "buffer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptExportPublicKeyInfoFromBCryptKeyHandle: {
      parameters: ["pointer", "u32", "buffer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptImportPublicKeyInfo: {
      parameters: ["usize", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptImportPublicKeyInfoEx: {
      parameters: ["usize", "u32", "pointer", "u32", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptImportPublicKeyInfoEx2: {
      parameters: ["u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptAcquireCertificatePrivateKey: {
      parameters: ["pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptFindCertificateKeyProvInfo: {
      parameters: ["pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptImportPKCS8: {
      parameters: ["pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptExportPKCS8: {
      parameters: ["usize", "u32", "buffer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptHashPublicKeyInfo: {
      parameters: ["pointer", "u32", "u32", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertRDNValueToStrA: {
      parameters: ["u32", "pointer", "buffer", "u32"],
      result: "u32",
    },
    CertRDNValueToStrW: {
      parameters: ["u32", "pointer", "buffer", "u32"],
      result: "u32",
    },
    CertNameToStrA: {
      parameters: ["u32", "pointer", "u32", "buffer", "u32"],
      result: "u32",
    },
    CertNameToStrW: {
      parameters: ["u32", "pointer", "u32", "buffer", "u32"],
      result: "u32",
    },
    CertStrToNameA: {
      parameters: ["u32", "buffer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertStrToNameW: {
      parameters: ["u32", "buffer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertGetNameStringA: {
      parameters: ["pointer", "u32", "u32", "pointer", "buffer", "u32"],
      result: "u32",
    },
    CertGetNameStringW: {
      parameters: ["pointer", "u32", "u32", "pointer", "buffer", "u32"],
      result: "u32",
    },
    CryptSignMessage: {
      parameters: ["pointer", "i32", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptVerifyMessageSignature: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptGetMessageSignerCount: {
      parameters: ["u32", "pointer", "u32"],
      result: "i32",
    },
    CryptGetMessageCertificates: {
      parameters: ["u32", "pointer", "u32", "pointer", "u32"],
      result: "pointer",
    },
    CryptVerifyDetachedMessageSignature: {
      parameters: ["pointer", "u32", "pointer", "u32", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptEncryptMessage: {
      parameters: ["pointer", "u32", "pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptDecryptMessage: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptSignAndEncryptMessage: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptDecryptAndVerifyMessageSignature: {
      parameters: ["pointer", "pointer", "u32", "pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptDecodeMessage: {
      parameters: ["u32", "pointer", "pointer", "u32", "pointer", "u32", "u32", "pointer", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptHashMessage: {
      parameters: ["pointer", "i32", "u32", "pointer", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptVerifyMessageHash: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptVerifyDetachedMessageHash: {
      parameters: ["pointer", "pointer", "u32", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptSignMessageWithKey: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptVerifyMessageSignatureWithKey: {
      parameters: ["pointer", "pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertOpenSystemStoreA: {
      parameters: ["pointer", "buffer"],
      result: "pointer",
    },
    CertOpenSystemStoreW: {
      parameters: ["pointer", "buffer"],
      result: "pointer",
    },
    CertAddEncodedCertificateToSystemStoreA: {
      parameters: ["buffer", "pointer", "u32"],
      result: "i32",
    },
    CertAddEncodedCertificateToSystemStoreW: {
      parameters: ["buffer", "pointer", "u32"],
      result: "i32",
    },
    CryptQueryObject: {
      parameters: ["u32", "pointer", "u32", "u32", "u32", "pointer", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptMemAlloc: {
      parameters: ["u32"],
      result: "pointer",
    },
    CryptMemRealloc: {
      parameters: ["pointer", "u32"],
      result: "pointer",
    },
    CryptMemFree: {
      parameters: ["pointer"],
      result: "void",
    },
    CryptCreateAsyncHandle: {
      parameters: ["u32", "pointer"],
      result: "i32",
    },
    CryptSetAsyncParam: {
      parameters: ["pointer", "buffer", "pointer", "pointer"],
      result: "i32",
    },
    CryptGetAsyncParam: {
      parameters: ["pointer", "buffer", "pointer", "pointer"],
      result: "i32",
    },
    CryptCloseAsyncHandle: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertCreateSelfSignCertificate: {
      parameters: ["pointer", "pointer", "u32", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    CryptGetKeyIdentifierProperty: {
      parameters: ["pointer", "u32", "u32", "buffer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptSetKeyIdentifierProperty: {
      parameters: ["pointer", "u32", "u32", "buffer", "pointer", "pointer"],
      result: "i32",
    },
    CryptEnumKeyIdentifierProperties: {
      parameters: ["pointer", "u32", "u32", "buffer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptCreateKeyIdentifierFromCSP: {
      parameters: ["u32", "buffer", "pointer", "u32", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertCreateCertificateChainEngine: {
      parameters: ["pointer", "pointer"],
      result: "i32",
    },
    CertFreeCertificateChainEngine: {
      parameters: ["pointer"],
      result: "void",
    },
    CertResyncCertificateChainEngine: {
      parameters: ["pointer"],
      result: "i32",
    },
    CertGetCertificateChain: {
      parameters: ["pointer", "pointer", "pointer", "pointer", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CertFreeCertificateChain: {
      parameters: ["pointer"],
      result: "void",
    },
    CertDuplicateCertificateChain: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CertFindChainInStore: {
      parameters: ["pointer", "u32", "u32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CertVerifyCertificateChainPolicy: {
      parameters: ["buffer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptStringToBinaryA: {
      parameters: ["buffer", "u32", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptStringToBinaryW: {
      parameters: ["buffer", "u32", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptBinaryToStringA: {
      parameters: ["pointer", "u32", "u32", "buffer", "pointer"],
      result: "i32",
    },
    CryptBinaryToStringW: {
      parameters: ["pointer", "u32", "u32", "buffer", "pointer"],
      result: "i32",
    },
    PFXImportCertStore: {
      parameters: ["pointer", "buffer", "u32"],
      result: "pointer",
    },
    PFXIsPFXBlob: {
      parameters: ["pointer"],
      result: "i32",
    },
    PFXVerifyPassword: {
      parameters: ["pointer", "buffer", "u32"],
      result: "i32",
    },
    PFXExportCertStoreEx: {
      parameters: ["pointer", "pointer", "buffer", "pointer", "u32"],
      result: "i32",
    },
    PFXExportCertStore: {
      parameters: ["pointer", "pointer", "buffer", "u32"],
      result: "i32",
    },
    CertOpenServerOcspResponse: {
      parameters: ["pointer", "u32", "pointer"],
      result: "pointer",
    },
    CertAddRefServerOcspResponse: {
      parameters: ["pointer"],
      result: "void",
    },
    CertCloseServerOcspResponse: {
      parameters: ["pointer", "u32"],
      result: "void",
    },
    CertGetServerOcspResponseContext: {
      parameters: ["pointer", "u32", "pointer"],
      result: "pointer",
    },
    CertAddRefServerOcspResponseContext: {
      parameters: ["pointer"],
      result: "void",
    },
    CertFreeServerOcspResponseContext: {
      parameters: ["pointer"],
      result: "void",
    },
    CertRetrieveLogoOrBiometricInfo: {
      parameters: ["pointer", "buffer", "u32", "u32", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertSelectCertificateChains: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertFreeCertificateChainList: {
      parameters: ["pointer"],
      result: "void",
    },
    CryptRetrieveTimeStamp: {
      parameters: ["buffer", "u32", "u32", "buffer", "pointer", "pointer", "u32", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptVerifyTimeStampSignature: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CertIsWeakHash: {
      parameters: ["u32", "buffer", "u32", "pointer", "pointer", "buffer"],
      result: "i32",
    },
    CryptProtectData: {
      parameters: ["pointer", "buffer", "pointer", "pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptUnprotectData: {
      parameters: ["pointer", "pointer", "pointer", "pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptUpdateProtectedState: {
      parameters: ["pointer", "buffer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    CryptProtectMemory: {
      parameters: ["pointer", "u32", "u32"],
      result: "i32",
    },
    CryptUnprotectMemory: {
      parameters: ["pointer", "u32", "u32"],
      result: "i32",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libWINTRUST_dll = Deno.dlopen("WINTRUST.dll", {
    FindCertsByIssuer: {
      parameters: ["pointer", "pointer", "pointer", "pointer", "u32", "buffer", "u32"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libCRYPTNET_dll = Deno.dlopen("CRYPTNET.dll", {
    CryptRetrieveObjectByUrlA: {
      parameters: ["buffer", "buffer", "u32", "u32", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptRetrieveObjectByUrlW: {
      parameters: ["buffer", "buffer", "u32", "u32", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
    CryptInstallCancelRetrieval: {
      parameters: ["pointer", "pointer", "u32", "pointer"],
      result: "i32",
    },
    CryptUninstallCancelRetrieval: {
      parameters: ["u32", "pointer"],
      result: "i32",
    },
    CryptGetObjectUrl: {
      parameters: ["buffer", "pointer", "u32", "pointer", "pointer", "pointer", "pointer", "pointer"],
      result: "i32",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libCRYPTXML_dll = Deno.dlopen("CRYPTXML.dll", {
    CryptXmlClose: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CryptXmlGetTransforms: {
      parameters: ["pointer"],
      result: "pointer",
    },
    CryptXmlOpenToEncode: {
      parameters: ["pointer", "u32", "buffer", "pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlOpenToDecode: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlAddObject: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlCreateReference: {
      parameters: ["pointer", "u32", "buffer", "buffer", "buffer", "pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlDigestReference: {
      parameters: ["pointer", "u32", "pointer"],
      result: "pointer",
    },
    CryptXmlSetHMACSecret: {
      parameters: ["pointer", "pointer", "u32"],
      result: "pointer",
    },
    CryptXmlSign: {
      parameters: ["pointer", "pointer", "u32", "u32", "i32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlImportPublicKey: {
      parameters: ["u32", "pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlVerifySignature: {
      parameters: ["pointer", "pointer", "u32"],
      result: "pointer",
    },
    CryptXmlGetDocContext: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlGetSignature: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlGetReference: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlGetStatus: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlEncode: {
      parameters: ["pointer", "i32", "pointer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    CryptXmlGetAlgorithmInfo: {
      parameters: ["pointer", "u32", "pointer"],
      result: "pointer",
    },
    CryptXmlFindAlgorithmInfo: {
      parameters: ["u32", "pointer", "u32", "u32"],
      result: "pointer",
    },
    CryptXmlEnumAlgorithmInfo: {
      parameters: ["u32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

try {
  var libinfocardapi_dll = Deno.dlopen("infocardapi.dll", {
    GetToken: {
      parameters: ["u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    ManageCardSpace: {
      parameters: [],
      result: "pointer",
    },
    ImportInformationCard: {
      parameters: ["buffer"],
      result: "pointer",
    },
    Encrypt: {
      parameters: ["pointer", "i32", "u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    Decrypt: {
      parameters: ["pointer", "i32", "u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    SignHash: {
      parameters: ["pointer", "u32", "pointer", "buffer", "pointer", "pointer"],
      result: "pointer",
    },
    VerifyHash: {
      parameters: ["pointer", "u32", "pointer", "buffer", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    GetCryptoTransform: {
      parameters: ["pointer", "u32", "i32", "u32", "i32", "u32", "pointer", "pointer"],
      result: "pointer",
    },
    GetKeyedHash: {
      parameters: ["pointer", "pointer"],
      result: "pointer",
    },
    TransformBlock: {
      parameters: ["pointer", "u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    TransformFinalBlock: {
      parameters: ["pointer", "u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    HashCore: {
      parameters: ["pointer", "u32", "pointer"],
      result: "pointer",
    },
    HashFinal: {
      parameters: ["pointer", "u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
    FreeToken: {
      parameters: ["pointer"],
      result: "i32",
    },
    CloseCryptoHandle: {
      parameters: ["pointer"],
      result: "pointer",
    },
    GenerateDerivedKey: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "u32", "u32", "buffer", "pointer", "pointer"],
      result: "pointer",
    },
    GetBrowserToken: {
      parameters: ["u32", "pointer", "pointer", "pointer"],
      result: "pointer",
    },
  }).symbols;
} catch(e) { /* ignore */ }

// Symbols

export function CryptAcquireContextA(
  phProv: Deno.PointerValue | Uint8Array /* ptr */,
  szContainer: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  szProvider: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwProvType: number /* u32 */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptAcquireContextA(util.toPointer(phProv), util.pstrToFfi(szContainer), util.pstrToFfi(szProvider), dwProvType, dwFlags));
}

export function CryptAcquireContextW(
  phProv: Deno.PointerValue | Uint8Array /* ptr */,
  szContainer: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  szProvider: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwProvType: number /* u32 */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptAcquireContextW(util.toPointer(phProv), util.pwstrToFfi(szContainer), util.pwstrToFfi(szProvider), dwProvType, dwFlags));
}

export function CryptReleaseContext(
  hProv: Deno.PointerValue /* usize */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptReleaseContext(hProv, dwFlags));
}

export function CryptGenKey(
  hProv: Deno.PointerValue /* usize */,
  Algid: number /* u32 */,
  dwFlags: CRYPT_KEY_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_KEY_FLAGS */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGenKey(hProv, Algid, dwFlags, util.toPointer(phKey)));
}

export function CryptDeriveKey(
  hProv: Deno.PointerValue /* usize */,
  Algid: number /* u32 */,
  hBaseData: Deno.PointerValue /* usize */,
  dwFlags: number /* u32 */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptDeriveKey(hProv, Algid, hBaseData, dwFlags, util.toPointer(phKey)));
}

export function CryptDestroyKey(
  hKey: Deno.PointerValue /* usize */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptDestroyKey(hKey));
}

export function CryptSetKeyParam(
  hKey: Deno.PointerValue /* usize */,
  dwParam: CRYPT_KEY_PARAM_ID /* Windows.Win32.Security.Cryptography.CRYPT_KEY_PARAM_ID */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSetKeyParam(hKey, dwParam, util.toPointer(pbData), dwFlags));
}

export function CryptGetKeyParam(
  hKey: Deno.PointerValue /* usize */,
  dwParam: CRYPT_KEY_PARAM_ID /* Windows.Win32.Security.Cryptography.CRYPT_KEY_PARAM_ID */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  pdwDataLen: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGetKeyParam(hKey, dwParam, util.toPointer(pbData), util.toPointer(pdwDataLen), dwFlags));
}

export function CryptSetHashParam(
  hHash: Deno.PointerValue /* usize */,
  dwParam: CRYPT_SET_HASH_PARAM /* Windows.Win32.Security.Cryptography.CRYPT_SET_HASH_PARAM */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSetHashParam(hHash, dwParam, util.toPointer(pbData), dwFlags));
}

export function CryptGetHashParam(
  hHash: Deno.PointerValue /* usize */,
  dwParam: number /* u32 */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  pdwDataLen: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGetHashParam(hHash, dwParam, util.toPointer(pbData), util.toPointer(pdwDataLen), dwFlags));
}

export function CryptSetProvParam(
  hProv: Deno.PointerValue /* usize */,
  dwParam: CRYPT_SET_PROV_PARAM_ID /* Windows.Win32.Security.Cryptography.CRYPT_SET_PROV_PARAM_ID */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSetProvParam(hProv, dwParam, util.toPointer(pbData), dwFlags));
}

export function CryptGetProvParam(
  hProv: Deno.PointerValue /* usize */,
  dwParam: number /* u32 */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  pdwDataLen: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGetProvParam(hProv, dwParam, util.toPointer(pbData), util.toPointer(pdwDataLen), dwFlags));
}

export function CryptGenRandom(
  hProv: Deno.PointerValue /* usize */,
  dwLen: number /* u32 */,
  pbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGenRandom(hProv, dwLen, util.toPointer(pbBuffer)));
}

export function CryptGetUserKey(
  hProv: Deno.PointerValue /* usize */,
  dwKeySpec: number /* u32 */,
  phUserKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGetUserKey(hProv, dwKeySpec, util.toPointer(phUserKey)));
}

export function CryptExportKey(
  hKey: Deno.PointerValue /* usize */,
  hExpKey: Deno.PointerValue /* usize */,
  dwBlobType: number /* u32 */,
  dwFlags: CRYPT_KEY_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_KEY_FLAGS */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  pdwDataLen: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptExportKey(hKey, hExpKey, dwBlobType, dwFlags, util.toPointer(pbData), util.toPointer(pdwDataLen)));
}

export function CryptImportKey(
  hProv: Deno.PointerValue /* usize */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  dwDataLen: number /* u32 */,
  hPubKey: Deno.PointerValue /* usize */,
  dwFlags: CRYPT_KEY_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_KEY_FLAGS */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptImportKey(hProv, util.toPointer(pbData), dwDataLen, hPubKey, dwFlags, util.toPointer(phKey)));
}

export function CryptEncrypt(
  hKey: Deno.PointerValue /* usize */,
  hHash: Deno.PointerValue /* usize */,
  Final: boolean /* Windows.Win32.Foundation.BOOL */,
  dwFlags: number /* u32 */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  pdwDataLen: Deno.PointerValue | Uint8Array /* ptr */,
  dwBufLen: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptEncrypt(hKey, hHash, util.boolToFfi(Final), dwFlags, util.toPointer(pbData), util.toPointer(pdwDataLen), dwBufLen));
}

export function CryptDecrypt(
  hKey: Deno.PointerValue /* usize */,
  hHash: Deno.PointerValue /* usize */,
  Final: boolean /* Windows.Win32.Foundation.BOOL */,
  dwFlags: number /* u32 */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  pdwDataLen: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptDecrypt(hKey, hHash, util.boolToFfi(Final), dwFlags, util.toPointer(pbData), util.toPointer(pdwDataLen)));
}

export function CryptCreateHash(
  hProv: Deno.PointerValue /* usize */,
  Algid: number /* u32 */,
  hKey: Deno.PointerValue /* usize */,
  dwFlags: number /* u32 */,
  phHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptCreateHash(hProv, Algid, hKey, dwFlags, util.toPointer(phHash)));
}

export function CryptHashData(
  hHash: Deno.PointerValue /* usize */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  dwDataLen: number /* u32 */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptHashData(hHash, util.toPointer(pbData), dwDataLen, dwFlags));
}

export function CryptHashSessionKey(
  hHash: Deno.PointerValue /* usize */,
  hKey: Deno.PointerValue /* usize */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptHashSessionKey(hHash, hKey, dwFlags));
}

export function CryptDestroyHash(
  hHash: Deno.PointerValue /* usize */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptDestroyHash(hHash));
}

export function CryptSignHashA(
  hHash: Deno.PointerValue /* usize */,
  dwKeySpec: number /* u32 */,
  szDescription: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  pdwSigLen: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSignHashA(hHash, dwKeySpec, util.pstrToFfi(szDescription), dwFlags, util.toPointer(pbSignature), util.toPointer(pdwSigLen)));
}

export function CryptSignHashW(
  hHash: Deno.PointerValue /* usize */,
  dwKeySpec: number /* u32 */,
  szDescription: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  pdwSigLen: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSignHashW(hHash, dwKeySpec, util.pwstrToFfi(szDescription), dwFlags, util.toPointer(pbSignature), util.toPointer(pdwSigLen)));
}

export function CryptVerifySignatureA(
  hHash: Deno.PointerValue /* usize */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  dwSigLen: number /* u32 */,
  hPubKey: Deno.PointerValue /* usize */,
  szDescription: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptVerifySignatureA(hHash, util.toPointer(pbSignature), dwSigLen, hPubKey, util.pstrToFfi(szDescription), dwFlags));
}

export function CryptVerifySignatureW(
  hHash: Deno.PointerValue /* usize */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  dwSigLen: number /* u32 */,
  hPubKey: Deno.PointerValue /* usize */,
  szDescription: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptVerifySignatureW(hHash, util.toPointer(pbSignature), dwSigLen, hPubKey, util.pwstrToFfi(szDescription), dwFlags));
}

export function CryptSetProviderA(
  pszProvName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwProvType: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSetProviderA(util.pstrToFfi(pszProvName), dwProvType));
}

export function CryptSetProviderW(
  pszProvName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwProvType: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSetProviderW(util.pwstrToFfi(pszProvName), dwProvType));
}

export function CryptSetProviderExA(
  pszProvName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwProvType: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSetProviderExA(util.pstrToFfi(pszProvName), dwProvType, util.toPointer(pdwReserved), dwFlags));
}

export function CryptSetProviderExW(
  pszProvName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwProvType: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptSetProviderExW(util.pwstrToFfi(pszProvName), dwProvType, util.toPointer(pdwReserved), dwFlags));
}

export function CryptGetDefaultProviderA(
  dwProvType: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pszProvName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pcbProvName: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGetDefaultProviderA(dwProvType, util.toPointer(pdwReserved), dwFlags, util.pstrToFfi(pszProvName), util.toPointer(pcbProvName)));
}

export function CryptGetDefaultProviderW(
  dwProvType: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pszProvName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbProvName: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptGetDefaultProviderW(dwProvType, util.toPointer(pdwReserved), dwFlags, util.pwstrToFfi(pszProvName), util.toPointer(pcbProvName)));
}

export function CryptEnumProviderTypesA(
  dwIndex: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pdwProvType: Deno.PointerValue | Uint8Array /* ptr */,
  szTypeName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pcbTypeName: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptEnumProviderTypesA(dwIndex, util.toPointer(pdwReserved), dwFlags, util.toPointer(pdwProvType), util.pstrToFfi(szTypeName), util.toPointer(pcbTypeName)));
}

export function CryptEnumProviderTypesW(
  dwIndex: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pdwProvType: Deno.PointerValue | Uint8Array /* ptr */,
  szTypeName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbTypeName: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptEnumProviderTypesW(dwIndex, util.toPointer(pdwReserved), dwFlags, util.toPointer(pdwProvType), util.pwstrToFfi(szTypeName), util.toPointer(pcbTypeName)));
}

export function CryptEnumProvidersA(
  dwIndex: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pdwProvType: Deno.PointerValue | Uint8Array /* ptr */,
  szProvName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pcbProvName: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptEnumProvidersA(dwIndex, util.toPointer(pdwReserved), dwFlags, util.toPointer(pdwProvType), util.pstrToFfi(szProvName), util.toPointer(pcbProvName)));
}

export function CryptEnumProvidersW(
  dwIndex: number /* u32 */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pdwProvType: Deno.PointerValue | Uint8Array /* ptr */,
  szProvName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbProvName: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptEnumProvidersW(dwIndex, util.toPointer(pdwReserved), dwFlags, util.toPointer(pdwProvType), util.pwstrToFfi(szProvName), util.toPointer(pcbProvName)));
}

export function CryptContextAddRef(
  hProv: Deno.PointerValue /* usize */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptContextAddRef(hProv, util.toPointer(pdwReserved), dwFlags));
}

export function CryptDuplicateKey(
  hKey: Deno.PointerValue /* usize */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptDuplicateKey(hKey, util.toPointer(pdwReserved), dwFlags, util.toPointer(phKey)));
}

export function CryptDuplicateHash(
  hHash: Deno.PointerValue /* usize */,
  pdwReserved: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  phHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libADVAPI32_dll.CryptDuplicateHash(hHash, util.toPointer(pdwReserved), dwFlags, util.toPointer(phHash)));
}

export function BCryptOpenAlgorithmProvider(
  phAlgorithm: Deno.PointerValue | Uint8Array /* ptr */,
  pszAlgId: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pszImplementation: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS /* Windows.Win32.Security.Cryptography.BCRYPT_OPEN_ALGORITHM_PROVIDER_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptOpenAlgorithmProvider(util.toPointer(phAlgorithm), util.pwstrToFfi(pszAlgId), util.pwstrToFfi(pszImplementation), dwFlags);
}

export function BCryptEnumAlgorithms(
  dwAlgOperations: BCRYPT_OPERATION /* Windows.Win32.Security.Cryptography.BCRYPT_OPERATION */,
  pAlgCount: Deno.PointerValue | Uint8Array /* ptr */,
  ppAlgList: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptEnumAlgorithms(dwAlgOperations, util.toPointer(pAlgCount), util.toPointer(ppAlgList), dwFlags);
}

export function BCryptEnumProviders(
  pszAlgId: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pImplCount: Deno.PointerValue | Uint8Array /* ptr */,
  ppImplList: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptEnumProviders(util.pwstrToFfi(pszAlgId), util.toPointer(pImplCount), util.toPointer(ppImplList), dwFlags);
}

export function BCryptGetProperty(
  hObject: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HANDLE */,
  pszProperty: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptGetProperty(util.toPointer(hObject), util.pwstrToFfi(pszProperty), util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function BCryptSetProperty(
  hObject: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HANDLE */,
  pszProperty: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptSetProperty(util.toPointer(hObject), util.pwstrToFfi(pszProperty), util.toPointer(pbInput), cbInput, dwFlags);
}

export function BCryptCloseAlgorithmProvider(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptCloseAlgorithmProvider(util.toPointer(hAlgorithm), dwFlags);
}

export function BCryptFreeBuffer(
  pvBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): void /* void */ {
  return libbcrypt_dll.BCryptFreeBuffer(util.toPointer(pvBuffer));
}

export function BCryptGenerateSymmetricKey(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  pbKeyObject: Deno.PointerValue | Uint8Array /* ptr */,
  cbKeyObject: number /* u32 */,
  pbSecret: Deno.PointerValue | Uint8Array /* ptr */,
  cbSecret: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptGenerateSymmetricKey(util.toPointer(hAlgorithm), util.toPointer(phKey), util.toPointer(pbKeyObject), cbKeyObject, util.toPointer(pbSecret), cbSecret, dwFlags);
}

export function BCryptGenerateKeyPair(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  dwLength: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptGenerateKeyPair(util.toPointer(hAlgorithm), util.toPointer(phKey), dwLength, dwFlags);
}

export function BCryptEncrypt(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbIV: Deno.PointerValue | Uint8Array /* ptr */,
  cbIV: number /* u32 */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptEncrypt(util.toPointer(hKey), util.toPointer(pbInput), cbInput, util.toPointer(pPaddingInfo), util.toPointer(pbIV), cbIV, util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function BCryptDecrypt(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbIV: Deno.PointerValue | Uint8Array /* ptr */,
  cbIV: number /* u32 */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDecrypt(util.toPointer(hKey), util.toPointer(pbInput), cbInput, util.toPointer(pPaddingInfo), util.toPointer(pbIV), cbIV, util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function BCryptExportKey(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  hExportKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pszBlobType: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptExportKey(util.toPointer(hKey), util.toPointer(hExportKey), util.pwstrToFfi(pszBlobType), util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function BCryptImportKey(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  hImportKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pszBlobType: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  pbKeyObject: Deno.PointerValue | Uint8Array /* ptr */,
  cbKeyObject: number /* u32 */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptImportKey(util.toPointer(hAlgorithm), util.toPointer(hImportKey), util.pwstrToFfi(pszBlobType), util.toPointer(phKey), util.toPointer(pbKeyObject), cbKeyObject, util.toPointer(pbInput), cbInput, dwFlags);
}

export function BCryptImportKeyPair(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  hImportKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pszBlobType: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptImportKeyPair(util.toPointer(hAlgorithm), util.toPointer(hImportKey), util.pwstrToFfi(pszBlobType), util.toPointer(phKey), util.toPointer(pbInput), cbInput, dwFlags);
}

export function BCryptDuplicateKey(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  phNewKey: Deno.PointerValue | Uint8Array /* ptr */,
  pbKeyObject: Deno.PointerValue | Uint8Array /* ptr */,
  cbKeyObject: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDuplicateKey(util.toPointer(hKey), util.toPointer(phNewKey), util.toPointer(pbKeyObject), cbKeyObject, dwFlags);
}

export function BCryptFinalizeKeyPair(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptFinalizeKeyPair(util.toPointer(hKey), dwFlags);
}

export function BCryptDestroyKey(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDestroyKey(util.toPointer(hKey));
}

export function BCryptDestroySecret(
  hSecret: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_SECRET_HANDLE */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDestroySecret(util.toPointer(hSecret));
}

export function BCryptSignHash(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptSignHash(util.toPointer(hKey), util.toPointer(pPaddingInfo), util.toPointer(pbInput), cbInput, util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function BCryptVerifySignature(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbHash: Deno.PointerValue | Uint8Array /* ptr */,
  cbHash: number /* u32 */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignature: number /* u32 */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptVerifySignature(util.toPointer(hKey), util.toPointer(pPaddingInfo), util.toPointer(pbHash), cbHash, util.toPointer(pbSignature), cbSignature, dwFlags);
}

export function BCryptSecretAgreement(
  hPrivKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  hPubKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  phAgreedSecret: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptSecretAgreement(util.toPointer(hPrivKey), util.toPointer(hPubKey), util.toPointer(phAgreedSecret), dwFlags);
}

export function BCryptDeriveKey(
  hSharedSecret: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_SECRET_HANDLE */,
  pwszKDF: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  pbDerivedKey: Deno.PointerValue | Uint8Array /* ptr */,
  cbDerivedKey: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDeriveKey(util.toPointer(hSharedSecret), util.pwstrToFfi(pwszKDF), util.toPointer(pParameterList), util.toPointer(pbDerivedKey), cbDerivedKey, util.toPointer(pcbResult), dwFlags);
}

export function BCryptKeyDerivation(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  pbDerivedKey: Deno.PointerValue | Uint8Array /* ptr */,
  cbDerivedKey: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptKeyDerivation(util.toPointer(hKey), util.toPointer(pParameterList), util.toPointer(pbDerivedKey), cbDerivedKey, util.toPointer(pcbResult), dwFlags);
}

export function BCryptCreateHash(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  phHash: Deno.PointerValue | Uint8Array /* ptr */,
  pbHashObject: Deno.PointerValue | Uint8Array /* ptr */,
  cbHashObject: number /* u32 */,
  pbSecret: Deno.PointerValue | Uint8Array /* ptr */,
  cbSecret: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptCreateHash(util.toPointer(hAlgorithm), util.toPointer(phHash), util.toPointer(pbHashObject), cbHashObject, util.toPointer(pbSecret), cbSecret, dwFlags);
}

export function BCryptHashData(
  hHash: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HASH_HANDLE */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptHashData(util.toPointer(hHash), util.toPointer(pbInput), cbInput, dwFlags);
}

export function BCryptFinishHash(
  hHash: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HASH_HANDLE */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptFinishHash(util.toPointer(hHash), util.toPointer(pbOutput), cbOutput, dwFlags);
}

export function BCryptCreateMultiHash(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  phHash: Deno.PointerValue | Uint8Array /* ptr */,
  nHashes: number /* u32 */,
  pbHashObject: Deno.PointerValue | Uint8Array /* ptr */,
  cbHashObject: number /* u32 */,
  pbSecret: Deno.PointerValue | Uint8Array /* ptr */,
  cbSecret: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptCreateMultiHash(util.toPointer(hAlgorithm), util.toPointer(phHash), nHashes, util.toPointer(pbHashObject), cbHashObject, util.toPointer(pbSecret), cbSecret, dwFlags);
}

export function BCryptProcessMultiOperations(
  hObject: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HANDLE */,
  operationType: BCRYPT_MULTI_OPERATION_TYPE /* Windows.Win32.Security.Cryptography.BCRYPT_MULTI_OPERATION_TYPE */,
  pOperations: Deno.PointerValue | Uint8Array /* ptr */,
  cbOperations: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptProcessMultiOperations(util.toPointer(hObject), operationType, util.toPointer(pOperations), cbOperations, dwFlags);
}

export function BCryptDuplicateHash(
  hHash: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HASH_HANDLE */,
  phNewHash: Deno.PointerValue | Uint8Array /* ptr */,
  pbHashObject: Deno.PointerValue | Uint8Array /* ptr */,
  cbHashObject: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDuplicateHash(util.toPointer(hHash), util.toPointer(phNewHash), util.toPointer(pbHashObject), cbHashObject, dwFlags);
}

export function BCryptDestroyHash(
  hHash: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HASH_HANDLE */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDestroyHash(util.toPointer(hHash));
}

export function BCryptHash(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  pbSecret: Deno.PointerValue | Uint8Array /* ptr */,
  cbSecret: number /* u32 */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptHash(util.toPointer(hAlgorithm), util.toPointer(pbSecret), cbSecret, util.toPointer(pbInput), cbInput, util.toPointer(pbOutput), cbOutput);
}

export function BCryptGenRandom(
  hAlgorithm: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  pbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  cbBuffer: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptGenRandom(util.toPointer(hAlgorithm), util.toPointer(pbBuffer), cbBuffer, dwFlags);
}

export function BCryptDeriveKeyCapi(
  hHash: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_HASH_HANDLE */,
  hTargetAlg: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  pbDerivedKey: Deno.PointerValue | Uint8Array /* ptr */,
  cbDerivedKey: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDeriveKeyCapi(util.toPointer(hHash), util.toPointer(hTargetAlg), util.toPointer(pbDerivedKey), cbDerivedKey, dwFlags);
}

export function BCryptDeriveKeyPBKDF2(
  hPrf: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_ALG_HANDLE */,
  pbPassword: Deno.PointerValue | Uint8Array /* ptr */,
  cbPassword: number /* u32 */,
  pbSalt: Deno.PointerValue | Uint8Array /* ptr */,
  cbSalt: number /* u32 */,
  cIterations: Deno.PointerValue /* u64 */,
  pbDerivedKey: Deno.PointerValue | Uint8Array /* ptr */,
  cbDerivedKey: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDeriveKeyPBKDF2(util.toPointer(hPrf), util.toPointer(pbPassword), cbPassword, util.toPointer(pbSalt), cbSalt, cIterations, util.toPointer(pbDerivedKey), cbDerivedKey, dwFlags);
}

export function BCryptQueryProviderRegistration(
  pszProvider: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwMode: BCRYPT_QUERY_PROVIDER_MODE /* Windows.Win32.Security.Cryptography.BCRYPT_QUERY_PROVIDER_MODE */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptQueryProviderRegistration(util.pwstrToFfi(pszProvider), dwMode, dwInterface, util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptEnumRegisteredProviders(
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptEnumRegisteredProviders(util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptCreateContext(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pConfig: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptCreateContext(dwTable, util.pwstrToFfi(pszContext), util.toPointer(pConfig));
}

export function BCryptDeleteContext(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptDeleteContext(dwTable, util.pwstrToFfi(pszContext));
}

export function BCryptEnumContexts(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptEnumContexts(dwTable, util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptConfigureContext(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pConfig: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptConfigureContext(dwTable, util.pwstrToFfi(pszContext), util.toPointer(pConfig));
}

export function BCryptQueryContextConfiguration(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptQueryContextConfiguration(dwTable, util.pwstrToFfi(pszContext), util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptAddContextFunction(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwPosition: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptAddContextFunction(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction), dwPosition);
}

export function BCryptRemoveContextFunction(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptRemoveContextFunction(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction));
}

export function BCryptEnumContextFunctions(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptEnumContextFunctions(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptConfigureContextFunction(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pConfig: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptConfigureContextFunction(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction), util.toPointer(pConfig));
}

export function BCryptQueryContextFunctionConfiguration(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptQueryContextFunctionConfiguration(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction), util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptEnumContextFunctionProviders(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptEnumContextFunctionProviders(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction), util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptSetContextFunctionProperty(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pszProperty: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  cbValue: number /* u32 */,
  pbValue: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptSetContextFunctionProperty(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction), util.pwstrToFfi(pszProperty), cbValue, util.toPointer(pbValue));
}

export function BCryptQueryContextFunctionProperty(
  dwTable: BCRYPT_TABLE /* Windows.Win32.Security.Cryptography.BCRYPT_TABLE */,
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: BCRYPT_INTERFACE /* Windows.Win32.Security.Cryptography.BCRYPT_INTERFACE */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pszProperty: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbValue: Deno.PointerValue | Uint8Array /* ptr */,
  ppbValue: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptQueryContextFunctionProperty(dwTable, util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction), util.pwstrToFfi(pszProperty), util.toPointer(pcbValue), util.toPointer(ppbValue));
}

export function BCryptRegisterConfigChangeNotify(
  phEvent: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptRegisterConfigChangeNotify(util.toPointer(phEvent));
}

export function BCryptUnregisterConfigChangeNotify(
  hEvent: Uint8Array | Deno.PointerValue /* Windows.Win32.Foundation.HANDLE */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptUnregisterConfigChangeNotify(util.toPointer(hEvent));
}

export function BCryptResolveProviders(
  pszContext: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwInterface: number /* u32 */,
  pszFunction: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pszProvider: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwMode: BCRYPT_QUERY_PROVIDER_MODE /* Windows.Win32.Security.Cryptography.BCRYPT_QUERY_PROVIDER_MODE */,
  dwFlags: BCRYPT_RESOLVE_PROVIDERS_FLAGS /* Windows.Win32.Security.Cryptography.BCRYPT_RESOLVE_PROVIDERS_FLAGS */,
  pcbBuffer: Deno.PointerValue | Uint8Array /* ptr */,
  ppBuffer: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptResolveProviders(util.pwstrToFfi(pszContext), dwInterface, util.pwstrToFfi(pszFunction), util.pwstrToFfi(pszProvider), dwMode, dwFlags, util.toPointer(pcbBuffer), util.toPointer(ppBuffer));
}

export function BCryptGetFipsAlgorithmMode(
  pfEnabled: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.NTSTATUS */ {
  return libbcrypt_dll.BCryptGetFipsAlgorithmMode(util.toPointer(pfEnabled));
}

export function NCryptOpenStorageProvider(
  phProvider: Deno.PointerValue | Uint8Array /* ptr */,
  pszProviderName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptOpenStorageProvider(util.toPointer(phProvider), util.pwstrToFfi(pszProviderName), dwFlags);
}

export function NCryptEnumAlgorithms(
  hProvider: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_PROV_HANDLE */,
  dwAlgOperations: NCRYPT_OPERATION /* Windows.Win32.Security.Cryptography.NCRYPT_OPERATION */,
  pdwAlgCount: Deno.PointerValue | Uint8Array /* ptr */,
  ppAlgList: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptEnumAlgorithms(util.toPointer(hProvider), dwAlgOperations, util.toPointer(pdwAlgCount), util.toPointer(ppAlgList), dwFlags);
}

export function NCryptIsAlgSupported(
  hProvider: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_PROV_HANDLE */,
  pszAlgId: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptIsAlgSupported(util.toPointer(hProvider), util.pwstrToFfi(pszAlgId), dwFlags);
}

export function NCryptEnumKeys(
  hProvider: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_PROV_HANDLE */,
  pszScope: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  ppKeyName: Deno.PointerValue | Uint8Array /* ptr */,
  ppEnumState: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptEnumKeys(util.toPointer(hProvider), util.pwstrToFfi(pszScope), util.toPointer(ppKeyName), util.toPointer(ppEnumState), dwFlags);
}

export function NCryptEnumStorageProviders(
  pdwProviderCount: Deno.PointerValue | Uint8Array /* ptr */,
  ppProviderList: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptEnumStorageProviders(util.toPointer(pdwProviderCount), util.toPointer(ppProviderList), dwFlags);
}

export function NCryptFreeBuffer(
  pvInput: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptFreeBuffer(util.toPointer(pvInput));
}

export function NCryptOpenKey(
  hProvider: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_PROV_HANDLE */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  pszKeyName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwLegacyKeySpec: CERT_KEY_SPEC /* Windows.Win32.Security.Cryptography.CERT_KEY_SPEC */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptOpenKey(util.toPointer(hProvider), util.toPointer(phKey), util.pwstrToFfi(pszKeyName), dwLegacyKeySpec, dwFlags);
}

export function NCryptCreatePersistedKey(
  hProvider: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_PROV_HANDLE */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  pszAlgId: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pszKeyName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwLegacyKeySpec: CERT_KEY_SPEC /* Windows.Win32.Security.Cryptography.CERT_KEY_SPEC */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptCreatePersistedKey(util.toPointer(hProvider), util.toPointer(phKey), util.pwstrToFfi(pszAlgId), util.pwstrToFfi(pszKeyName), dwLegacyKeySpec, dwFlags);
}

export function NCryptGetProperty(
  hObject: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_HANDLE */,
  pszProperty: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: OBJECT_SECURITY_INFORMATION /* Windows.Win32.Security.OBJECT_SECURITY_INFORMATION */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptGetProperty(util.toPointer(hObject), util.pwstrToFfi(pszProperty), util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function NCryptSetProperty(
  hObject: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_HANDLE */,
  pszProperty: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptSetProperty(util.toPointer(hObject), util.pwstrToFfi(pszProperty), util.toPointer(pbInput), cbInput, dwFlags);
}

export function NCryptFinalizeKey(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptFinalizeKey(util.toPointer(hKey), dwFlags);
}

export function NCryptEncrypt(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptEncrypt(util.toPointer(hKey), util.toPointer(pbInput), cbInput, util.toPointer(pPaddingInfo), util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function NCryptDecrypt(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  pbInput: Deno.PointerValue | Uint8Array /* ptr */,
  cbInput: number /* u32 */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptDecrypt(util.toPointer(hKey), util.toPointer(pbInput), cbInput, util.toPointer(pPaddingInfo), util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function NCryptImportKey(
  hProvider: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_PROV_HANDLE */,
  hImportKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  pszBlobType: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  cbData: number /* u32 */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptImportKey(util.toPointer(hProvider), util.toPointer(hImportKey), util.pwstrToFfi(pszBlobType), util.toPointer(pParameterList), util.toPointer(phKey), util.toPointer(pbData), cbData, dwFlags);
}

export function NCryptExportKey(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  hExportKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  pszBlobType: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  pbOutput: Deno.PointerValue | Uint8Array /* ptr */,
  cbOutput: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptExportKey(util.toPointer(hKey), util.toPointer(hExportKey), util.pwstrToFfi(pszBlobType), util.toPointer(pParameterList), util.toPointer(pbOutput), cbOutput, util.toPointer(pcbResult), dwFlags);
}

export function NCryptSignHash(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbHashValue: Deno.PointerValue | Uint8Array /* ptr */,
  cbHashValue: number /* u32 */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignature: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptSignHash(util.toPointer(hKey), util.toPointer(pPaddingInfo), util.toPointer(pbHashValue), cbHashValue, util.toPointer(pbSignature), cbSignature, util.toPointer(pcbResult), dwFlags);
}

export function NCryptVerifySignature(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  pPaddingInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbHashValue: Deno.PointerValue | Uint8Array /* ptr */,
  cbHashValue: number /* u32 */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignature: number /* u32 */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptVerifySignature(util.toPointer(hKey), util.toPointer(pPaddingInfo), util.toPointer(pbHashValue), cbHashValue, util.toPointer(pbSignature), cbSignature, dwFlags);
}

export function NCryptDeleteKey(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptDeleteKey(util.toPointer(hKey), dwFlags);
}

export function NCryptFreeObject(
  hObject: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_HANDLE */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptFreeObject(util.toPointer(hObject));
}

export function NCryptIsKeyHandle(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libncrypt_dll.NCryptIsKeyHandle(util.toPointer(hKey)));
}

export function NCryptTranslateHandle(
  phProvider: Deno.PointerValue | Uint8Array /* ptr */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
  hLegacyProv: Deno.PointerValue /* usize */,
  hLegacyKey: Deno.PointerValue /* usize */,
  dwLegacyKeySpec: CERT_KEY_SPEC /* Windows.Win32.Security.Cryptography.CERT_KEY_SPEC */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptTranslateHandle(util.toPointer(phProvider), util.toPointer(phKey), hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags);
}

export function NCryptNotifyChangeKey(
  hProvider: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_PROV_HANDLE */,
  phEvent: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptNotifyChangeKey(util.toPointer(hProvider), util.toPointer(phEvent), dwFlags);
}

export function NCryptSecretAgreement(
  hPrivKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  hPubKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  phAgreedSecret: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptSecretAgreement(util.toPointer(hPrivKey), util.toPointer(hPubKey), util.toPointer(phAgreedSecret), dwFlags);
}

export function NCryptDeriveKey(
  hSharedSecret: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_SECRET_HANDLE */,
  pwszKDF: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  pbDerivedKey: Deno.PointerValue | Uint8Array /* ptr */,
  cbDerivedKey: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptDeriveKey(util.toPointer(hSharedSecret), util.pwstrToFfi(pwszKDF), util.toPointer(pParameterList), util.toPointer(pbDerivedKey), cbDerivedKey, util.toPointer(pcbResult), dwFlags);
}

export function NCryptKeyDerivation(
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  pbDerivedKey: Deno.PointerValue | Uint8Array /* ptr */,
  cbDerivedKey: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptKeyDerivation(util.toPointer(hKey), util.toPointer(pParameterList), util.toPointer(pbDerivedKey), cbDerivedKey, util.toPointer(pcbResult), dwFlags);
}

export function NCryptCreateClaim(
  hSubjectKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  hAuthorityKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  dwClaimType: number /* u32 */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  pbClaimBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbClaimBlob: number /* u32 */,
  pcbResult: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptCreateClaim(util.toPointer(hSubjectKey), util.toPointer(hAuthorityKey), dwClaimType, util.toPointer(pParameterList), util.toPointer(pbClaimBlob), cbClaimBlob, util.toPointer(pcbResult), dwFlags);
}

export function NCryptVerifyClaim(
  hSubjectKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  hAuthorityKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.NCRYPT_KEY_HANDLE */,
  dwClaimType: number /* u32 */,
  pParameterList: Deno.PointerValue | Uint8Array /* ptr */,
  pbClaimBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbClaimBlob: number /* u32 */,
  pOutput: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptVerifyClaim(util.toPointer(hSubjectKey), util.toPointer(hAuthorityKey), dwClaimType, util.toPointer(pParameterList), util.toPointer(pbClaimBlob), cbClaimBlob, util.toPointer(pOutput), dwFlags);
}

export function CryptFormatObject(
  dwCertEncodingType: number /* u32 */,
  dwFormatType: number /* u32 */,
  dwFormatStrType: number /* u32 */,
  pFormatStruct: Deno.PointerValue | Uint8Array /* ptr */,
  lpszStructType: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  pbFormat: Deno.PointerValue | Uint8Array /* ptr */,
  pcbFormat: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptFormatObject(dwCertEncodingType, dwFormatType, dwFormatStrType, util.toPointer(pFormatStruct), util.pstrToFfi(lpszStructType), util.toPointer(pbEncoded), cbEncoded, util.toPointer(pbFormat), util.toPointer(pcbFormat)));
}

export function CryptEncodeObjectEx(
  dwCertEncodingType: CERT_QUERY_ENCODING_TYPE /* Windows.Win32.Security.Cryptography.CERT_QUERY_ENCODING_TYPE */,
  lpszStructType: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pvStructInfo: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_ENCODE_OBJECT_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_ENCODE_OBJECT_FLAGS */,
  pEncodePara: Deno.PointerValue | Uint8Array /* ptr */,
  pvEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptEncodeObjectEx(dwCertEncodingType, util.pstrToFfi(lpszStructType), util.toPointer(pvStructInfo), dwFlags, util.toPointer(pEncodePara), util.toPointer(pvEncoded), util.toPointer(pcbEncoded)));
}

export function CryptEncodeObject(
  dwCertEncodingType: number /* u32 */,
  lpszStructType: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pvStructInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptEncodeObject(dwCertEncodingType, util.pstrToFfi(lpszStructType), util.toPointer(pvStructInfo), util.toPointer(pbEncoded), util.toPointer(pcbEncoded)));
}

export function CryptDecodeObjectEx(
  dwCertEncodingType: number /* u32 */,
  lpszStructType: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  dwFlags: number /* u32 */,
  pDecodePara: Deno.PointerValue | Uint8Array /* ptr */,
  pvStructInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pcbStructInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptDecodeObjectEx(dwCertEncodingType, util.pstrToFfi(lpszStructType), util.toPointer(pbEncoded), cbEncoded, dwFlags, util.toPointer(pDecodePara), util.toPointer(pvStructInfo), util.toPointer(pcbStructInfo)));
}

export function CryptDecodeObject(
  dwCertEncodingType: number /* u32 */,
  lpszStructType: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  dwFlags: number /* u32 */,
  pvStructInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pcbStructInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptDecodeObject(dwCertEncodingType, util.pstrToFfi(lpszStructType), util.toPointer(pbEncoded), cbEncoded, dwFlags, util.toPointer(pvStructInfo), util.toPointer(pcbStructInfo)));
}

export function CryptInstallOIDFunctionAddress(
  hModule: Uint8Array | Deno.PointerValue /* Windows.Win32.Foundation.HINSTANCE */,
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  cFuncEntry: number /* u32 */,
  rgFuncEntry: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptInstallOIDFunctionAddress(util.toPointer(hModule), dwEncodingType, util.pstrToFfi(pszFuncName), cFuncEntry, util.toPointer(rgFuncEntry), dwFlags));
}

export function CryptInitOIDFunctionSet(
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CryptInitOIDFunctionSet(util.pstrToFfi(pszFuncName), dwFlags);
}

export function CryptGetOIDFunctionAddress(
  hFuncSet: Deno.PointerValue | Uint8Array /* ptr */,
  dwEncodingType: number /* u32 */,
  pszOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
  ppvFuncAddr: Deno.PointerValue | Uint8Array /* ptr */,
  phFuncAddr: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptGetOIDFunctionAddress(util.toPointer(hFuncSet), dwEncodingType, util.pstrToFfi(pszOID), dwFlags, util.toPointer(ppvFuncAddr), util.toPointer(phFuncAddr)));
}

export function CryptGetDefaultOIDDllList(
  hFuncSet: Deno.PointerValue | Uint8Array /* ptr */,
  dwEncodingType: number /* u32 */,
  pwszDllList: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcchDllList: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptGetDefaultOIDDllList(util.toPointer(hFuncSet), dwEncodingType, util.pwstrToFfi(pwszDllList), util.toPointer(pcchDllList)));
}

export function CryptGetDefaultOIDFunctionAddress(
  hFuncSet: Deno.PointerValue | Uint8Array /* ptr */,
  dwEncodingType: number /* u32 */,
  pwszDll: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
  ppvFuncAddr: Deno.PointerValue | Uint8Array /* ptr */,
  phFuncAddr: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptGetDefaultOIDFunctionAddress(util.toPointer(hFuncSet), dwEncodingType, util.pwstrToFfi(pwszDll), dwFlags, util.toPointer(ppvFuncAddr), util.toPointer(phFuncAddr)));
}

export function CryptFreeOIDFunctionAddress(
  hFuncAddr: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptFreeOIDFunctionAddress(util.toPointer(hFuncAddr), dwFlags));
}

export function CryptRegisterOIDFunction(
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pszOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pwszDll: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pszOverrideFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptRegisterOIDFunction(dwEncodingType, util.pstrToFfi(pszFuncName), util.pstrToFfi(pszOID), util.pwstrToFfi(pwszDll), util.pstrToFfi(pszOverrideFuncName)));
}

export function CryptUnregisterOIDFunction(
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pszOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptUnregisterOIDFunction(dwEncodingType, util.pstrToFfi(pszFuncName), util.pstrToFfi(pszOID)));
}

export function CryptRegisterDefaultOIDFunction(
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwIndex: number /* u32 */,
  pwszDll: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptRegisterDefaultOIDFunction(dwEncodingType, util.pstrToFfi(pszFuncName), dwIndex, util.pwstrToFfi(pwszDll)));
}

export function CryptUnregisterDefaultOIDFunction(
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pwszDll: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptUnregisterDefaultOIDFunction(dwEncodingType, util.pstrToFfi(pszFuncName), util.pwstrToFfi(pwszDll)));
}

export function CryptSetOIDFunctionValue(
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pszOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pwszValueName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwValueType: REG_VALUE_TYPE /* Windows.Win32.System.Registry.REG_VALUE_TYPE */,
  pbValueData: Deno.PointerValue | Uint8Array /* ptr */,
  cbValueData: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSetOIDFunctionValue(dwEncodingType, util.pstrToFfi(pszFuncName), util.pstrToFfi(pszOID), util.pwstrToFfi(pwszValueName), dwValueType, util.toPointer(pbValueData), cbValueData));
}

export function CryptGetOIDFunctionValue(
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pszOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pwszValueName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pdwValueType: Deno.PointerValue | Uint8Array /* ptr */,
  pbValueData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbValueData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptGetOIDFunctionValue(dwEncodingType, util.pstrToFfi(pszFuncName), util.pstrToFfi(pszOID), util.pwstrToFfi(pwszValueName), util.toPointer(pdwValueType), util.toPointer(pbValueData), util.toPointer(pcbValueData)));
}

export function CryptEnumOIDFunction(
  dwEncodingType: number /* u32 */,
  pszFuncName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pszOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  pfnEnumOIDFunc: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CRYPT_ENUM_OID_FUNC */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptEnumOIDFunction(dwEncodingType, util.pstrToFfi(pszFuncName), util.pstrToFfi(pszOID), dwFlags, util.toPointer(pvArg), util.toPointer(pfnEnumOIDFunc)));
}

export function CryptFindOIDInfo(
  dwKeyType: number /* u32 */,
  pvKey: Deno.PointerValue | Uint8Array /* ptr */,
  dwGroupId: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CryptFindOIDInfo(dwKeyType, util.toPointer(pvKey), dwGroupId);
}

export function CryptRegisterOIDInfo(
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptRegisterOIDInfo(util.toPointer(pInfo), dwFlags));
}

export function CryptUnregisterOIDInfo(
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptUnregisterOIDInfo(util.toPointer(pInfo)));
}

export function CryptEnumOIDInfo(
  dwGroupId: number /* u32 */,
  dwFlags: number /* u32 */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  pfnEnumOIDInfo: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CRYPT_ENUM_OID_INFO */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptEnumOIDInfo(dwGroupId, dwFlags, util.toPointer(pvArg), util.toPointer(pfnEnumOIDInfo)));
}

export function CryptFindLocalizedName(
  pwszCryptName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): string | null /* Windows.Win32.Foundation.PWSTR */ {
  return util.pwstrFromFfi(libCRYPT32_dll.CryptFindLocalizedName(util.pwstrToFfi(pwszCryptName)));
}

export function CryptMsgOpenToEncode(
  dwMsgEncodingType: number /* u32 */,
  dwFlags: number /* u32 */,
  dwMsgType: CRYPT_MSG_TYPE /* Windows.Win32.Security.Cryptography.CRYPT_MSG_TYPE */,
  pvMsgEncodeInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pszInnerContentObjID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pStreamInfo: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CryptMsgOpenToEncode(dwMsgEncodingType, dwFlags, dwMsgType, util.toPointer(pvMsgEncodeInfo), util.pstrToFfi(pszInnerContentObjID), util.toPointer(pStreamInfo));
}

export function CryptMsgCalculateEncodedLength(
  dwMsgEncodingType: number /* u32 */,
  dwFlags: number /* u32 */,
  dwMsgType: number /* u32 */,
  pvMsgEncodeInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pszInnerContentObjID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  cbData: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CryptMsgCalculateEncodedLength(dwMsgEncodingType, dwFlags, dwMsgType, util.toPointer(pvMsgEncodeInfo), util.pstrToFfi(pszInnerContentObjID), cbData);
}

export function CryptMsgOpenToDecode(
  dwMsgEncodingType: number /* u32 */,
  dwFlags: number /* u32 */,
  dwMsgType: number /* u32 */,
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  pRecipientInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pStreamInfo: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CryptMsgOpenToDecode(dwMsgEncodingType, dwFlags, dwMsgType, util.toPointer(hCryptProv), util.toPointer(pRecipientInfo), util.toPointer(pStreamInfo));
}

export function CryptMsgDuplicate(
  hCryptMsg: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CryptMsgDuplicate(util.toPointer(hCryptMsg));
}

export function CryptMsgClose(
  hCryptMsg: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgClose(util.toPointer(hCryptMsg)));
}

export function CryptMsgUpdate(
  hCryptMsg: Deno.PointerValue | Uint8Array /* ptr */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  cbData: number /* u32 */,
  fFinal: boolean /* Windows.Win32.Foundation.BOOL */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgUpdate(util.toPointer(hCryptMsg), util.toPointer(pbData), cbData, util.boolToFfi(fFinal)));
}

export function CryptMsgGetParam(
  hCryptMsg: Deno.PointerValue | Uint8Array /* ptr */,
  dwParamType: number /* u32 */,
  dwIndex: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgGetParam(util.toPointer(hCryptMsg), dwParamType, dwIndex, util.toPointer(pvData), util.toPointer(pcbData)));
}

export function CryptMsgControl(
  hCryptMsg: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  dwCtrlType: number /* u32 */,
  pvCtrlPara: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgControl(util.toPointer(hCryptMsg), dwFlags, dwCtrlType, util.toPointer(pvCtrlPara)));
}

export function CryptMsgVerifyCountersignatureEncoded(
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  dwEncodingType: number /* u32 */,
  pbSignerInfo: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignerInfo: number /* u32 */,
  pbSignerInfoCountersignature: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignerInfoCountersignature: number /* u32 */,
  pciCountersigner: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgVerifyCountersignatureEncoded(util.toPointer(hCryptProv), dwEncodingType, util.toPointer(pbSignerInfo), cbSignerInfo, util.toPointer(pbSignerInfoCountersignature), cbSignerInfoCountersignature, util.toPointer(pciCountersigner)));
}

export function CryptMsgVerifyCountersignatureEncodedEx(
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  dwEncodingType: number /* u32 */,
  pbSignerInfo: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignerInfo: number /* u32 */,
  pbSignerInfoCountersignature: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignerInfoCountersignature: number /* u32 */,
  dwSignerType: number /* u32 */,
  pvSigner: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvExtra: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgVerifyCountersignatureEncodedEx(util.toPointer(hCryptProv), dwEncodingType, util.toPointer(pbSignerInfo), cbSignerInfo, util.toPointer(pbSignerInfoCountersignature), cbSignerInfoCountersignature, dwSignerType, util.toPointer(pvSigner), dwFlags, util.toPointer(pvExtra)));
}

export function CryptMsgCountersign(
  hCryptMsg: Deno.PointerValue | Uint8Array /* ptr */,
  dwIndex: number /* u32 */,
  cCountersigners: number /* u32 */,
  rgCountersigners: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgCountersign(util.toPointer(hCryptMsg), dwIndex, cCountersigners, util.toPointer(rgCountersigners)));
}

export function CryptMsgCountersignEncoded(
  dwEncodingType: number /* u32 */,
  pbSignerInfo: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignerInfo: number /* u32 */,
  cCountersigners: number /* u32 */,
  rgCountersigners: Deno.PointerValue | Uint8Array /* ptr */,
  pbCountersignature: Deno.PointerValue | Uint8Array /* ptr */,
  pcbCountersignature: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgCountersignEncoded(dwEncodingType, util.toPointer(pbSignerInfo), cbSignerInfo, cCountersigners, util.toPointer(rgCountersigners), util.toPointer(pbCountersignature), util.toPointer(pcbCountersignature)));
}

export function CertOpenStore(
  lpszStoreProvider: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwEncodingType: CERT_QUERY_ENCODING_TYPE /* Windows.Win32.Security.Cryptography.CERT_QUERY_ENCODING_TYPE */,
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  dwFlags: CERT_OPEN_STORE_FLAGS /* Windows.Win32.Security.Cryptography.CERT_OPEN_STORE_FLAGS */,
  pvPara: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */ {
  return libCRYPT32_dll.CertOpenStore(util.pstrToFfi(lpszStoreProvider), dwEncodingType, util.toPointer(hCryptProv), dwFlags, util.toPointer(pvPara));
}

export function CertDuplicateStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
): Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */ {
  return libCRYPT32_dll.CertDuplicateStore(util.toPointer(hCertStore));
}

export function CertSaveStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwEncodingType: CERT_QUERY_ENCODING_TYPE /* Windows.Win32.Security.Cryptography.CERT_QUERY_ENCODING_TYPE */,
  dwSaveAs: CERT_STORE_SAVE_AS /* Windows.Win32.Security.Cryptography.CERT_STORE_SAVE_AS */,
  dwSaveTo: CERT_STORE_SAVE_TO /* Windows.Win32.Security.Cryptography.CERT_STORE_SAVE_TO */,
  pvSaveToPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSaveStore(util.toPointer(hCertStore), dwEncodingType, dwSaveAs, dwSaveTo, util.toPointer(pvSaveToPara), dwFlags));
}

export function CertCloseStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertCloseStore(util.toPointer(hCertStore), dwFlags));
}

export function CertGetSubjectCertificateFromStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwCertEncodingType: number /* u32 */,
  pCertId: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertGetSubjectCertificateFromStore(util.toPointer(hCertStore), dwCertEncodingType, util.toPointer(pCertId));
}

export function CertEnumCertificatesInStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pPrevCertContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertEnumCertificatesInStore(util.toPointer(hCertStore), util.toPointer(pPrevCertContext));
}

export function CertFindCertificateInStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwCertEncodingType: number /* u32 */,
  dwFindFlags: number /* u32 */,
  dwFindType: CERT_FIND_FLAGS /* Windows.Win32.Security.Cryptography.CERT_FIND_FLAGS */,
  pvFindPara: Deno.PointerValue | Uint8Array /* ptr */,
  pPrevCertContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindCertificateInStore(util.toPointer(hCertStore), dwCertEncodingType, dwFindFlags, dwFindType, util.toPointer(pvFindPara), util.toPointer(pPrevCertContext));
}

export function CertGetIssuerCertificateFromStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pSubjectContext: Deno.PointerValue | Uint8Array /* ptr */,
  pPrevIssuerContext: Deno.PointerValue | Uint8Array /* ptr */,
  pdwFlags: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertGetIssuerCertificateFromStore(util.toPointer(hCertStore), util.toPointer(pSubjectContext), util.toPointer(pPrevIssuerContext), util.toPointer(pdwFlags));
}

export function CertVerifySubjectCertificateContext(
  pSubject: Deno.PointerValue | Uint8Array /* ptr */,
  pIssuer: Deno.PointerValue | Uint8Array /* ptr */,
  pdwFlags: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertVerifySubjectCertificateContext(util.toPointer(pSubject), util.toPointer(pIssuer), util.toPointer(pdwFlags)));
}

export function CertDuplicateCertificateContext(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertDuplicateCertificateContext(util.toPointer(pCertContext));
}

export function CertCreateCertificateContext(
  dwCertEncodingType: number /* u32 */,
  pbCertEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCertEncoded: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertCreateCertificateContext(dwCertEncodingType, util.toPointer(pbCertEncoded), cbCertEncoded);
}

export function CertFreeCertificateContext(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertFreeCertificateContext(util.toPointer(pCertContext)));
}

export function CertSetCertificateContextProperty(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  dwFlags: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSetCertificateContextProperty(util.toPointer(pCertContext), dwPropId, dwFlags, util.toPointer(pvData)));
}

export function CertGetCertificateContextProperty(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetCertificateContextProperty(util.toPointer(pCertContext), dwPropId, util.toPointer(pvData), util.toPointer(pcbData)));
}

export function CertEnumCertificateContextProperties(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertEnumCertificateContextProperties(util.toPointer(pCertContext), dwPropId);
}

export function CertCreateCTLEntryFromCertificateContextProperties(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  cOptAttr: number /* u32 */,
  rgOptAttr: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pCtlEntry: Deno.PointerValue | Uint8Array /* ptr */,
  pcbCtlEntry: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertCreateCTLEntryFromCertificateContextProperties(util.toPointer(pCertContext), cOptAttr, util.toPointer(rgOptAttr), dwFlags, util.toPointer(pvReserved), util.toPointer(pCtlEntry), util.toPointer(pcbCtlEntry)));
}

export function CertSetCertificateContextPropertiesFromCTLEntry(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  pCtlEntry: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSetCertificateContextPropertiesFromCTLEntry(util.toPointer(pCertContext), util.toPointer(pCtlEntry), dwFlags));
}

export function CertGetCRLFromStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pIssuerContext: Deno.PointerValue | Uint8Array /* ptr */,
  pPrevCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  pdwFlags: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertGetCRLFromStore(util.toPointer(hCertStore), util.toPointer(pIssuerContext), util.toPointer(pPrevCrlContext), util.toPointer(pdwFlags));
}

export function CertEnumCRLsInStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pPrevCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertEnumCRLsInStore(util.toPointer(hCertStore), util.toPointer(pPrevCrlContext));
}

export function CertFindCRLInStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwCertEncodingType: number /* u32 */,
  dwFindFlags: number /* u32 */,
  dwFindType: number /* u32 */,
  pvFindPara: Deno.PointerValue | Uint8Array /* ptr */,
  pPrevCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindCRLInStore(util.toPointer(hCertStore), dwCertEncodingType, dwFindFlags, dwFindType, util.toPointer(pvFindPara), util.toPointer(pPrevCrlContext));
}

export function CertDuplicateCRLContext(
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertDuplicateCRLContext(util.toPointer(pCrlContext));
}

export function CertCreateCRLContext(
  dwCertEncodingType: number /* u32 */,
  pbCrlEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCrlEncoded: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertCreateCRLContext(dwCertEncodingType, util.toPointer(pbCrlEncoded), cbCrlEncoded);
}

export function CertFreeCRLContext(
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertFreeCRLContext(util.toPointer(pCrlContext)));
}

export function CertSetCRLContextProperty(
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  dwFlags: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSetCRLContextProperty(util.toPointer(pCrlContext), dwPropId, dwFlags, util.toPointer(pvData)));
}

export function CertGetCRLContextProperty(
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetCRLContextProperty(util.toPointer(pCrlContext), dwPropId, util.toPointer(pvData), util.toPointer(pcbData)));
}

export function CertEnumCRLContextProperties(
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertEnumCRLContextProperties(util.toPointer(pCrlContext), dwPropId);
}

export function CertFindCertificateInCRL(
  pCert: Deno.PointerValue | Uint8Array /* ptr */,
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  ppCrlEntry: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertFindCertificateInCRL(util.toPointer(pCert), util.toPointer(pCrlContext), dwFlags, util.toPointer(pvReserved), util.toPointer(ppCrlEntry)));
}

export function CertIsValidCRLForCertificate(
  pCert: Deno.PointerValue | Uint8Array /* ptr */,
  pCrl: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertIsValidCRLForCertificate(util.toPointer(pCert), util.toPointer(pCrl), dwFlags, util.toPointer(pvReserved)));
}

export function CertAddEncodedCertificateToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwCertEncodingType: number /* u32 */,
  pbCertEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCertEncoded: number /* u32 */,
  dwAddDisposition: number /* u32 */,
  ppCertContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddEncodedCertificateToStore(util.toPointer(hCertStore), dwCertEncodingType, util.toPointer(pbCertEncoded), cbCertEncoded, dwAddDisposition, util.toPointer(ppCertContext)));
}

export function CertAddCertificateContextToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwAddDisposition: number /* u32 */,
  ppStoreContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddCertificateContextToStore(util.toPointer(hCertStore), util.toPointer(pCertContext), dwAddDisposition, util.toPointer(ppStoreContext)));
}

export function CertAddSerializedElementToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pbElement: Deno.PointerValue | Uint8Array /* ptr */,
  cbElement: number /* u32 */,
  dwAddDisposition: number /* u32 */,
  dwFlags: number /* u32 */,
  dwContextTypeFlags: number /* u32 */,
  pdwContextType: Deno.PointerValue | Uint8Array /* ptr */,
  ppvContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddSerializedElementToStore(util.toPointer(hCertStore), util.toPointer(pbElement), cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, util.toPointer(pdwContextType), util.toPointer(ppvContext)));
}

export function CertDeleteCertificateFromStore(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertDeleteCertificateFromStore(util.toPointer(pCertContext)));
}

export function CertAddEncodedCRLToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwCertEncodingType: number /* u32 */,
  pbCrlEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCrlEncoded: number /* u32 */,
  dwAddDisposition: number /* u32 */,
  ppCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddEncodedCRLToStore(util.toPointer(hCertStore), dwCertEncodingType, util.toPointer(pbCrlEncoded), cbCrlEncoded, dwAddDisposition, util.toPointer(ppCrlContext)));
}

export function CertAddCRLContextToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwAddDisposition: number /* u32 */,
  ppStoreContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddCRLContextToStore(util.toPointer(hCertStore), util.toPointer(pCrlContext), dwAddDisposition, util.toPointer(ppStoreContext)));
}

export function CertDeleteCRLFromStore(
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertDeleteCRLFromStore(util.toPointer(pCrlContext)));
}

export function CertSerializeCertificateStoreElement(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pbElement: Deno.PointerValue | Uint8Array /* ptr */,
  pcbElement: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSerializeCertificateStoreElement(util.toPointer(pCertContext), dwFlags, util.toPointer(pbElement), util.toPointer(pcbElement)));
}

export function CertSerializeCRLStoreElement(
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pbElement: Deno.PointerValue | Uint8Array /* ptr */,
  pcbElement: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSerializeCRLStoreElement(util.toPointer(pCrlContext), dwFlags, util.toPointer(pbElement), util.toPointer(pcbElement)));
}

export function CertDuplicateCTLContext(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertDuplicateCTLContext(util.toPointer(pCtlContext));
}

export function CertCreateCTLContext(
  dwMsgAndCertEncodingType: number /* u32 */,
  pbCtlEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCtlEncoded: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertCreateCTLContext(dwMsgAndCertEncodingType, util.toPointer(pbCtlEncoded), cbCtlEncoded);
}

export function CertFreeCTLContext(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertFreeCTLContext(util.toPointer(pCtlContext)));
}

export function CertSetCTLContextProperty(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  dwFlags: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSetCTLContextProperty(util.toPointer(pCtlContext), dwPropId, dwFlags, util.toPointer(pvData)));
}

export function CertGetCTLContextProperty(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetCTLContextProperty(util.toPointer(pCtlContext), dwPropId, util.toPointer(pvData), util.toPointer(pcbData)));
}

export function CertEnumCTLContextProperties(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertEnumCTLContextProperties(util.toPointer(pCtlContext), dwPropId);
}

export function CertEnumCTLsInStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pPrevCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertEnumCTLsInStore(util.toPointer(hCertStore), util.toPointer(pPrevCtlContext));
}

export function CertFindSubjectInCTL(
  dwEncodingType: number /* u32 */,
  dwSubjectType: number /* u32 */,
  pvSubject: Deno.PointerValue | Uint8Array /* ptr */,
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindSubjectInCTL(dwEncodingType, dwSubjectType, util.toPointer(pvSubject), util.toPointer(pCtlContext), dwFlags);
}

export function CertFindCTLInStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwMsgAndCertEncodingType: number /* u32 */,
  dwFindFlags: number /* u32 */,
  dwFindType: CERT_FIND_TYPE /* Windows.Win32.Security.Cryptography.CERT_FIND_TYPE */,
  pvFindPara: Deno.PointerValue | Uint8Array /* ptr */,
  pPrevCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindCTLInStore(util.toPointer(hCertStore), dwMsgAndCertEncodingType, dwFindFlags, dwFindType, util.toPointer(pvFindPara), util.toPointer(pPrevCtlContext));
}

export function CertAddEncodedCTLToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwMsgAndCertEncodingType: number /* u32 */,
  pbCtlEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCtlEncoded: number /* u32 */,
  dwAddDisposition: number /* u32 */,
  ppCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddEncodedCTLToStore(util.toPointer(hCertStore), dwMsgAndCertEncodingType, util.toPointer(pbCtlEncoded), cbCtlEncoded, dwAddDisposition, util.toPointer(ppCtlContext)));
}

export function CertAddCTLContextToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwAddDisposition: number /* u32 */,
  ppStoreContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddCTLContextToStore(util.toPointer(hCertStore), util.toPointer(pCtlContext), dwAddDisposition, util.toPointer(ppStoreContext)));
}

export function CertSerializeCTLStoreElement(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pbElement: Deno.PointerValue | Uint8Array /* ptr */,
  pcbElement: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSerializeCTLStoreElement(util.toPointer(pCtlContext), dwFlags, util.toPointer(pbElement), util.toPointer(pcbElement)));
}

export function CertDeleteCTLFromStore(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertDeleteCTLFromStore(util.toPointer(pCtlContext)));
}

export function CertAddCertificateLinkToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwAddDisposition: number /* u32 */,
  ppStoreContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddCertificateLinkToStore(util.toPointer(hCertStore), util.toPointer(pCertContext), dwAddDisposition, util.toPointer(ppStoreContext)));
}

export function CertAddCRLLinkToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pCrlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwAddDisposition: number /* u32 */,
  ppStoreContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddCRLLinkToStore(util.toPointer(hCertStore), util.toPointer(pCrlContext), dwAddDisposition, util.toPointer(ppStoreContext)));
}

export function CertAddCTLLinkToStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwAddDisposition: number /* u32 */,
  ppStoreContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddCTLLinkToStore(util.toPointer(hCertStore), util.toPointer(pCtlContext), dwAddDisposition, util.toPointer(ppStoreContext)));
}

export function CertAddStoreToCollection(
  hCollectionStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  hSiblingStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwUpdateFlags: number /* u32 */,
  dwPriority: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddStoreToCollection(util.toPointer(hCollectionStore), util.toPointer(hSiblingStore), dwUpdateFlags, dwPriority));
}

export function CertRemoveStoreFromCollection(
  hCollectionStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  hSiblingStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
): void /* void */ {
  return libCRYPT32_dll.CertRemoveStoreFromCollection(util.toPointer(hCollectionStore), util.toPointer(hSiblingStore));
}

export function CertControlStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwFlags: CERT_CONTROL_STORE_FLAGS /* Windows.Win32.Security.Cryptography.CERT_CONTROL_STORE_FLAGS */,
  dwCtrlType: number /* u32 */,
  pvCtrlPara: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertControlStore(util.toPointer(hCertStore), dwFlags, dwCtrlType, util.toPointer(pvCtrlPara)));
}

export function CertSetStoreProperty(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwPropId: number /* u32 */,
  dwFlags: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSetStoreProperty(util.toPointer(hCertStore), dwPropId, dwFlags, util.toPointer(pvData)));
}

export function CertGetStoreProperty(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwPropId: number /* u32 */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetStoreProperty(util.toPointer(hCertStore), dwPropId, util.toPointer(pvData), util.toPointer(pcbData)));
}

export function CertCreateContext(
  dwContextType: number /* u32 */,
  dwEncodingType: number /* u32 */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  dwFlags: number /* u32 */,
  pCreatePara: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertCreateContext(dwContextType, dwEncodingType, util.toPointer(pbEncoded), cbEncoded, dwFlags, util.toPointer(pCreatePara));
}

export function CertRegisterSystemStore(
  pvSystemStore: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pStoreInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertRegisterSystemStore(util.toPointer(pvSystemStore), dwFlags, util.toPointer(pStoreInfo), util.toPointer(pvReserved)));
}

export function CertRegisterPhysicalStore(
  pvSystemStore: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pwszStoreName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pStoreInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertRegisterPhysicalStore(util.toPointer(pvSystemStore), dwFlags, util.pwstrToFfi(pwszStoreName), util.toPointer(pStoreInfo), util.toPointer(pvReserved)));
}

export function CertUnregisterSystemStore(
  pvSystemStore: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertUnregisterSystemStore(util.toPointer(pvSystemStore), dwFlags));
}

export function CertUnregisterPhysicalStore(
  pvSystemStore: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pwszStoreName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertUnregisterPhysicalStore(util.toPointer(pvSystemStore), dwFlags, util.pwstrToFfi(pwszStoreName)));
}

export function CertEnumSystemStoreLocation(
  dwFlags: number /* u32 */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  pfnEnum: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CERT_ENUM_SYSTEM_STORE_LOCATION */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertEnumSystemStoreLocation(dwFlags, util.toPointer(pvArg), util.toPointer(pfnEnum)));
}

export function CertEnumSystemStore(
  dwFlags: number /* u32 */,
  pvSystemStoreLocationPara: Deno.PointerValue | Uint8Array /* ptr */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  pfnEnum: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CERT_ENUM_SYSTEM_STORE */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertEnumSystemStore(dwFlags, util.toPointer(pvSystemStoreLocationPara), util.toPointer(pvArg), util.toPointer(pfnEnum)));
}

export function CertEnumPhysicalStore(
  pvSystemStore: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  pfnEnum: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CERT_ENUM_PHYSICAL_STORE */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertEnumPhysicalStore(util.toPointer(pvSystemStore), dwFlags, util.toPointer(pvArg), util.toPointer(pfnEnum)));
}

export function CertGetEnhancedKeyUsage(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pUsage: Deno.PointerValue | Uint8Array /* ptr */,
  pcbUsage: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetEnhancedKeyUsage(util.toPointer(pCertContext), dwFlags, util.toPointer(pUsage), util.toPointer(pcbUsage)));
}

export function CertSetEnhancedKeyUsage(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  pUsage: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSetEnhancedKeyUsage(util.toPointer(pCertContext), util.toPointer(pUsage)));
}

export function CertAddEnhancedKeyUsageIdentifier(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  pszUsageIdentifier: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddEnhancedKeyUsageIdentifier(util.toPointer(pCertContext), util.pstrToFfi(pszUsageIdentifier)));
}

export function CertRemoveEnhancedKeyUsageIdentifier(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  pszUsageIdentifier: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertRemoveEnhancedKeyUsageIdentifier(util.toPointer(pCertContext), util.pstrToFfi(pszUsageIdentifier)));
}

export function CertGetValidUsages(
  cCerts: number /* u32 */,
  rghCerts: Deno.PointerValue | Uint8Array /* ptr */,
  cNumOIDs: Deno.PointerValue | Uint8Array /* ptr */,
  rghOIDs: Deno.PointerValue | Uint8Array /* ptr */,
  pcbOIDs: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetValidUsages(cCerts, util.toPointer(rghCerts), util.toPointer(cNumOIDs), util.toPointer(rghOIDs), util.toPointer(pcbOIDs)));
}

export function CryptMsgGetAndVerifySigner(
  hCryptMsg: Deno.PointerValue | Uint8Array /* ptr */,
  cSignerStore: number /* u32 */,
  rghSignerStore: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  ppSigner: Deno.PointerValue | Uint8Array /* ptr */,
  pdwSignerIndex: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgGetAndVerifySigner(util.toPointer(hCryptMsg), cSignerStore, util.toPointer(rghSignerStore), dwFlags, util.toPointer(ppSigner), util.toPointer(pdwSignerIndex)));
}

export function CryptMsgSignCTL(
  dwMsgEncodingType: number /* u32 */,
  pbCtlContent: Deno.PointerValue | Uint8Array /* ptr */,
  cbCtlContent: number /* u32 */,
  pSignInfo: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgSignCTL(dwMsgEncodingType, util.toPointer(pbCtlContent), cbCtlContent, util.toPointer(pSignInfo), dwFlags, util.toPointer(pbEncoded), util.toPointer(pcbEncoded)));
}

export function CryptMsgEncodeAndSignCTL(
  dwMsgEncodingType: number /* u32 */,
  pCtlInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pSignInfo: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptMsgEncodeAndSignCTL(dwMsgEncodingType, util.toPointer(pCtlInfo), util.toPointer(pSignInfo), dwFlags, util.toPointer(pbEncoded), util.toPointer(pcbEncoded)));
}

export function CertFindSubjectInSortedCTL(
  pSubjectIdentifier: Deno.PointerValue | Uint8Array /* ptr */,
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pEncodedAttributes: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertFindSubjectInSortedCTL(util.toPointer(pSubjectIdentifier), util.toPointer(pCtlContext), dwFlags, util.toPointer(pvReserved), util.toPointer(pEncodedAttributes)));
}

export function CertEnumSubjectInSortedCTL(
  pCtlContext: Deno.PointerValue | Uint8Array /* ptr */,
  ppvNextSubject: Deno.PointerValue | Uint8Array /* ptr */,
  pSubjectIdentifier: Deno.PointerValue | Uint8Array /* ptr */,
  pEncodedAttributes: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertEnumSubjectInSortedCTL(util.toPointer(pCtlContext), util.toPointer(ppvNextSubject), util.toPointer(pSubjectIdentifier), util.toPointer(pEncodedAttributes)));
}

export function CertVerifyCTLUsage(
  dwEncodingType: number /* u32 */,
  dwSubjectType: number /* u32 */,
  pvSubject: Deno.PointerValue | Uint8Array /* ptr */,
  pSubjectUsage: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pVerifyUsagePara: Deno.PointerValue | Uint8Array /* ptr */,
  pVerifyUsageStatus: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertVerifyCTLUsage(dwEncodingType, dwSubjectType, util.toPointer(pvSubject), util.toPointer(pSubjectUsage), dwFlags, util.toPointer(pVerifyUsagePara), util.toPointer(pVerifyUsageStatus)));
}

export function CertVerifyRevocation(
  dwEncodingType: number /* u32 */,
  dwRevType: number /* u32 */,
  cContext: number /* u32 */,
  rgpvContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pRevPara: Deno.PointerValue | Uint8Array /* ptr */,
  pRevStatus: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertVerifyRevocation(dwEncodingType, dwRevType, cContext, util.toPointer(rgpvContext), dwFlags, util.toPointer(pRevPara), util.toPointer(pRevStatus)));
}

export function CertCompareIntegerBlob(
  pInt1: Deno.PointerValue | Uint8Array /* ptr */,
  pInt2: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertCompareIntegerBlob(util.toPointer(pInt1), util.toPointer(pInt2)));
}

export function CertCompareCertificate(
  dwCertEncodingType: number /* u32 */,
  pCertId1: Deno.PointerValue | Uint8Array /* ptr */,
  pCertId2: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertCompareCertificate(dwCertEncodingType, util.toPointer(pCertId1), util.toPointer(pCertId2)));
}

export function CertCompareCertificateName(
  dwCertEncodingType: number /* u32 */,
  pCertName1: Deno.PointerValue | Uint8Array /* ptr */,
  pCertName2: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertCompareCertificateName(dwCertEncodingType, util.toPointer(pCertName1), util.toPointer(pCertName2)));
}

export function CertIsRDNAttrsInCertificateName(
  dwCertEncodingType: number /* u32 */,
  dwFlags: number /* u32 */,
  pCertName: Deno.PointerValue | Uint8Array /* ptr */,
  pRDN: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertIsRDNAttrsInCertificateName(dwCertEncodingType, dwFlags, util.toPointer(pCertName), util.toPointer(pRDN)));
}

export function CertComparePublicKeyInfo(
  dwCertEncodingType: number /* u32 */,
  pPublicKey1: Deno.PointerValue | Uint8Array /* ptr */,
  pPublicKey2: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertComparePublicKeyInfo(dwCertEncodingType, util.toPointer(pPublicKey1), util.toPointer(pPublicKey2)));
}

export function CertGetPublicKeyLength(
  dwCertEncodingType: number /* u32 */,
  pPublicKey: Deno.PointerValue | Uint8Array /* ptr */,
): number /* u32 */ {
  return libCRYPT32_dll.CertGetPublicKeyLength(dwCertEncodingType, util.toPointer(pPublicKey));
}

export function CryptVerifyCertificateSignature(
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  dwCertEncodingType: number /* u32 */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  pPublicKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyCertificateSignature(util.toPointer(hCryptProv), dwCertEncodingType, util.toPointer(pbEncoded), cbEncoded, util.toPointer(pPublicKey)));
}

export function CryptVerifyCertificateSignatureEx(
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  dwCertEncodingType: number /* u32 */,
  dwSubjectType: number /* u32 */,
  pvSubject: Deno.PointerValue | Uint8Array /* ptr */,
  dwIssuerType: number /* u32 */,
  pvIssuer: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_VERIFY_CERT_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_VERIFY_CERT_FLAGS */,
  pvExtra: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyCertificateSignatureEx(util.toPointer(hCryptProv), dwCertEncodingType, dwSubjectType, util.toPointer(pvSubject), dwIssuerType, util.toPointer(pvIssuer), dwFlags, util.toPointer(pvExtra)));
}

export function CertIsStrongHashToSign(
  pStrongSignPara: Deno.PointerValue | Uint8Array /* ptr */,
  pwszCNGHashAlgid: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pSigningCert: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertIsStrongHashToSign(util.toPointer(pStrongSignPara), util.pwstrToFfi(pwszCNGHashAlgid), util.toPointer(pSigningCert)));
}

export function CryptHashToBeSigned(
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  dwCertEncodingType: number /* u32 */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  pbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptHashToBeSigned(util.toPointer(hCryptProv), dwCertEncodingType, util.toPointer(pbEncoded), cbEncoded, util.toPointer(pbComputedHash), util.toPointer(pcbComputedHash)));
}

export function CryptHashCertificate(
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  Algid: number /* u32 */,
  dwFlags: number /* u32 */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  pbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptHashCertificate(util.toPointer(hCryptProv), Algid, dwFlags, util.toPointer(pbEncoded), cbEncoded, util.toPointer(pbComputedHash), util.toPointer(pcbComputedHash)));
}

export function CryptHashCertificate2(
  pwszCNGHashAlgid: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncoded: number /* u32 */,
  pbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptHashCertificate2(util.pwstrToFfi(pwszCNGHashAlgid), dwFlags, util.toPointer(pvReserved), util.toPointer(pbEncoded), cbEncoded, util.toPointer(pbComputedHash), util.toPointer(pcbComputedHash)));
}

export function CryptSignCertificate(
  hCryptProvOrNCryptKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_OR_NCRYPT_KEY_HANDLE */,
  dwKeySpec: number /* u32 */,
  dwCertEncodingType: number /* u32 */,
  pbEncodedToBeSigned: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncodedToBeSigned: number /* u32 */,
  pSignatureAlgorithm: Deno.PointerValue | Uint8Array /* ptr */,
  pvHashAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbSignature: Deno.PointerValue | Uint8Array /* ptr */,
  pcbSignature: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSignCertificate(util.toPointer(hCryptProvOrNCryptKey), dwKeySpec, dwCertEncodingType, util.toPointer(pbEncodedToBeSigned), cbEncodedToBeSigned, util.toPointer(pSignatureAlgorithm), util.toPointer(pvHashAuxInfo), util.toPointer(pbSignature), util.toPointer(pcbSignature)));
}

export function CryptSignAndEncodeCertificate(
  hCryptProvOrNCryptKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_OR_NCRYPT_KEY_HANDLE */,
  dwKeySpec: CERT_KEY_SPEC /* Windows.Win32.Security.Cryptography.CERT_KEY_SPEC */,
  dwCertEncodingType: number /* u32 */,
  lpszStructType: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pvStructInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pSignatureAlgorithm: Deno.PointerValue | Uint8Array /* ptr */,
  pvHashAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSignAndEncodeCertificate(util.toPointer(hCryptProvOrNCryptKey), dwKeySpec, dwCertEncodingType, util.pstrToFfi(lpszStructType), util.toPointer(pvStructInfo), util.toPointer(pSignatureAlgorithm), util.toPointer(pvHashAuxInfo), util.toPointer(pbEncoded), util.toPointer(pcbEncoded)));
}

export function CertVerifyTimeValidity(
  pTimeToVerify: Deno.PointerValue | Uint8Array /* ptr */,
  pCertInfo: Deno.PointerValue | Uint8Array /* ptr */,
): number /* i32 */ {
  return libCRYPT32_dll.CertVerifyTimeValidity(util.toPointer(pTimeToVerify), util.toPointer(pCertInfo));
}

export function CertVerifyCRLTimeValidity(
  pTimeToVerify: Deno.PointerValue | Uint8Array /* ptr */,
  pCrlInfo: Deno.PointerValue | Uint8Array /* ptr */,
): number /* i32 */ {
  return libCRYPT32_dll.CertVerifyCRLTimeValidity(util.toPointer(pTimeToVerify), util.toPointer(pCrlInfo));
}

export function CertVerifyValidityNesting(
  pSubjectInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pIssuerInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertVerifyValidityNesting(util.toPointer(pSubjectInfo), util.toPointer(pIssuerInfo)));
}

export function CertVerifyCRLRevocation(
  dwCertEncodingType: number /* u32 */,
  pCertId: Deno.PointerValue | Uint8Array /* ptr */,
  cCrlInfo: number /* u32 */,
  rgpCrlInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertVerifyCRLRevocation(dwCertEncodingType, util.toPointer(pCertId), cCrlInfo, util.toPointer(rgpCrlInfo)));
}

export function CertAlgIdToOID(
  dwAlgId: number /* u32 */,
): string | null /* Windows.Win32.Foundation.PSTR */ {
  return util.pstrFromFfi(libCRYPT32_dll.CertAlgIdToOID(dwAlgId));
}

export function CertOIDToAlgId(
  pszObjId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
): number /* u32 */ {
  return libCRYPT32_dll.CertOIDToAlgId(util.pstrToFfi(pszObjId));
}

export function CertFindExtension(
  pszObjId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  cExtensions: number /* u32 */,
  rgExtensions: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindExtension(util.pstrToFfi(pszObjId), cExtensions, util.toPointer(rgExtensions));
}

export function CertFindAttribute(
  pszObjId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  cAttr: number /* u32 */,
  rgAttr: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindAttribute(util.pstrToFfi(pszObjId), cAttr, util.toPointer(rgAttr));
}

export function CertFindRDNAttr(
  pszObjId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pName: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindRDNAttr(util.pstrToFfi(pszObjId), util.toPointer(pName));
}

export function CertGetIntendedKeyUsage(
  dwCertEncodingType: number /* u32 */,
  pCertInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbKeyUsage: Deno.PointerValue | Uint8Array /* ptr */,
  cbKeyUsage: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetIntendedKeyUsage(dwCertEncodingType, util.toPointer(pCertInfo), util.toPointer(pbKeyUsage), cbKeyUsage));
}

export function CryptInstallDefaultContext(
  hCryptProv: Deno.PointerValue /* usize */,
  dwDefaultType: CRYPT_DEFAULT_CONTEXT_TYPE /* Windows.Win32.Security.Cryptography.CRYPT_DEFAULT_CONTEXT_TYPE */,
  pvDefaultPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_DEFAULT_CONTEXT_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_DEFAULT_CONTEXT_FLAGS */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  phDefaultContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptInstallDefaultContext(hCryptProv, dwDefaultType, util.toPointer(pvDefaultPara), dwFlags, util.toPointer(pvReserved), util.toPointer(phDefaultContext)));
}

export function CryptUninstallDefaultContext(
  hDefaultContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptUninstallDefaultContext(util.toPointer(hDefaultContext), dwFlags, util.toPointer(pvReserved)));
}

export function CryptExportPublicKeyInfo(
  hCryptProvOrNCryptKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_OR_NCRYPT_KEY_HANDLE */,
  dwKeySpec: number /* u32 */,
  dwCertEncodingType: number /* u32 */,
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pcbInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptExportPublicKeyInfo(util.toPointer(hCryptProvOrNCryptKey), dwKeySpec, dwCertEncodingType, util.toPointer(pInfo), util.toPointer(pcbInfo)));
}

export function CryptExportPublicKeyInfoEx(
  hCryptProvOrNCryptKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_OR_NCRYPT_KEY_HANDLE */,
  dwKeySpec: number /* u32 */,
  dwCertEncodingType: number /* u32 */,
  pszPublicKeyObjId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
  pvAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pcbInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptExportPublicKeyInfoEx(util.toPointer(hCryptProvOrNCryptKey), dwKeySpec, dwCertEncodingType, util.pstrToFfi(pszPublicKeyObjId), dwFlags, util.toPointer(pvAuxInfo), util.toPointer(pInfo), util.toPointer(pcbInfo)));
}

export function CryptExportPublicKeyInfoFromBCryptKeyHandle(
  hBCryptKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  dwCertEncodingType: number /* u32 */,
  pszPublicKeyObjId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
  pvAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pcbInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptExportPublicKeyInfoFromBCryptKeyHandle(util.toPointer(hBCryptKey), dwCertEncodingType, util.pstrToFfi(pszPublicKeyObjId), dwFlags, util.toPointer(pvAuxInfo), util.toPointer(pInfo), util.toPointer(pcbInfo)));
}

export function CryptImportPublicKeyInfo(
  hCryptProv: Deno.PointerValue /* usize */,
  dwCertEncodingType: number /* u32 */,
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptImportPublicKeyInfo(hCryptProv, dwCertEncodingType, util.toPointer(pInfo), util.toPointer(phKey)));
}

export function CryptImportPublicKeyInfoEx(
  hCryptProv: Deno.PointerValue /* usize */,
  dwCertEncodingType: number /* u32 */,
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  aiKeyAlg: number /* u32 */,
  dwFlags: number /* u32 */,
  pvAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptImportPublicKeyInfoEx(hCryptProv, dwCertEncodingType, util.toPointer(pInfo), aiKeyAlg, dwFlags, util.toPointer(pvAuxInfo), util.toPointer(phKey)));
}

export function CryptImportPublicKeyInfoEx2(
  dwCertEncodingType: number /* u32 */,
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_IMPORT_PUBLIC_KEY_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_IMPORT_PUBLIC_KEY_FLAGS */,
  pvAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptImportPublicKeyInfoEx2(dwCertEncodingType, util.toPointer(pInfo), dwFlags, util.toPointer(pvAuxInfo), util.toPointer(phKey)));
}

export function CryptAcquireCertificatePrivateKey(
  pCert: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_ACQUIRE_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_ACQUIRE_FLAGS */,
  pvParameters: Deno.PointerValue | Uint8Array /* ptr */,
  phCryptProvOrNCryptKey: Deno.PointerValue | Uint8Array /* ptr */,
  pdwKeySpec: Deno.PointerValue | Uint8Array /* ptr */,
  pfCallerFreeProvOrNCryptKey: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptAcquireCertificatePrivateKey(util.toPointer(pCert), dwFlags, util.toPointer(pvParameters), util.toPointer(phCryptProvOrNCryptKey), util.toPointer(pdwKeySpec), util.toPointer(pfCallerFreeProvOrNCryptKey)));
}

export function CryptFindCertificateKeyProvInfo(
  pCert: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_FIND_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_FIND_FLAGS */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptFindCertificateKeyProvInfo(util.toPointer(pCert), dwFlags, util.toPointer(pvReserved)));
}

export function CryptImportPKCS8(
  sPrivateKeyAndParams: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.CRYPT_PKCS8_IMPORT_PARAMS */,
  dwFlags: CRYPT_KEY_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_KEY_FLAGS */,
  phCryptProv: Deno.PointerValue | Uint8Array /* ptr */,
  pvAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptImportPKCS8(util.toPointer(sPrivateKeyAndParams), dwFlags, util.toPointer(phCryptProv), util.toPointer(pvAuxInfo)));
}

export function CryptExportPKCS8(
  hCryptProv: Deno.PointerValue /* usize */,
  dwKeySpec: number /* u32 */,
  pszPrivateKeyObjId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwFlags: number /* u32 */,
  pvAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbPrivateKeyBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pcbPrivateKeyBlob: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptExportPKCS8(hCryptProv, dwKeySpec, util.pstrToFfi(pszPrivateKeyObjId), dwFlags, util.toPointer(pvAuxInfo), util.toPointer(pbPrivateKeyBlob), util.toPointer(pcbPrivateKeyBlob)));
}

export function CryptHashPublicKeyInfo(
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  Algid: number /* u32 */,
  dwFlags: number /* u32 */,
  dwCertEncodingType: number /* u32 */,
  pInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptHashPublicKeyInfo(util.toPointer(hCryptProv), Algid, dwFlags, dwCertEncodingType, util.toPointer(pInfo), util.toPointer(pbComputedHash), util.toPointer(pcbComputedHash)));
}

export function CertRDNValueToStrA(
  dwValueType: number /* u32 */,
  pValue: Deno.PointerValue | Uint8Array /* ptr */,
  psz: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  csz: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertRDNValueToStrA(dwValueType, util.toPointer(pValue), util.pstrToFfi(psz), csz);
}

export function CertRDNValueToStrW(
  dwValueType: number /* u32 */,
  pValue: Deno.PointerValue | Uint8Array /* ptr */,
  psz: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  csz: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertRDNValueToStrW(dwValueType, util.toPointer(pValue), util.pwstrToFfi(psz), csz);
}

export function CertNameToStrA(
  dwCertEncodingType: number /* u32 */,
  pName: Deno.PointerValue | Uint8Array /* ptr */,
  dwStrType: CERT_STRING_TYPE /* Windows.Win32.Security.Cryptography.CERT_STRING_TYPE */,
  psz: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  csz: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertNameToStrA(dwCertEncodingType, util.toPointer(pName), dwStrType, util.pstrToFfi(psz), csz);
}

export function CertNameToStrW(
  dwCertEncodingType: number /* u32 */,
  pName: Deno.PointerValue | Uint8Array /* ptr */,
  dwStrType: CERT_STRING_TYPE /* Windows.Win32.Security.Cryptography.CERT_STRING_TYPE */,
  psz: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  csz: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertNameToStrW(dwCertEncodingType, util.toPointer(pName), dwStrType, util.pwstrToFfi(psz), csz);
}

export function CertStrToNameA(
  dwCertEncodingType: number /* u32 */,
  pszX500: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwStrType: CERT_STRING_TYPE /* Windows.Win32.Security.Cryptography.CERT_STRING_TYPE */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  ppszError: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertStrToNameA(dwCertEncodingType, util.pstrToFfi(pszX500), dwStrType, util.toPointer(pvReserved), util.toPointer(pbEncoded), util.toPointer(pcbEncoded), util.toPointer(ppszError)));
}

export function CertStrToNameW(
  dwCertEncodingType: number /* u32 */,
  pszX500: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwStrType: CERT_STRING_TYPE /* Windows.Win32.Security.Cryptography.CERT_STRING_TYPE */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  ppszError: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertStrToNameW(dwCertEncodingType, util.pwstrToFfi(pszX500), dwStrType, util.toPointer(pvReserved), util.toPointer(pbEncoded), util.toPointer(pcbEncoded), util.toPointer(ppszError)));
}

export function CertGetNameStringA(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwType: number /* u32 */,
  dwFlags: number /* u32 */,
  pvTypePara: Deno.PointerValue | Uint8Array /* ptr */,
  pszNameString: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  cchNameString: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertGetNameStringA(util.toPointer(pCertContext), dwType, dwFlags, util.toPointer(pvTypePara), util.pstrToFfi(pszNameString), cchNameString);
}

export function CertGetNameStringW(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwType: number /* u32 */,
  dwFlags: number /* u32 */,
  pvTypePara: Deno.PointerValue | Uint8Array /* ptr */,
  pszNameString: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  cchNameString: number /* u32 */,
): number /* u32 */ {
  return libCRYPT32_dll.CertGetNameStringW(util.toPointer(pCertContext), dwType, dwFlags, util.toPointer(pvTypePara), util.pwstrToFfi(pszNameString), cchNameString);
}

export function CryptSignMessage(
  pSignPara: Deno.PointerValue | Uint8Array /* ptr */,
  fDetachedSignature: boolean /* Windows.Win32.Foundation.BOOL */,
  cToBeSigned: number /* u32 */,
  rgpbToBeSigned: Deno.PointerValue | Uint8Array /* ptr */,
  rgcbToBeSigned: Deno.PointerValue | Uint8Array /* ptr */,
  pbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pcbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSignMessage(util.toPointer(pSignPara), util.boolToFfi(fDetachedSignature), cToBeSigned, util.toPointer(rgpbToBeSigned), util.toPointer(rgcbToBeSigned), util.toPointer(pbSignedBlob), util.toPointer(pcbSignedBlob)));
}

export function CryptVerifyMessageSignature(
  pVerifyPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwSignerIndex: number /* u32 */,
  pbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignedBlob: number /* u32 */,
  pbDecoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbDecoded: Deno.PointerValue | Uint8Array /* ptr */,
  ppSignerCert: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyMessageSignature(util.toPointer(pVerifyPara), dwSignerIndex, util.toPointer(pbSignedBlob), cbSignedBlob, util.toPointer(pbDecoded), util.toPointer(pcbDecoded), util.toPointer(ppSignerCert)));
}

export function CryptGetMessageSignerCount(
  dwMsgEncodingType: number /* u32 */,
  pbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignedBlob: number /* u32 */,
): number /* i32 */ {
  return libCRYPT32_dll.CryptGetMessageSignerCount(dwMsgEncodingType, util.toPointer(pbSignedBlob), cbSignedBlob);
}

export function CryptGetMessageCertificates(
  dwMsgAndCertEncodingType: number /* u32 */,
  hCryptProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  dwFlags: number /* u32 */,
  pbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignedBlob: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */ {
  return libCRYPT32_dll.CryptGetMessageCertificates(dwMsgAndCertEncodingType, util.toPointer(hCryptProv), dwFlags, util.toPointer(pbSignedBlob), cbSignedBlob);
}

export function CryptVerifyDetachedMessageSignature(
  pVerifyPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwSignerIndex: number /* u32 */,
  pbDetachedSignBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbDetachedSignBlob: number /* u32 */,
  cToBeSigned: number /* u32 */,
  rgpbToBeSigned: Deno.PointerValue | Uint8Array /* ptr */,
  rgcbToBeSigned: Deno.PointerValue | Uint8Array /* ptr */,
  ppSignerCert: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyDetachedMessageSignature(util.toPointer(pVerifyPara), dwSignerIndex, util.toPointer(pbDetachedSignBlob), cbDetachedSignBlob, cToBeSigned, util.toPointer(rgpbToBeSigned), util.toPointer(rgcbToBeSigned), util.toPointer(ppSignerCert)));
}

export function CryptEncryptMessage(
  pEncryptPara: Deno.PointerValue | Uint8Array /* ptr */,
  cRecipientCert: number /* u32 */,
  rgpRecipientCert: Deno.PointerValue | Uint8Array /* ptr */,
  pbToBeEncrypted: Deno.PointerValue | Uint8Array /* ptr */,
  cbToBeEncrypted: number /* u32 */,
  pbEncryptedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pcbEncryptedBlob: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptEncryptMessage(util.toPointer(pEncryptPara), cRecipientCert, util.toPointer(rgpRecipientCert), util.toPointer(pbToBeEncrypted), cbToBeEncrypted, util.toPointer(pbEncryptedBlob), util.toPointer(pcbEncryptedBlob)));
}

export function CryptDecryptMessage(
  pDecryptPara: Deno.PointerValue | Uint8Array /* ptr */,
  pbEncryptedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncryptedBlob: number /* u32 */,
  pbDecrypted: Deno.PointerValue | Uint8Array /* ptr */,
  pcbDecrypted: Deno.PointerValue | Uint8Array /* ptr */,
  ppXchgCert: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptDecryptMessage(util.toPointer(pDecryptPara), util.toPointer(pbEncryptedBlob), cbEncryptedBlob, util.toPointer(pbDecrypted), util.toPointer(pcbDecrypted), util.toPointer(ppXchgCert)));
}

export function CryptSignAndEncryptMessage(
  pSignPara: Deno.PointerValue | Uint8Array /* ptr */,
  pEncryptPara: Deno.PointerValue | Uint8Array /* ptr */,
  cRecipientCert: number /* u32 */,
  rgpRecipientCert: Deno.PointerValue | Uint8Array /* ptr */,
  pbToBeSignedAndEncrypted: Deno.PointerValue | Uint8Array /* ptr */,
  cbToBeSignedAndEncrypted: number /* u32 */,
  pbSignedAndEncryptedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pcbSignedAndEncryptedBlob: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSignAndEncryptMessage(util.toPointer(pSignPara), util.toPointer(pEncryptPara), cRecipientCert, util.toPointer(rgpRecipientCert), util.toPointer(pbToBeSignedAndEncrypted), cbToBeSignedAndEncrypted, util.toPointer(pbSignedAndEncryptedBlob), util.toPointer(pcbSignedAndEncryptedBlob)));
}

export function CryptDecryptAndVerifyMessageSignature(
  pDecryptPara: Deno.PointerValue | Uint8Array /* ptr */,
  pVerifyPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwSignerIndex: number /* u32 */,
  pbEncryptedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncryptedBlob: number /* u32 */,
  pbDecrypted: Deno.PointerValue | Uint8Array /* ptr */,
  pcbDecrypted: Deno.PointerValue | Uint8Array /* ptr */,
  ppXchgCert: Deno.PointerValue | Uint8Array /* ptr */,
  ppSignerCert: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptDecryptAndVerifyMessageSignature(util.toPointer(pDecryptPara), util.toPointer(pVerifyPara), dwSignerIndex, util.toPointer(pbEncryptedBlob), cbEncryptedBlob, util.toPointer(pbDecrypted), util.toPointer(pcbDecrypted), util.toPointer(ppXchgCert), util.toPointer(ppSignerCert)));
}

export function CryptDecodeMessage(
  dwMsgTypeFlags: number /* u32 */,
  pDecryptPara: Deno.PointerValue | Uint8Array /* ptr */,
  pVerifyPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwSignerIndex: number /* u32 */,
  pbEncodedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncodedBlob: number /* u32 */,
  dwPrevInnerContentType: number /* u32 */,
  pdwMsgType: Deno.PointerValue | Uint8Array /* ptr */,
  pdwInnerContentType: Deno.PointerValue | Uint8Array /* ptr */,
  pbDecoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbDecoded: Deno.PointerValue | Uint8Array /* ptr */,
  ppXchgCert: Deno.PointerValue | Uint8Array /* ptr */,
  ppSignerCert: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptDecodeMessage(dwMsgTypeFlags, util.toPointer(pDecryptPara), util.toPointer(pVerifyPara), dwSignerIndex, util.toPointer(pbEncodedBlob), cbEncodedBlob, dwPrevInnerContentType, util.toPointer(pdwMsgType), util.toPointer(pdwInnerContentType), util.toPointer(pbDecoded), util.toPointer(pcbDecoded), util.toPointer(ppXchgCert), util.toPointer(ppSignerCert)));
}

export function CryptHashMessage(
  pHashPara: Deno.PointerValue | Uint8Array /* ptr */,
  fDetachedHash: boolean /* Windows.Win32.Foundation.BOOL */,
  cToBeHashed: number /* u32 */,
  rgpbToBeHashed: Deno.PointerValue | Uint8Array /* ptr */,
  rgcbToBeHashed: Deno.PointerValue | Uint8Array /* ptr */,
  pbHashedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pcbHashedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptHashMessage(util.toPointer(pHashPara), util.boolToFfi(fDetachedHash), cToBeHashed, util.toPointer(rgpbToBeHashed), util.toPointer(rgcbToBeHashed), util.toPointer(pbHashedBlob), util.toPointer(pcbHashedBlob), util.toPointer(pbComputedHash), util.toPointer(pcbComputedHash)));
}

export function CryptVerifyMessageHash(
  pHashPara: Deno.PointerValue | Uint8Array /* ptr */,
  pbHashedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbHashedBlob: number /* u32 */,
  pbToBeHashed: Deno.PointerValue | Uint8Array /* ptr */,
  pcbToBeHashed: Deno.PointerValue | Uint8Array /* ptr */,
  pbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyMessageHash(util.toPointer(pHashPara), util.toPointer(pbHashedBlob), cbHashedBlob, util.toPointer(pbToBeHashed), util.toPointer(pcbToBeHashed), util.toPointer(pbComputedHash), util.toPointer(pcbComputedHash)));
}

export function CryptVerifyDetachedMessageHash(
  pHashPara: Deno.PointerValue | Uint8Array /* ptr */,
  pbDetachedHashBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbDetachedHashBlob: number /* u32 */,
  cToBeHashed: number /* u32 */,
  rgpbToBeHashed: Deno.PointerValue | Uint8Array /* ptr */,
  rgcbToBeHashed: Deno.PointerValue | Uint8Array /* ptr */,
  pbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbComputedHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyDetachedMessageHash(util.toPointer(pHashPara), util.toPointer(pbDetachedHashBlob), cbDetachedHashBlob, cToBeHashed, util.toPointer(rgpbToBeHashed), util.toPointer(rgcbToBeHashed), util.toPointer(pbComputedHash), util.toPointer(pcbComputedHash)));
}

export function CryptSignMessageWithKey(
  pSignPara: Deno.PointerValue | Uint8Array /* ptr */,
  pbToBeSigned: Deno.PointerValue | Uint8Array /* ptr */,
  cbToBeSigned: number /* u32 */,
  pbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pcbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSignMessageWithKey(util.toPointer(pSignPara), util.toPointer(pbToBeSigned), cbToBeSigned, util.toPointer(pbSignedBlob), util.toPointer(pcbSignedBlob)));
}

export function CryptVerifyMessageSignatureWithKey(
  pVerifyPara: Deno.PointerValue | Uint8Array /* ptr */,
  pPublicKeyInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pbSignedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbSignedBlob: number /* u32 */,
  pbDecoded: Deno.PointerValue | Uint8Array /* ptr */,
  pcbDecoded: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyMessageSignatureWithKey(util.toPointer(pVerifyPara), util.toPointer(pPublicKeyInfo), util.toPointer(pbSignedBlob), cbSignedBlob, util.toPointer(pbDecoded), util.toPointer(pcbDecoded)));
}

export function CertOpenSystemStoreA(
  hProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  szSubsystemProtocol: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
): Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */ {
  return libCRYPT32_dll.CertOpenSystemStoreA(util.toPointer(hProv), util.pstrToFfi(szSubsystemProtocol));
}

export function CertOpenSystemStoreW(
  hProv: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_LEGACY */,
  szSubsystemProtocol: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */ {
  return libCRYPT32_dll.CertOpenSystemStoreW(util.toPointer(hProv), util.pwstrToFfi(szSubsystemProtocol));
}

export function CertAddEncodedCertificateToSystemStoreA(
  szCertStoreName: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pbCertEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCertEncoded: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddEncodedCertificateToSystemStoreA(util.pstrToFfi(szCertStoreName), util.toPointer(pbCertEncoded), cbCertEncoded));
}

export function CertAddEncodedCertificateToSystemStoreW(
  szCertStoreName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pbCertEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  cbCertEncoded: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertAddEncodedCertificateToSystemStoreW(util.pwstrToFfi(szCertStoreName), util.toPointer(pbCertEncoded), cbCertEncoded));
}

export function FindCertsByIssuer(
  pCertChains: Deno.PointerValue | Uint8Array /* ptr */,
  pcbCertChains: Deno.PointerValue | Uint8Array /* ptr */,
  pcCertChains: Deno.PointerValue | Uint8Array /* ptr */,
  pbEncodedIssuerName: Deno.PointerValue | Uint8Array /* ptr */,
  cbEncodedIssuerName: number /* u32 */,
  pwszPurpose: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwKeySpec: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libWINTRUST_dll.FindCertsByIssuer(util.toPointer(pCertChains), util.toPointer(pcbCertChains), util.toPointer(pcCertChains), util.toPointer(pbEncodedIssuerName), cbEncodedIssuerName, util.pwstrToFfi(pwszPurpose), dwKeySpec);
}

export function CryptQueryObject(
  dwObjectType: CERT_QUERY_OBJECT_TYPE /* Windows.Win32.Security.Cryptography.CERT_QUERY_OBJECT_TYPE */,
  pvObject: Deno.PointerValue | Uint8Array /* ptr */,
  dwExpectedContentTypeFlags: CERT_QUERY_CONTENT_TYPE_FLAGS /* Windows.Win32.Security.Cryptography.CERT_QUERY_CONTENT_TYPE_FLAGS */,
  dwExpectedFormatTypeFlags: CERT_QUERY_FORMAT_TYPE_FLAGS /* Windows.Win32.Security.Cryptography.CERT_QUERY_FORMAT_TYPE_FLAGS */,
  dwFlags: number /* u32 */,
  pdwMsgAndCertEncodingType: Deno.PointerValue | Uint8Array /* ptr */,
  pdwContentType: Deno.PointerValue | Uint8Array /* ptr */,
  pdwFormatType: Deno.PointerValue | Uint8Array /* ptr */,
  phCertStore: Deno.PointerValue | Uint8Array /* ptr */,
  phMsg: Deno.PointerValue | Uint8Array /* ptr */,
  ppvContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptQueryObject(dwObjectType, util.toPointer(pvObject), dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, util.toPointer(pdwMsgAndCertEncodingType), util.toPointer(pdwContentType), util.toPointer(pdwFormatType), util.toPointer(phCertStore), util.toPointer(phMsg), util.toPointer(ppvContext)));
}

export function CryptMemAlloc(
  cbSize: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CryptMemAlloc(cbSize);
}

export function CryptMemRealloc(
  pv: Deno.PointerValue | Uint8Array /* ptr */,
  cbSize: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CryptMemRealloc(util.toPointer(pv), cbSize);
}

export function CryptMemFree(
  pv: Deno.PointerValue | Uint8Array /* ptr */,
): void /* void */ {
  return libCRYPT32_dll.CryptMemFree(util.toPointer(pv));
}

export function CryptCreateAsyncHandle(
  dwFlags: number /* u32 */,
  phAsync: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptCreateAsyncHandle(dwFlags, util.toPointer(phAsync)));
}

export function CryptSetAsyncParam(
  hAsync: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTASYNC */,
  pszParamOid: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pvParam: Deno.PointerValue | Uint8Array /* ptr */,
  pfnFree: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CRYPT_ASYNC_PARAM_FREE_FUNC */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSetAsyncParam(util.toPointer(hAsync), util.pstrToFfi(pszParamOid), util.toPointer(pvParam), util.toPointer(pfnFree)));
}

export function CryptGetAsyncParam(
  hAsync: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTASYNC */,
  pszParamOid: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  ppvParam: Deno.PointerValue | Uint8Array /* ptr */,
  ppfnFree: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptGetAsyncParam(util.toPointer(hAsync), util.pstrToFfi(pszParamOid), util.toPointer(ppvParam), util.toPointer(ppfnFree)));
}

export function CryptCloseAsyncHandle(
  hAsync: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTASYNC */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptCloseAsyncHandle(util.toPointer(hAsync)));
}

export function CryptRetrieveObjectByUrlA(
  pszUrl: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pszObjectOid: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwRetrievalFlags: number /* u32 */,
  dwTimeout: number /* u32 */,
  ppvObject: Deno.PointerValue | Uint8Array /* ptr */,
  hAsyncRetrieve: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTASYNC */,
  pCredentials: Deno.PointerValue | Uint8Array /* ptr */,
  pvVerify: Deno.PointerValue | Uint8Array /* ptr */,
  pAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPTNET_dll.CryptRetrieveObjectByUrlA(util.pstrToFfi(pszUrl), util.pstrToFfi(pszObjectOid), dwRetrievalFlags, dwTimeout, util.toPointer(ppvObject), util.toPointer(hAsyncRetrieve), util.toPointer(pCredentials), util.toPointer(pvVerify), util.toPointer(pAuxInfo)));
}

export function CryptRetrieveObjectByUrlW(
  pszUrl: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pszObjectOid: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwRetrievalFlags: number /* u32 */,
  dwTimeout: number /* u32 */,
  ppvObject: Deno.PointerValue | Uint8Array /* ptr */,
  hAsyncRetrieve: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTASYNC */,
  pCredentials: Deno.PointerValue | Uint8Array /* ptr */,
  pvVerify: Deno.PointerValue | Uint8Array /* ptr */,
  pAuxInfo: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPTNET_dll.CryptRetrieveObjectByUrlW(util.pwstrToFfi(pszUrl), util.pstrToFfi(pszObjectOid), dwRetrievalFlags, dwTimeout, util.toPointer(ppvObject), util.toPointer(hAsyncRetrieve), util.toPointer(pCredentials), util.toPointer(pvVerify), util.toPointer(pAuxInfo)));
}

export function CryptInstallCancelRetrieval(
  pfnCancel: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CRYPT_CANCEL_RETRIEVAL */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPTNET_dll.CryptInstallCancelRetrieval(util.toPointer(pfnCancel), util.toPointer(pvArg), dwFlags, util.toPointer(pvReserved)));
}

export function CryptUninstallCancelRetrieval(
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPTNET_dll.CryptUninstallCancelRetrieval(dwFlags, util.toPointer(pvReserved)));
}

export function CryptGetObjectUrl(
  pszUrlOid: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pvPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_GET_URL_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_GET_URL_FLAGS */,
  pUrlArray: Deno.PointerValue | Uint8Array /* ptr */,
  pcbUrlArray: Deno.PointerValue | Uint8Array /* ptr */,
  pUrlInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pcbUrlInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPTNET_dll.CryptGetObjectUrl(util.pstrToFfi(pszUrlOid), util.toPointer(pvPara), dwFlags, util.toPointer(pUrlArray), util.toPointer(pcbUrlArray), util.toPointer(pUrlInfo), util.toPointer(pcbUrlInfo), util.toPointer(pvReserved)));
}

export function CertCreateSelfSignCertificate(
  hCryptProvOrNCryptKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_OR_NCRYPT_KEY_HANDLE */,
  pSubjectIssuerBlob: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CERT_CREATE_SELFSIGN_FLAGS /* Windows.Win32.Security.Cryptography.CERT_CREATE_SELFSIGN_FLAGS */,
  pKeyProvInfo: Deno.PointerValue | Uint8Array /* ptr */,
  pSignatureAlgorithm: Deno.PointerValue | Uint8Array /* ptr */,
  pStartTime: Deno.PointerValue | Uint8Array /* ptr */,
  pEndTime: Deno.PointerValue | Uint8Array /* ptr */,
  pExtensions: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertCreateSelfSignCertificate(util.toPointer(hCryptProvOrNCryptKey), util.toPointer(pSubjectIssuerBlob), dwFlags, util.toPointer(pKeyProvInfo), util.toPointer(pSignatureAlgorithm), util.toPointer(pStartTime), util.toPointer(pEndTime), util.toPointer(pExtensions));
}

export function CryptGetKeyIdentifierProperty(
  pKeyIdentifier: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  dwFlags: number /* u32 */,
  pwszComputerName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptGetKeyIdentifierProperty(util.toPointer(pKeyIdentifier), dwPropId, dwFlags, util.pwstrToFfi(pwszComputerName), util.toPointer(pvReserved), util.toPointer(pvData), util.toPointer(pcbData)));
}

export function CryptSetKeyIdentifierProperty(
  pKeyIdentifier: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  dwFlags: number /* u32 */,
  pwszComputerName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pvData: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptSetKeyIdentifierProperty(util.toPointer(pKeyIdentifier), dwPropId, dwFlags, util.pwstrToFfi(pwszComputerName), util.toPointer(pvReserved), util.toPointer(pvData)));
}

export function CryptEnumKeyIdentifierProperties(
  pKeyIdentifier: Deno.PointerValue | Uint8Array /* ptr */,
  dwPropId: number /* u32 */,
  dwFlags: number /* u32 */,
  pwszComputerName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  pfnEnum: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CRYPT_ENUM_KEYID_PROP */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptEnumKeyIdentifierProperties(util.toPointer(pKeyIdentifier), dwPropId, dwFlags, util.pwstrToFfi(pwszComputerName), util.toPointer(pvReserved), util.toPointer(pvArg), util.toPointer(pfnEnum)));
}

export function CryptCreateKeyIdentifierFromCSP(
  dwCertEncodingType: number /* u32 */,
  pszPubKeyOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pPubKeyStruc: Deno.PointerValue | Uint8Array /* ptr */,
  cbPubKeyStruc: number /* u32 */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pbHash: Deno.PointerValue | Uint8Array /* ptr */,
  pcbHash: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptCreateKeyIdentifierFromCSP(dwCertEncodingType, util.pstrToFfi(pszPubKeyOID), util.toPointer(pPubKeyStruc), cbPubKeyStruc, dwFlags, util.toPointer(pvReserved), util.toPointer(pbHash), util.toPointer(pcbHash)));
}

export function CertCreateCertificateChainEngine(
  pConfig: Deno.PointerValue | Uint8Array /* ptr */,
  phChainEngine: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertCreateCertificateChainEngine(util.toPointer(pConfig), util.toPointer(phChainEngine)));
}

export function CertFreeCertificateChainEngine(
  hChainEngine: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTCHAINENGINE */,
): void /* void */ {
  return libCRYPT32_dll.CertFreeCertificateChainEngine(util.toPointer(hChainEngine));
}

export function CertResyncCertificateChainEngine(
  hChainEngine: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTCHAINENGINE */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertResyncCertificateChainEngine(util.toPointer(hChainEngine)));
}

export function CertGetCertificateChain(
  hChainEngine: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTCHAINENGINE */,
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  pTime: Deno.PointerValue | Uint8Array /* ptr */,
  hAdditionalStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pChainPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  ppChainContext: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertGetCertificateChain(util.toPointer(hChainEngine), util.toPointer(pCertContext), util.toPointer(pTime), util.toPointer(hAdditionalStore), util.toPointer(pChainPara), dwFlags, util.toPointer(pvReserved), util.toPointer(ppChainContext)));
}

export function CertFreeCertificateChain(
  pChainContext: Deno.PointerValue | Uint8Array /* ptr */,
): void /* void */ {
  return libCRYPT32_dll.CertFreeCertificateChain(util.toPointer(pChainContext));
}

export function CertDuplicateCertificateChain(
  pChainContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertDuplicateCertificateChain(util.toPointer(pChainContext));
}

export function CertFindChainInStore(
  hCertStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  dwCertEncodingType: number /* u32 */,
  dwFindFlags: CERT_FIND_CHAIN_IN_STORE_FLAGS /* Windows.Win32.Security.Cryptography.CERT_FIND_CHAIN_IN_STORE_FLAGS */,
  dwFindType: number /* u32 */,
  pvFindPara: Deno.PointerValue | Uint8Array /* ptr */,
  pPrevChainContext: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertFindChainInStore(util.toPointer(hCertStore), dwCertEncodingType, dwFindFlags, dwFindType, util.toPointer(pvFindPara), util.toPointer(pPrevChainContext));
}

export function CertVerifyCertificateChainPolicy(
  pszPolicyOID: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pChainContext: Deno.PointerValue | Uint8Array /* ptr */,
  pPolicyPara: Deno.PointerValue | Uint8Array /* ptr */,
  pPolicyStatus: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertVerifyCertificateChainPolicy(util.pstrToFfi(pszPolicyOID), util.toPointer(pChainContext), util.toPointer(pPolicyPara), util.toPointer(pPolicyStatus)));
}

export function CryptStringToBinaryA(
  pszString: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  cchString: number /* u32 */,
  dwFlags: CRYPT_STRING /* Windows.Win32.Security.Cryptography.CRYPT_STRING */,
  pbBinary: Deno.PointerValue | Uint8Array /* ptr */,
  pcbBinary: Deno.PointerValue | Uint8Array /* ptr */,
  pdwSkip: Deno.PointerValue | Uint8Array /* ptr */,
  pdwFlags: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptStringToBinaryA(util.pstrToFfi(pszString), cchString, dwFlags, util.toPointer(pbBinary), util.toPointer(pcbBinary), util.toPointer(pdwSkip), util.toPointer(pdwFlags)));
}

export function CryptStringToBinaryW(
  pszString: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  cchString: number /* u32 */,
  dwFlags: CRYPT_STRING /* Windows.Win32.Security.Cryptography.CRYPT_STRING */,
  pbBinary: Deno.PointerValue | Uint8Array /* ptr */,
  pcbBinary: Deno.PointerValue | Uint8Array /* ptr */,
  pdwSkip: Deno.PointerValue | Uint8Array /* ptr */,
  pdwFlags: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptStringToBinaryW(util.pwstrToFfi(pszString), cchString, dwFlags, util.toPointer(pbBinary), util.toPointer(pcbBinary), util.toPointer(pdwSkip), util.toPointer(pdwFlags)));
}

export function CryptBinaryToStringA(
  pbBinary: Deno.PointerValue | Uint8Array /* ptr */,
  cbBinary: number /* u32 */,
  dwFlags: CRYPT_STRING /* Windows.Win32.Security.Cryptography.CRYPT_STRING */,
  pszString: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pcchString: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptBinaryToStringA(util.toPointer(pbBinary), cbBinary, dwFlags, util.pstrToFfi(pszString), util.toPointer(pcchString)));
}

export function CryptBinaryToStringW(
  pbBinary: Deno.PointerValue | Uint8Array /* ptr */,
  cbBinary: number /* u32 */,
  dwFlags: CRYPT_STRING /* Windows.Win32.Security.Cryptography.CRYPT_STRING */,
  pszString: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcchString: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptBinaryToStringW(util.toPointer(pbBinary), cbBinary, dwFlags, util.pwstrToFfi(pszString), util.toPointer(pcchString)));
}

export function PFXImportCertStore(
  pPFX: Deno.PointerValue | Uint8Array /* ptr */,
  szPassword: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: CRYPT_KEY_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_KEY_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */ {
  return libCRYPT32_dll.PFXImportCertStore(util.toPointer(pPFX), util.pwstrToFfi(szPassword), dwFlags);
}

export function PFXIsPFXBlob(
  pPFX: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.PFXIsPFXBlob(util.toPointer(pPFX)));
}

export function PFXVerifyPassword(
  pPFX: Deno.PointerValue | Uint8Array /* ptr */,
  szPassword: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.PFXVerifyPassword(util.toPointer(pPFX), util.pwstrToFfi(szPassword), dwFlags));
}

export function PFXExportCertStoreEx(
  hStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pPFX: Deno.PointerValue | Uint8Array /* ptr */,
  szPassword: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pvPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.PFXExportCertStoreEx(util.toPointer(hStore), util.toPointer(pPFX), util.pwstrToFfi(szPassword), util.toPointer(pvPara), dwFlags));
}

export function PFXExportCertStore(
  hStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pPFX: Deno.PointerValue | Uint8Array /* ptr */,
  szPassword: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.PFXExportCertStore(util.toPointer(hStore), util.toPointer(pPFX), util.pwstrToFfi(szPassword), dwFlags));
}

export function CertOpenServerOcspResponse(
  pChainContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pOpenPara: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertOpenServerOcspResponse(util.toPointer(pChainContext), dwFlags, util.toPointer(pOpenPara));
}

export function CertAddRefServerOcspResponse(
  hServerOcspResponse: Deno.PointerValue | Uint8Array /* ptr */,
): void /* void */ {
  return libCRYPT32_dll.CertAddRefServerOcspResponse(util.toPointer(hServerOcspResponse));
}

export function CertCloseServerOcspResponse(
  hServerOcspResponse: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): void /* void */ {
  return libCRYPT32_dll.CertCloseServerOcspResponse(util.toPointer(hServerOcspResponse), dwFlags);
}

export function CertGetServerOcspResponseContext(
  hServerOcspResponse: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* ptr */ {
  return libCRYPT32_dll.CertGetServerOcspResponseContext(util.toPointer(hServerOcspResponse), dwFlags, util.toPointer(pvReserved));
}

export function CertAddRefServerOcspResponseContext(
  pServerOcspResponseContext: Deno.PointerValue | Uint8Array /* ptr */,
): void /* void */ {
  return libCRYPT32_dll.CertAddRefServerOcspResponseContext(util.toPointer(pServerOcspResponseContext));
}

export function CertFreeServerOcspResponseContext(
  pServerOcspResponseContext: Deno.PointerValue | Uint8Array /* ptr */,
): void /* void */ {
  return libCRYPT32_dll.CertFreeServerOcspResponseContext(util.toPointer(pServerOcspResponseContext));
}

export function CertRetrieveLogoOrBiometricInfo(
  pCertContext: Deno.PointerValue | Uint8Array /* ptr */,
  lpszLogoOrBiometricType: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  dwRetrievalFlags: number /* u32 */,
  dwTimeout: number /* u32 */,
  dwFlags: number /* u32 */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  ppbData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
  ppwszMimeType: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertRetrieveLogoOrBiometricInfo(util.toPointer(pCertContext), util.pstrToFfi(lpszLogoOrBiometricType), dwRetrievalFlags, dwTimeout, dwFlags, util.toPointer(pvReserved), util.toPointer(ppbData), util.toPointer(pcbData), util.toPointer(ppwszMimeType)));
}

export function CertSelectCertificateChains(
  pSelectionContext: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pChainParameters: Deno.PointerValue | Uint8Array /* ptr */,
  cCriteria: number /* u32 */,
  rgpCriteria: Deno.PointerValue | Uint8Array /* ptr */,
  hStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  pcSelection: Deno.PointerValue | Uint8Array /* ptr */,
  pprgpSelection: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertSelectCertificateChains(util.toPointer(pSelectionContext), dwFlags, util.toPointer(pChainParameters), cCriteria, util.toPointer(rgpCriteria), util.toPointer(hStore), util.toPointer(pcSelection), util.toPointer(pprgpSelection)));
}

export function CertFreeCertificateChainList(
  prgpSelection: Deno.PointerValue | Uint8Array /* ptr */,
): void /* void */ {
  return libCRYPT32_dll.CertFreeCertificateChainList(util.toPointer(prgpSelection));
}

export function CryptRetrieveTimeStamp(
  wszUrl: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwRetrievalFlags: number /* u32 */,
  dwTimeout: number /* u32 */,
  pszHashId: string | null | Uint8Array /* Windows.Win32.Foundation.PSTR */,
  pPara: Deno.PointerValue | Uint8Array /* ptr */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  cbData: number /* u32 */,
  ppTsContext: Deno.PointerValue | Uint8Array /* ptr */,
  ppTsSigner: Deno.PointerValue | Uint8Array /* ptr */,
  phStore: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptRetrieveTimeStamp(util.pwstrToFfi(wszUrl), dwRetrievalFlags, dwTimeout, util.pstrToFfi(pszHashId), util.toPointer(pPara), util.toPointer(pbData), cbData, util.toPointer(ppTsContext), util.toPointer(ppTsSigner), util.toPointer(phStore)));
}

export function CryptVerifyTimeStampSignature(
  pbTSContentInfo: Deno.PointerValue | Uint8Array /* ptr */,
  cbTSContentInfo: number /* u32 */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  cbData: number /* u32 */,
  hAdditionalStore: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCERTSTORE */,
  ppTsContext: Deno.PointerValue | Uint8Array /* ptr */,
  ppTsSigner: Deno.PointerValue | Uint8Array /* ptr */,
  phStore: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptVerifyTimeStampSignature(util.toPointer(pbTSContentInfo), cbTSContentInfo, util.toPointer(pbData), cbData, util.toPointer(hAdditionalStore), util.toPointer(ppTsContext), util.toPointer(ppTsSigner), util.toPointer(phStore)));
}

export function CertIsWeakHash(
  dwHashUseType: number /* u32 */,
  pwszCNGHashAlgid: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwChainFlags: number /* u32 */,
  pSignerChainContext: Deno.PointerValue | Uint8Array /* ptr */,
  pTimeStamp: Deno.PointerValue | Uint8Array /* ptr */,
  pwszFileName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CertIsWeakHash(dwHashUseType, util.pwstrToFfi(pwszCNGHashAlgid), dwChainFlags, util.toPointer(pSignerChainContext), util.toPointer(pTimeStamp), util.pwstrToFfi(pwszFileName)));
}

export function CryptProtectData(
  pDataIn: Deno.PointerValue | Uint8Array /* ptr */,
  szDataDescr: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pOptionalEntropy: Deno.PointerValue | Uint8Array /* ptr */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pPromptStruct: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pDataOut: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptProtectData(util.toPointer(pDataIn), util.pwstrToFfi(szDataDescr), util.toPointer(pOptionalEntropy), util.toPointer(pvReserved), util.toPointer(pPromptStruct), dwFlags, util.toPointer(pDataOut)));
}

export function CryptUnprotectData(
  pDataIn: Deno.PointerValue | Uint8Array /* ptr */,
  ppszDataDescr: Deno.PointerValue | Uint8Array /* ptr */,
  pOptionalEntropy: Deno.PointerValue | Uint8Array /* ptr */,
  pvReserved: Deno.PointerValue | Uint8Array /* ptr */,
  pPromptStruct: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pDataOut: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptUnprotectData(util.toPointer(pDataIn), util.toPointer(ppszDataDescr), util.toPointer(pOptionalEntropy), util.toPointer(pvReserved), util.toPointer(pPromptStruct), dwFlags, util.toPointer(pDataOut)));
}

export function CryptUpdateProtectedState(
  pOldSid: Uint8Array | Deno.PointerValue /* Windows.Win32.Foundation.PSID */,
  pwszOldPassword: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
  pdwSuccessCount: Deno.PointerValue | Uint8Array /* ptr */,
  pdwFailureCount: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptUpdateProtectedState(util.toPointer(pOldSid), util.pwstrToFfi(pwszOldPassword), dwFlags, util.toPointer(pdwSuccessCount), util.toPointer(pdwFailureCount)));
}

export function CryptProtectMemory(
  pDataIn: Deno.PointerValue | Uint8Array /* ptr */,
  cbDataIn: number /* u32 */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptProtectMemory(util.toPointer(pDataIn), cbDataIn, dwFlags));
}

export function CryptUnprotectMemory(
  pDataIn: Deno.PointerValue | Uint8Array /* ptr */,
  cbDataIn: number /* u32 */,
  dwFlags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libCRYPT32_dll.CryptUnprotectMemory(util.toPointer(pDataIn), cbDataIn, dwFlags));
}

export function NCryptRegisterProtectionDescriptorName(
  pwszName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pwszDescriptorString: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptRegisterProtectionDescriptorName(util.pwstrToFfi(pwszName), util.pwstrToFfi(pwszDescriptorString), dwFlags);
}

export function NCryptQueryProtectionDescriptorName(
  pwszName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pwszDescriptorString: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcDescriptorString: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptQueryProtectionDescriptorName(util.pwstrToFfi(pwszName), util.pwstrToFfi(pwszDescriptorString), util.toPointer(pcDescriptorString), dwFlags);
}

export function NCryptCreateProtectionDescriptor(
  pwszDescriptorString: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  dwFlags: number /* u32 */,
  phDescriptor: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptCreateProtectionDescriptor(util.pwstrToFfi(pwszDescriptorString), dwFlags, util.toPointer(phDescriptor));
}

export function NCryptCloseProtectionDescriptor(
  hDescriptor: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.NCRYPT_DESCRIPTOR_HANDLE */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptCloseProtectionDescriptor(util.toPointer(hDescriptor));
}

export function NCryptGetProtectionDescriptorInfo(
  hDescriptor: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.NCRYPT_DESCRIPTOR_HANDLE */,
  pMemPara: Deno.PointerValue | Uint8Array /* ptr */,
  dwInfoType: number /* u32 */,
  ppvInfo: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptGetProtectionDescriptorInfo(util.toPointer(hDescriptor), util.toPointer(pMemPara), dwInfoType, util.toPointer(ppvInfo));
}

export function NCryptProtectSecret(
  hDescriptor: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.NCRYPT_DESCRIPTOR_HANDLE */,
  dwFlags: number /* u32 */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  cbData: number /* u32 */,
  pMemPara: Deno.PointerValue | Uint8Array /* ptr */,
  hWnd: Deno.PointerValue /* Windows.Win32.Foundation.HWND */,
  ppbProtectedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  pcbProtectedBlob: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptProtectSecret(util.toPointer(hDescriptor), dwFlags, util.toPointer(pbData), cbData, util.toPointer(pMemPara), (hWnd), util.toPointer(ppbProtectedBlob), util.toPointer(pcbProtectedBlob));
}

export function NCryptUnprotectSecret(
  phDescriptor: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: NCRYPT_FLAGS /* Windows.Win32.Security.Cryptography.NCRYPT_FLAGS */,
  pbProtectedBlob: Deno.PointerValue | Uint8Array /* ptr */,
  cbProtectedBlob: number /* u32 */,
  pMemPara: Deno.PointerValue | Uint8Array /* ptr */,
  hWnd: Deno.PointerValue /* Windows.Win32.Foundation.HWND */,
  ppbData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbData: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptUnprotectSecret(util.toPointer(phDescriptor), dwFlags, util.toPointer(pbProtectedBlob), cbProtectedBlob, util.toPointer(pMemPara), (hWnd), util.toPointer(ppbData), util.toPointer(pcbData));
}

export function NCryptStreamOpenToProtect(
  hDescriptor: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.NCRYPT_DESCRIPTOR_HANDLE */,
  dwFlags: number /* u32 */,
  hWnd: Deno.PointerValue /* Windows.Win32.Foundation.HWND */,
  pStreamInfo: Deno.PointerValue | Uint8Array /* ptr */,
  phStream: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptStreamOpenToProtect(util.toPointer(hDescriptor), dwFlags, (hWnd), util.toPointer(pStreamInfo), util.toPointer(phStream));
}

export function NCryptStreamOpenToUnprotect(
  pStreamInfo: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  hWnd: Deno.PointerValue /* Windows.Win32.Foundation.HWND */,
  phStream: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptStreamOpenToUnprotect(util.toPointer(pStreamInfo), dwFlags, (hWnd), util.toPointer(phStream));
}

export function NCryptStreamOpenToUnprotectEx(
  pStreamInfo: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  hWnd: Deno.PointerValue /* Windows.Win32.Foundation.HWND */,
  phStream: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptStreamOpenToUnprotectEx(util.toPointer(pStreamInfo), dwFlags, (hWnd), util.toPointer(phStream));
}

export function NCryptStreamUpdate(
  hStream: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.NCRYPT_STREAM_HANDLE */,
  pbData: Deno.PointerValue | Uint8Array /* ptr */,
  cbData: Deno.PointerValue /* usize */,
  fFinal: boolean /* Windows.Win32.Foundation.BOOL */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptStreamUpdate(util.toPointer(hStream), util.toPointer(pbData), cbData, util.boolToFfi(fFinal));
}

export function NCryptStreamClose(
  hStream: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.NCRYPT_STREAM_HANDLE */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libncrypt_dll.NCryptStreamClose(util.toPointer(hStream));
}

export function CryptXmlClose(
  hCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlClose(util.toPointer(hCryptXml));
}

export function CryptXmlGetTransforms(
  ppConfig: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlGetTransforms(util.toPointer(ppConfig));
}

export function CryptXmlOpenToEncode(
  pConfig: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_XML_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_XML_FLAGS */,
  wszId: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  rgProperty: Deno.PointerValue | Uint8Array /* ptr */,
  cProperty: number /* u32 */,
  pEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  phSignature: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlOpenToEncode(util.toPointer(pConfig), dwFlags, util.pwstrToFfi(wszId), util.toPointer(rgProperty), cProperty, util.toPointer(pEncoded), util.toPointer(phSignature));
}

export function CryptXmlOpenToDecode(
  pConfig: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_XML_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_XML_FLAGS */,
  rgProperty: Deno.PointerValue | Uint8Array /* ptr */,
  cProperty: number /* u32 */,
  pEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  phCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlOpenToDecode(util.toPointer(pConfig), dwFlags, util.toPointer(rgProperty), cProperty, util.toPointer(pEncoded), util.toPointer(phCryptXml));
}

export function CryptXmlAddObject(
  hSignatureOrObject: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  rgProperty: Deno.PointerValue | Uint8Array /* ptr */,
  cProperty: number /* u32 */,
  pEncoded: Deno.PointerValue | Uint8Array /* ptr */,
  ppObject: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlAddObject(util.toPointer(hSignatureOrObject), dwFlags, util.toPointer(rgProperty), cProperty, util.toPointer(pEncoded), util.toPointer(ppObject));
}

export function CryptXmlCreateReference(
  hCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  wszId: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  wszURI: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  wszType: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pDigestMethod: Deno.PointerValue | Uint8Array /* ptr */,
  cTransform: number /* u32 */,
  rgTransform: Deno.PointerValue | Uint8Array /* ptr */,
  phReference: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlCreateReference(util.toPointer(hCryptXml), dwFlags, util.pwstrToFfi(wszId), util.pwstrToFfi(wszURI), util.pwstrToFfi(wszType), util.toPointer(pDigestMethod), cTransform, util.toPointer(rgTransform), util.toPointer(phReference));
}

export function CryptXmlDigestReference(
  hReference: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: number /* u32 */,
  pDataProviderIn: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlDigestReference(util.toPointer(hReference), dwFlags, util.toPointer(pDataProviderIn));
}

export function CryptXmlSetHMACSecret(
  hSignature: Deno.PointerValue | Uint8Array /* ptr */,
  pbSecret: Deno.PointerValue | Uint8Array /* ptr */,
  cbSecret: number /* u32 */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlSetHMACSecret(util.toPointer(hSignature), util.toPointer(pbSecret), cbSecret);
}

export function CryptXmlSign(
  hSignature: Deno.PointerValue | Uint8Array /* ptr */,
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.HCRYPTPROV_OR_NCRYPT_KEY_HANDLE */,
  dwKeySpec: CERT_KEY_SPEC /* Windows.Win32.Security.Cryptography.CERT_KEY_SPEC */,
  dwFlags: CRYPT_XML_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_XML_FLAGS */,
  dwKeyInfoSpec: CRYPT_XML_KEYINFO_SPEC /* Windows.Win32.Security.Cryptography.CRYPT_XML_KEYINFO_SPEC */,
  pvKeyInfoSpec: Deno.PointerValue | Uint8Array /* ptr */,
  pSignatureMethod: Deno.PointerValue | Uint8Array /* ptr */,
  pCanonicalization: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlSign(util.toPointer(hSignature), util.toPointer(hKey), dwKeySpec, dwFlags, dwKeyInfoSpec, util.toPointer(pvKeyInfoSpec), util.toPointer(pSignatureMethod), util.toPointer(pCanonicalization));
}

export function CryptXmlImportPublicKey(
  dwFlags: CRYPT_XML_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_XML_FLAGS */,
  pKeyValue: Deno.PointerValue | Uint8Array /* ptr */,
  phKey: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlImportPublicKey(dwFlags, util.toPointer(pKeyValue), util.toPointer(phKey));
}

export function CryptXmlVerifySignature(
  hSignature: Deno.PointerValue | Uint8Array /* ptr */,
  hKey: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.BCRYPT_KEY_HANDLE */,
  dwFlags: CRYPT_XML_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_XML_FLAGS */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlVerifySignature(util.toPointer(hSignature), util.toPointer(hKey), dwFlags);
}

export function CryptXmlGetDocContext(
  hCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
  ppStruct: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlGetDocContext(util.toPointer(hCryptXml), util.toPointer(ppStruct));
}

export function CryptXmlGetSignature(
  hCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
  ppStruct: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlGetSignature(util.toPointer(hCryptXml), util.toPointer(ppStruct));
}

export function CryptXmlGetReference(
  hCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
  ppStruct: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlGetReference(util.toPointer(hCryptXml), util.toPointer(ppStruct));
}

export function CryptXmlGetStatus(
  hCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
  pStatus: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlGetStatus(util.toPointer(hCryptXml), util.toPointer(pStatus));
}

export function CryptXmlEncode(
  hCryptXml: Deno.PointerValue | Uint8Array /* ptr */,
  dwCharset: CRYPT_XML_CHARSET /* Windows.Win32.Security.Cryptography.CRYPT_XML_CHARSET */,
  rgProperty: Deno.PointerValue | Uint8Array /* ptr */,
  cProperty: number /* u32 */,
  pvCallbackState: Deno.PointerValue | Uint8Array /* ptr */,
  pfnWrite: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CRYPT_XML_WRITE_CALLBACK */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlEncode(util.toPointer(hCryptXml), dwCharset, util.toPointer(rgProperty), cProperty, util.toPointer(pvCallbackState), util.toPointer(pfnWrite));
}

export function CryptXmlGetAlgorithmInfo(
  pXmlAlgorithm: Deno.PointerValue | Uint8Array /* ptr */,
  dwFlags: CRYPT_XML_FLAGS /* Windows.Win32.Security.Cryptography.CRYPT_XML_FLAGS */,
  ppAlgInfo: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlGetAlgorithmInfo(util.toPointer(pXmlAlgorithm), dwFlags, util.toPointer(ppAlgInfo));
}

export function CryptXmlFindAlgorithmInfo(
  dwFindByType: number /* u32 */,
  pvFindBy: Deno.PointerValue | Uint8Array /* ptr */,
  dwGroupId: number /* u32 */,
  dwFlags: number /* u32 */,
): Deno.PointerValue /* ptr */ {
  return libCRYPTXML_dll.CryptXmlFindAlgorithmInfo(dwFindByType, util.toPointer(pvFindBy), dwGroupId, dwFlags);
}

export function CryptXmlEnumAlgorithmInfo(
  dwGroupId: number /* u32 */,
  dwFlags: number /* u32 */,
  pvArg: Deno.PointerValue | Uint8Array /* ptr */,
  pfnEnumAlgInfo: Uint8Array | Deno.PointerValue /* Windows.Win32.Security.Cryptography.PFN_CRYPT_XML_ENUM_ALG_INFO */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libCRYPTXML_dll.CryptXmlEnumAlgorithmInfo(dwGroupId, dwFlags, util.toPointer(pvArg), util.toPointer(pfnEnumAlgInfo));
}

export function GetToken(
  cPolicyChain: number /* u32 */,
  pPolicyChain: Deno.PointerValue | Uint8Array /* ptr */,
  securityToken: Deno.PointerValue | Uint8Array /* ptr */,
  phProofTokenCrypto: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.GetToken(cPolicyChain, util.toPointer(pPolicyChain), util.toPointer(securityToken), util.toPointer(phProofTokenCrypto));
}

export function ManageCardSpace(): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.ManageCardSpace();
}

export function ImportInformationCard(
  fileName: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.ImportInformationCard(util.pwstrToFfi(fileName));
}

export function Encrypt(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  fOAEP: boolean /* Windows.Win32.Foundation.BOOL */,
  cbInData: number /* u32 */,
  pInData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbOutData: Deno.PointerValue | Uint8Array /* ptr */,
  ppOutData: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.Encrypt(util.toPointer(hCrypto), util.boolToFfi(fOAEP), cbInData, util.toPointer(pInData), util.toPointer(pcbOutData), util.toPointer(ppOutData));
}

export function Decrypt(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  fOAEP: boolean /* Windows.Win32.Foundation.BOOL */,
  cbInData: number /* u32 */,
  pInData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbOutData: Deno.PointerValue | Uint8Array /* ptr */,
  ppOutData: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.Decrypt(util.toPointer(hCrypto), util.boolToFfi(fOAEP), cbInData, util.toPointer(pInData), util.toPointer(pcbOutData), util.toPointer(ppOutData));
}

export function SignHash(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  cbHash: number /* u32 */,
  pHash: Deno.PointerValue | Uint8Array /* ptr */,
  hashAlgOid: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbSig: Deno.PointerValue | Uint8Array /* ptr */,
  ppSig: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.SignHash(util.toPointer(hCrypto), cbHash, util.toPointer(pHash), util.pwstrToFfi(hashAlgOid), util.toPointer(pcbSig), util.toPointer(ppSig));
}

export function VerifyHash(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  cbHash: number /* u32 */,
  pHash: Deno.PointerValue | Uint8Array /* ptr */,
  hashAlgOid: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  cbSig: number /* u32 */,
  pSig: Deno.PointerValue | Uint8Array /* ptr */,
  pfVerified: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.VerifyHash(util.toPointer(hCrypto), cbHash, util.toPointer(pHash), util.pwstrToFfi(hashAlgOid), cbSig, util.toPointer(pSig), util.toPointer(pfVerified));
}

export function GetCryptoTransform(
  hSymmetricCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  mode: number /* u32 */,
  padding: PaddingMode /* Windows.Win32.Security.Cryptography.PaddingMode */,
  feedbackSize: number /* u32 */,
  direction: Direction /* Windows.Win32.Security.Cryptography.Direction */,
  cbIV: number /* u32 */,
  pIV: Deno.PointerValue | Uint8Array /* ptr */,
  pphTransform: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.GetCryptoTransform(util.toPointer(hSymmetricCrypto), mode, padding, feedbackSize, direction, cbIV, util.toPointer(pIV), util.toPointer(pphTransform));
}

export function GetKeyedHash(
  hSymmetricCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  pphHash: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.GetKeyedHash(util.toPointer(hSymmetricCrypto), util.toPointer(pphHash));
}

export function TransformBlock(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  cbInData: number /* u32 */,
  pInData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbOutData: Deno.PointerValue | Uint8Array /* ptr */,
  ppOutData: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.TransformBlock(util.toPointer(hCrypto), cbInData, util.toPointer(pInData), util.toPointer(pcbOutData), util.toPointer(ppOutData));
}

export function TransformFinalBlock(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  cbInData: number /* u32 */,
  pInData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbOutData: Deno.PointerValue | Uint8Array /* ptr */,
  ppOutData: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.TransformFinalBlock(util.toPointer(hCrypto), cbInData, util.toPointer(pInData), util.toPointer(pcbOutData), util.toPointer(ppOutData));
}

export function HashCore(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  cbInData: number /* u32 */,
  pInData: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.HashCore(util.toPointer(hCrypto), cbInData, util.toPointer(pInData));
}

export function HashFinal(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  cbInData: number /* u32 */,
  pInData: Deno.PointerValue | Uint8Array /* ptr */,
  pcbOutData: Deno.PointerValue | Uint8Array /* ptr */,
  ppOutData: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.HashFinal(util.toPointer(hCrypto), cbInData, util.toPointer(pInData), util.toPointer(pcbOutData), util.toPointer(ppOutData));
}

export function FreeToken(
  pAllocMemory: Deno.PointerValue | Uint8Array /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libinfocardapi_dll.FreeToken(util.toPointer(pAllocMemory)));
}

export function CloseCryptoHandle(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.CloseCryptoHandle(util.toPointer(hCrypto));
}

export function GenerateDerivedKey(
  hCrypto: Deno.PointerValue | Uint8Array /* ptr */,
  cbLabel: number /* u32 */,
  pLabel: Deno.PointerValue | Uint8Array /* ptr */,
  cbNonce: number /* u32 */,
  pNonce: Deno.PointerValue | Uint8Array /* ptr */,
  derivedKeyLength: number /* u32 */,
  offset: number /* u32 */,
  algId: string | null | Uint8Array | Uint16Array /* Windows.Win32.Foundation.PWSTR */,
  pcbKey: Deno.PointerValue | Uint8Array /* ptr */,
  ppKey: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.GenerateDerivedKey(util.toPointer(hCrypto), cbLabel, util.toPointer(pLabel), cbNonce, util.toPointer(pNonce), derivedKeyLength, offset, util.pwstrToFfi(algId), util.toPointer(pcbKey), util.toPointer(ppKey));
}

export function GetBrowserToken(
  dwParamType: number /* u32 */,
  pParam: Deno.PointerValue | Uint8Array /* ptr */,
  pcbToken: Deno.PointerValue | Uint8Array /* ptr */,
  ppToken: Deno.PointerValue | Uint8Array /* ptr */,
): Deno.PointerValue /* Windows.Win32.Foundation.HRESULT */ {
  return libinfocardapi_dll.GetBrowserToken(dwParamType, util.toPointer(pParam), util.toPointer(pcbToken), util.toPointer(ppToken));
}

