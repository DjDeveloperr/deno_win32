/// Auto-generated by Deno Win32: Windows.Win32.System.ApplicationVerifier.Apis

import * as util from "../../util.ts";

// Enums
export type VERIFIER_ENUM_RESOURCE_FLAGS = number;
export type eUserAllocationState = number;
export type eHeapAllocationState = number;
export type eHeapEnumerationLevel = number;
export type eHANDLE_TRACE_OPERATIONS = number;
export type eAvrfResourceTypes = number;

// Constants
export const AVRF_ENUM_RESOURCES_FLAGS_DONT_RESOLVE_TRACES = 2;
export const AVRF_ENUM_RESOURCES_FLAGS_SUSPEND = 1;
export const AVRF_MAX_TRACES = 32;
export const AllocationStateUnknown = 0;
export const AllocationStateBusy = 1;
export const AllocationStateFree = 2;
export const HeapFullPageHeap = 1073741824;
export const HeapMetadata = `-2147483648`;
export const HeapStateMask = `-65536`;
export const HeapEnumerationEverything = 0;
export const HeapEnumerationStop = `-1`;
export const OperationDbUnused = 0;
export const OperationDbOPEN = 1;
export const OperationDbCLOSE = 2;
export const OperationDbBADREF = 3;
export const AvrfResourceHeapAllocation = 0;
export const AvrfResourceHandleTrace = 1;
export const AvrfResourceMax = 2;

// Structs

/**
 * Windows.Win32.System.ApplicationVerifier.AVRF_BACKTRACE_INFORMATION (size: 16)
 */
export interface AVRF_BACKTRACE_INFORMATION {
  /** u32 */
  Depth: number;
  /** u32 */
  Index: number;
  /** array */
  ReturnAddresses: Deno.PointerValue;
}

export const sizeofAVRF_BACKTRACE_INFORMATION = 16;

export function allocAVRF_BACKTRACE_INFORMATION(data?: Partial<AVRF_BACKTRACE_INFORMATION>): Uint8Array {
  const buf = new Uint8Array(sizeofAVRF_BACKTRACE_INFORMATION);
  const view = new DataView(buf.buffer);
  // 0x00: u32
  if (data?.Depth !== undefined) view.setUint32(0, Number(data.Depth), true);
  // 0x04: u32
  if (data?.Index !== undefined) view.setUint32(4, Number(data.Index), true);
  // 0x08: pointer
  if (data?.ReturnAddresses !== undefined) view.setBigUint64(8, data.ReturnAddresses === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.ReturnAddresses))), true);
  return buf;
}

export class AVRF_BACKTRACE_INFORMATIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u32
  get Depth(): number {
    return this.view.getUint32(0, true);
  }

  // 0x04: u32
  get Index(): number {
    return this.view.getUint32(4, true);
  }

  // 0x08: pointer
  get ReturnAddresses(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(8, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u32
  set Depth(value: number) {
    this.view.setUint32(0, value, true);
  }

  // 0x04: u32
  set Index(value: number) {
    this.view.setUint32(4, value, true);
  }

  // 0x08: pointer
  set ReturnAddresses(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(8, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.System.ApplicationVerifier.AVRF_HEAP_ALLOCATION (size: 64)
 */
export interface AVRF_HEAP_ALLOCATION {
  /** u64 */
  HeapHandle: bigint | number;
  /** u64 */
  UserAllocation: bigint | number;
  /** u64 */
  UserAllocationSize: bigint | number;
  /** u64 */
  Allocation: bigint | number;
  /** u64 */
  AllocationSize: bigint | number;
  /** u32 */
  UserAllocationState: number;
  /** u32 */
  HeapState: number;
  /** u64 */
  HeapContext: bigint | number;
  /** ptr */
  BackTraceInformation: Deno.PointerValue | Uint8Array;
}

export const sizeofAVRF_HEAP_ALLOCATION = 64;

export function allocAVRF_HEAP_ALLOCATION(data?: Partial<AVRF_HEAP_ALLOCATION>): Uint8Array {
  const buf = new Uint8Array(sizeofAVRF_HEAP_ALLOCATION);
  const view = new DataView(buf.buffer);
  // 0x00: u64
  if (data?.HeapHandle !== undefined) view.setBigUint64(0, BigInt(data.HeapHandle), true);
  // 0x08: u64
  if (data?.UserAllocation !== undefined) view.setBigUint64(8, BigInt(data.UserAllocation), true);
  // 0x10: u64
  if (data?.UserAllocationSize !== undefined) view.setBigUint64(16, BigInt(data.UserAllocationSize), true);
  // 0x18: u64
  if (data?.Allocation !== undefined) view.setBigUint64(24, BigInt(data.Allocation), true);
  // 0x20: u64
  if (data?.AllocationSize !== undefined) view.setBigUint64(32, BigInt(data.AllocationSize), true);
  // 0x28: u32
  if (data?.UserAllocationState !== undefined) view.setUint32(40, Number(data.UserAllocationState), true);
  // 0x2c: u32
  if (data?.HeapState !== undefined) view.setUint32(44, Number(data.HeapState), true);
  // 0x30: u64
  if (data?.HeapContext !== undefined) view.setBigUint64(48, BigInt(data.HeapContext), true);
  // 0x38: pointer
  if (data?.BackTraceInformation !== undefined) view.setBigUint64(56, data.BackTraceInformation === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.BackTraceInformation))), true);
  return buf;
}

export class AVRF_HEAP_ALLOCATIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u64
  get HeapHandle(): bigint | number {
    return Number(this.view.getBigUint64(0, true));
  }

  // 0x08: u64
  get UserAllocation(): bigint | number {
    return Number(this.view.getBigUint64(8, true));
  }

  // 0x10: u64
  get UserAllocationSize(): bigint | number {
    return Number(this.view.getBigUint64(16, true));
  }

  // 0x18: u64
  get Allocation(): bigint | number {
    return Number(this.view.getBigUint64(24, true));
  }

  // 0x20: u64
  get AllocationSize(): bigint | number {
    return Number(this.view.getBigUint64(32, true));
  }

  // 0x28: u32
  get UserAllocationState(): number {
    return this.view.getUint32(40, true);
  }

  // 0x2c: u32
  get HeapState(): number {
    return this.view.getUint32(44, true);
  }

  // 0x30: u64
  get HeapContext(): bigint | number {
    return Number(this.view.getBigUint64(48, true));
  }

  // 0x38: pointer
  get BackTraceInformation(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(56, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u64
  set HeapHandle(value: bigint | number) {
    this.view.setBigUint64(0, BigInt(value), true);
  }

  // 0x08: u64
  set UserAllocation(value: bigint | number) {
    this.view.setBigUint64(8, BigInt(value), true);
  }

  // 0x10: u64
  set UserAllocationSize(value: bigint | number) {
    this.view.setBigUint64(16, BigInt(value), true);
  }

  // 0x18: u64
  set Allocation(value: bigint | number) {
    this.view.setBigUint64(24, BigInt(value), true);
  }

  // 0x20: u64
  set AllocationSize(value: bigint | number) {
    this.view.setBigUint64(32, BigInt(value), true);
  }

  // 0x28: u32
  set UserAllocationState(value: number) {
    this.view.setUint32(40, value, true);
  }

  // 0x2c: u32
  set HeapState(value: number) {
    this.view.setUint32(44, value, true);
  }

  // 0x30: u64
  set HeapContext(value: bigint | number) {
    this.view.setBigUint64(48, BigInt(value), true);
  }

  // 0x38: pointer
  set BackTraceInformation(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(56, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

/**
 * Windows.Win32.System.ApplicationVerifier.AVRF_HANDLE_OPERATION (size: 32)
 */
export interface AVRF_HANDLE_OPERATION {
  /** u64 */
  Handle: bigint | number;
  /** u32 */
  ProcessId: number;
  /** u32 */
  ThreadId: number;
  /** u32 */
  OperationType: number;
  /** u32 */
  Spare0: number;
  /** Windows.Win32.System.ApplicationVerifier.AVRF_BACKTRACE_INFORMATION */
  BackTraceInformation: Uint8Array | Deno.PointerValue;
}

export const sizeofAVRF_HANDLE_OPERATION = 32;

export function allocAVRF_HANDLE_OPERATION(data?: Partial<AVRF_HANDLE_OPERATION>): Uint8Array {
  const buf = new Uint8Array(sizeofAVRF_HANDLE_OPERATION);
  const view = new DataView(buf.buffer);
  // 0x00: u64
  if (data?.Handle !== undefined) view.setBigUint64(0, BigInt(data.Handle), true);
  // 0x08: u32
  if (data?.ProcessId !== undefined) view.setUint32(8, Number(data.ProcessId), true);
  // 0x0c: u32
  if (data?.ThreadId !== undefined) view.setUint32(12, Number(data.ThreadId), true);
  // 0x10: u32
  if (data?.OperationType !== undefined) view.setUint32(16, Number(data.OperationType), true);
  // 0x14: u32
  if (data?.Spare0 !== undefined) view.setUint32(20, Number(data.Spare0), true);
  // 0x18: pointer
  if (data?.BackTraceInformation !== undefined) view.setBigUint64(24, data.BackTraceInformation === null ? 0n : BigInt(Deno.UnsafePointer.value(util.toPointer(data.BackTraceInformation))), true);
  return buf;
}

export class AVRF_HANDLE_OPERATIONView {
  private readonly view: DataView;
  constructor(private readonly buf: Uint8Array) {
    this.view = new DataView(buf.buffer);
  }

  get buffer(): Uint8Array {
    return this.buf;
  }

  // 0x00: u64
  get Handle(): bigint | number {
    return Number(this.view.getBigUint64(0, true));
  }

  // 0x08: u32
  get ProcessId(): number {
    return this.view.getUint32(8, true);
  }

  // 0x0c: u32
  get ThreadId(): number {
    return this.view.getUint32(12, true);
  }

  // 0x10: u32
  get OperationType(): number {
    return this.view.getUint32(16, true);
  }

  // 0x14: u32
  get Spare0(): number {
    return this.view.getUint32(20, true);
  }

  // 0x18: pointer
  get BackTraceInformation(): Uint8Array | Deno.PointerValue {
    const ptr = this.view.getBigUint64(24, true);
    return Deno.UnsafePointer.create(ptr);
  }

  // 0x00: u64
  set Handle(value: bigint | number) {
    this.view.setBigUint64(0, BigInt(value), true);
  }

  // 0x08: u32
  set ProcessId(value: number) {
    this.view.setUint32(8, value, true);
  }

  // 0x0c: u32
  set ThreadId(value: number) {
    this.view.setUint32(12, value, true);
  }

  // 0x10: u32
  set OperationType(value: number) {
    this.view.setUint32(16, value, true);
  }

  // 0x14: u32
  set Spare0(value: number) {
    this.view.setUint32(20, value, true);
  }

  // 0x18: pointer
  set BackTraceInformation(value: Uint8Array | Deno.PointerValue) {
    this.view.setBigUint64(24, BigInt(Deno.UnsafePointer.value(util.toPointer(value))), true);
  }
}

export type HANDLE = bigint | number;

// Native Libraries

try {
  var libverifier_dll = Deno.dlopen("verifier.dll", {
    VerifierEnumerateResource: {
      parameters: ["pointer", "u32", "i32", "pointer", "pointer"],
      result: "u32",
      optional: true,
    },
  }).symbols;
} catch(e) { /* ignore */ }

// Symbols

export function VerifierEnumerateResource(
  Process: Uint8Array | Deno.PointerValue /* Windows.Win32.Foundation.HANDLE */,
  Flags: VERIFIER_ENUM_RESOURCE_FLAGS /* Windows.Win32.System.ApplicationVerifier.VERIFIER_ENUM_RESOURCE_FLAGS */,
  ResourceType: eAvrfResourceTypes /* Windows.Win32.System.ApplicationVerifier.eAvrfResourceTypes */,
  ResourceCallback: Uint8Array | Deno.PointerValue /* Windows.Win32.System.ApplicationVerifier.AVRF_RESOURCE_ENUMERATE_CALLBACK */,
  EnumerationContext: Deno.PointerValue | Uint8Array /* ptr */,
): number /* u32 */ {
  return libverifier_dll.VerifierEnumerateResource!(util.toPointer(Process), Flags, ResourceType, util.toPointer(ResourceCallback), util.toPointer(EnumerationContext));
}

