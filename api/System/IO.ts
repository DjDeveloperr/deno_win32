/// Auto-generated by Deno Win32: Windows.Win32.System.IO.Apis

import * as util from "../../util.ts";

// Structs

/**
 * _Anonymous_e__Struct (size: 16)
 */
export interface _Anonymous_e__Struct {
  /** u64 */
  Alignment: Deno.PointerValue;
  /** u64 */
  Region: Deno.PointerValue;
}

export const sizeof_Anonymous_e__Struct = 16;

export function alloc_Anonymous_e__Struct(data?: Partial<_Anonymous_e__Struct>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous_e__Struct);
  const view = new DataView(buf.buffer);
  // 0x00: u64
  if (data?.Alignment !== undefined) view.setBigUint64(0, BigInt(data.Alignment), true);
  // 0x08: u64
  if (data?.Region !== undefined) view.setBigUint64(8, BigInt(data.Region), true);
  return buf;
}

/**
 * _Anonymous_e__Union (size: 16)
 */
export interface _Anonymous_e__Union {
  /** _Anonymous_e__Struct */
  Anonymous: Uint8Array | Deno.PointerValue | null;
  /** array */
  X: Deno.PointerValue | null;
}

export const sizeof_Anonymous_e__Union = 16;

export function alloc_Anonymous_e__Union(data?: Partial<_Anonymous_e__Union>): Uint8Array {
  const buf = new Uint8Array(sizeof_Anonymous_e__Union);
  const view = new DataView(buf.buffer);
  // 0x00: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(0, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  // 0x08: pointer
  if (data?.X !== undefined) view.setBigUint64(8, data.X === null ? 0n : BigInt(util.toPointer(data.X)), true);
  return buf;
}

export type HANDLE = Deno.PointerValue;

/**
 * Windows.Win32.System.IO.OVERLAPPED (size: 32)
 */
export interface OVERLAPPED {
  /** usize */
  Internal: Deno.PointerValue;
  /** usize */
  InternalHigh: Deno.PointerValue;
  /** _Anonymous_e__Union */
  Anonymous: Uint8Array | Deno.PointerValue | null;
  /** Windows.Win32.Foundation.HANDLE */
  hEvent: Uint8Array | Deno.PointerValue | null;
}

export const sizeofOVERLAPPED = 32;

export function allocOVERLAPPED(data?: Partial<OVERLAPPED>): Uint8Array {
  const buf = new Uint8Array(sizeofOVERLAPPED);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.Internal !== undefined) view.setBigUint64(0, BigInt(data.Internal), true);
  // 0x08: usize
  if (data?.InternalHigh !== undefined) view.setBigUint64(8, BigInt(data.InternalHigh), true);
  // 0x10: pointer
  if (data?.Anonymous !== undefined) view.setBigUint64(16, data.Anonymous === null ? 0n : BigInt(util.toPointer(data.Anonymous)), true);
  // 0x18: pointer
  if (data?.hEvent !== undefined) view.setBigUint64(24, data.hEvent === null ? 0n : BigInt(util.toPointer(data.hEvent)), true);
  return buf;
}

/**
 * Windows.Win32.System.IO.OVERLAPPED_ENTRY (size: 32)
 */
export interface OVERLAPPED_ENTRY {
  /** usize */
  lpCompletionKey: Deno.PointerValue;
  /** ptr */
  lpOverlapped: Deno.PointerValue | Uint8Array | null;
  /** usize */
  Internal: Deno.PointerValue;
  /** u32 */
  dwNumberOfBytesTransferred: number;
}

export const sizeofOVERLAPPED_ENTRY = 32;

export function allocOVERLAPPED_ENTRY(data?: Partial<OVERLAPPED_ENTRY>): Uint8Array {
  const buf = new Uint8Array(sizeofOVERLAPPED_ENTRY);
  const view = new DataView(buf.buffer);
  // 0x00: usize
  if (data?.lpCompletionKey !== undefined) view.setBigUint64(0, BigInt(data.lpCompletionKey), true);
  // 0x08: pointer
  if (data?.lpOverlapped !== undefined) view.setBigUint64(8, data.lpOverlapped === null ? 0n : BigInt(util.toPointer(data.lpOverlapped)), true);
  // 0x10: usize
  if (data?.Internal !== undefined) view.setBigUint64(16, BigInt(data.Internal), true);
  // 0x18: u32
  if (data?.dwNumberOfBytesTransferred !== undefined) view.setUint32(24, Number(data.dwNumberOfBytesTransferred), true);
  // 0x1c: pad4
  return buf;
}

export type BOOL = number;

// Native Libraries

try {
  var libKERNEL32 = Deno.dlopen("KERNEL32", {
    CreateIoCompletionPort: {
      parameters: ["pointer", "pointer", "usize", "u32"],
      result: "pointer",
    },
    GetQueuedCompletionStatus: {
      parameters: ["pointer", "pointer", "pointer", "pointer", "u32"],
      result: "i32",
    },
    GetQueuedCompletionStatusEx: {
      parameters: ["pointer", "pointer", "u32", "pointer", "u32", "i32"],
      result: "i32",
    },
    PostQueuedCompletionStatus: {
      parameters: ["pointer", "u32", "usize", "pointer"],
      result: "i32",
    },
    DeviceIoControl: {
      parameters: ["pointer", "u32", "pointer", "u32", "pointer", "u32", "pointer", "pointer"],
      result: "i32",
    },
    GetOverlappedResult: {
      parameters: ["pointer", "pointer", "pointer", "i32"],
      result: "i32",
    },
    CancelIoEx: {
      parameters: ["pointer", "pointer"],
      result: "i32",
    },
    CancelIo: {
      parameters: ["pointer"],
      result: "i32",
    },
    GetOverlappedResultEx: {
      parameters: ["pointer", "pointer", "pointer", "u32", "i32"],
      result: "i32",
    },
    CancelSynchronousIo: {
      parameters: ["pointer"],
      result: "i32",
    },
    BindIoCompletionCallback: {
      parameters: ["pointer", "pointer", "u32"],
      result: "i32",
    },
  }).symbols;
} catch(e) { /* ignore */ }

// Symbols

export function CreateIoCompletionPort(
  FileHandle: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  ExistingCompletionPort: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  CompletionKey: Deno.PointerValue /* usize */,
  NumberOfConcurrentThreads: number /* u32 */,
): Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */ {
  return util.pointerFromFfi(libKERNEL32.CreateIoCompletionPort(util.toPointer(FileHandle), util.toPointer(ExistingCompletionPort), CompletionKey, NumberOfConcurrentThreads));
}

export function GetQueuedCompletionStatus(
  CompletionPort: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  lpNumberOfBytesTransferred: Deno.PointerValue | Uint8Array | null /* ptr */,
  lpCompletionKey: Deno.PointerValue | Uint8Array | null /* ptr */,
  lpOverlapped: Deno.PointerValue | Uint8Array | null /* ptr */,
  dwMilliseconds: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.GetQueuedCompletionStatus(util.toPointer(CompletionPort), util.toPointer(lpNumberOfBytesTransferred), util.toPointer(lpCompletionKey), util.toPointer(lpOverlapped), dwMilliseconds));
}

export function GetQueuedCompletionStatusEx(
  CompletionPort: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  lpCompletionPortEntries: Deno.PointerValue | Uint8Array | null /* ptr */,
  ulCount: number /* u32 */,
  ulNumEntriesRemoved: Deno.PointerValue | Uint8Array | null /* ptr */,
  dwMilliseconds: number /* u32 */,
  fAlertable: boolean /* Windows.Win32.Foundation.BOOL */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.GetQueuedCompletionStatusEx(util.toPointer(CompletionPort), util.toPointer(lpCompletionPortEntries), ulCount, util.toPointer(ulNumEntriesRemoved), dwMilliseconds, util.boolToFfi(fAlertable)));
}

export function PostQueuedCompletionStatus(
  CompletionPort: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  dwNumberOfBytesTransferred: number /* u32 */,
  dwCompletionKey: Deno.PointerValue /* usize */,
  lpOverlapped: Deno.PointerValue | Uint8Array | null /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.PostQueuedCompletionStatus(util.toPointer(CompletionPort), dwNumberOfBytesTransferred, dwCompletionKey, util.toPointer(lpOverlapped)));
}

export function DeviceIoControl(
  hDevice: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  dwIoControlCode: number /* u32 */,
  lpInBuffer: Deno.PointerValue | Uint8Array | null /* ptr */,
  nInBufferSize: number /* u32 */,
  lpOutBuffer: Deno.PointerValue | Uint8Array | null /* ptr */,
  nOutBufferSize: number /* u32 */,
  lpBytesReturned: Deno.PointerValue | Uint8Array | null /* ptr */,
  lpOverlapped: Deno.PointerValue | Uint8Array | null /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.DeviceIoControl(util.toPointer(hDevice), dwIoControlCode, util.toPointer(lpInBuffer), nInBufferSize, util.toPointer(lpOutBuffer), nOutBufferSize, util.toPointer(lpBytesReturned), util.toPointer(lpOverlapped)));
}

export function GetOverlappedResult(
  hFile: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  lpOverlapped: Deno.PointerValue | Uint8Array | null /* ptr */,
  lpNumberOfBytesTransferred: Deno.PointerValue | Uint8Array | null /* ptr */,
  bWait: boolean /* Windows.Win32.Foundation.BOOL */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.GetOverlappedResult(util.toPointer(hFile), util.toPointer(lpOverlapped), util.toPointer(lpNumberOfBytesTransferred), util.boolToFfi(bWait)));
}

export function CancelIoEx(
  hFile: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  lpOverlapped: Deno.PointerValue | Uint8Array | null /* ptr */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.CancelIoEx(util.toPointer(hFile), util.toPointer(lpOverlapped)));
}

export function CancelIo(
  hFile: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.CancelIo(util.toPointer(hFile)));
}

export function GetOverlappedResultEx(
  hFile: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  lpOverlapped: Deno.PointerValue | Uint8Array | null /* ptr */,
  lpNumberOfBytesTransferred: Deno.PointerValue | Uint8Array | null /* ptr */,
  dwMilliseconds: number /* u32 */,
  bAlertable: boolean /* Windows.Win32.Foundation.BOOL */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.GetOverlappedResultEx(util.toPointer(hFile), util.toPointer(lpOverlapped), util.toPointer(lpNumberOfBytesTransferred), dwMilliseconds, util.boolToFfi(bAlertable)));
}

export function CancelSynchronousIo(
  hThread: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.CancelSynchronousIo(util.toPointer(hThread)));
}

export function BindIoCompletionCallback(
  FileHandle: Uint8Array | Deno.PointerValue | null /* Windows.Win32.Foundation.HANDLE */,
  Function: Uint8Array | Deno.PointerValue | null /* Windows.Win32.System.IO.LPOVERLAPPED_COMPLETION_ROUTINE */,
  Flags: number /* u32 */,
): boolean /* Windows.Win32.Foundation.BOOL */ {
  return util.boolFromFfi(libKERNEL32.BindIoCompletionCallback(util.toPointer(FileHandle), util.toPointer(Function), Flags));
}

